# Introducing Stagehand

> Developers use Stagehand to reliably automate the web.

Stagehand is a browser automation framework used to control web browsers with natural language and code. By combining the power of AI with the precision of code, Stagehand makes web automation flexible, maintainable, and actually reliable.

## The Problem with Browser Automation

Traditional frameworks like Playwright and Puppeteer force you to write brittle scripts that break with every UI change. Web agents promise to solve this with AI, but leave you at the mercy of unpredictable behavior.

**You're stuck between two bad options:**

* **Too brittle**: Traditional selectors break when websites change
* **Too agentic**: AI agents are unpredictable and impossible to debug

## Enter Stagehand

Stagehand gives you the best of both worlds through four powerful primitives that let you choose exactly how much AI to use:

<CardGroup cols={2}>
  <Card title="Act" icon="play" href="/v3/basics/act">
    Execute actions using natural language
  </Card>

  <Card title="Extract" icon="database" href="/v3/basics/extract">
    Pull structured data with schemas
  </Card>

  <Card title="Observe" icon="eye" href="/v3/basics/observe">
    Discover available actions on any page
  </Card>

  <Card title="Agent" icon="robot" href="/v3/basics/agent">
    Automate entire workflows autonomously
  </Card>
</CardGroup>

```typescript  theme={null}
// Act - Execute natural language actions
await stagehand.act("click the login button");

// Extract - Pull structured data
const price = await stagehand.extract(
  "extract the price",
  z.number()
);

// Observe - Discover available actions
const actions = await stagehand.observe("find submit buttons");

// Agent - Automate entire workflows
const agent = stagehand.agent({
  cua: true,
  model: "google/gemini-2.5-computer-use-preview-10-2025",
});
await agent.execute("apply for this job");
```

## Why Developers Choose Stagehand

* **Precise Control**: Mix AI-powered actions with deterministic code. You decide exactly how much AI to use.

* **Actually Repeatable**: Save and replay actions exactly. No more "it worked on my machine" with browser automations.

* **Maintainable at Scale**: One script can automate multiple websites. When sites change, your automations adapt.

* **Composable Tools**: Choose your level of automation with Act, Extract, Observe, and Agent.

## Built for Modern Development

Stagehand is designed for developers building production browser automations and AI agents that need reliable web access.

<AccordionGroup>
  <Accordion title="Works Everywhere">
    Compatible with all Chromium-based browsers: Chrome, Edge, Arc, Brave, and more.
  </Accordion>

  <Accordion title="Built by Browserbase">
    Created and maintained by the team behind enterprise browser infrastructure.
  </Accordion>
</AccordionGroup>

## Get Started in 60 Seconds

<Info>
  **Pro tip**: For best results, we recommend using Stagehand with [Browserbase](https://www.browserbase.com) for reliable cloud browser infrastructure.
</Info>

<CardGroup cols={2}>
  <Card title="Quickstart" icon="rocket" href="/v3/first-steps/quickstart">
    Build your first automation in under a minute
  </Card>

  <Card title="Try Director" icon="wand-magic-sparkles" href="https://www.director.ai">
    Generate Stagehand scripts with AI
  </Card>

  <Card title="View Examples" icon="code" href="https://github.com/browserbase/stagehand/tree/main/packages/core/examples">
    See real-world automation examples
  </Card>

  <Card title="Join Discord" icon="discord" href="https://discord.gg/stagehand">
    Get help from the community
  </Card>
</CardGroup>
# Quickstart

> Stagehand allows you to build web automations with natural language and code.

If this is your **first time using Stagehand**, you should try [Director](https://director.ai) first. It's an agent that allows you to build Stagehand workflows using natural language. You can also try Stagehand using our [MCP server](/integrations/mcp/introduction) .

Otherwise, the quickest way to start with Stagehand is with our CLI. It scaffolds a ready‑to‑run Stagehand app with sensible defaults, and an example script.

<Note>
  This quickstart is for **TypeScript**. For **Python**, see the [v2 installation guide](/v2/first-steps/installation).
</Note>

## 1) Create a sample project

<CodeGroup>
  ```bash Bash theme={null}
  npx create-browser-app
  ```
</CodeGroup>

## 2) Run it

Follow the CLI prompts to enter the project directory and add your API keys. Then run the example script.

<CodeGroup>
  ```bash Bash theme={null}
  cd my-stagehand-app # Enter the project directory
  cp .env.example .env  # Add your API keys
  npm start # Run the example script
  ```
</CodeGroup>

## 3) Use Stagehand (act, extract, observe)

The scaffold includes an index.ts file that contains the example script. Here's what it looks like:

<CodeGroup>
  ```typescript TypeScript theme={null}
  import "dotenv/config";
  import { Stagehand } from "@browserbasehq/stagehand";

  async function main() {
    const stagehand = new Stagehand({
      env: "BROWSERBASE"
    });

    await stagehand.init();

    console.log(`Stagehand Session Started`);
    console.log(`Watch live: https://browserbase.com/sessions/${stagehand.browserbaseSessionID}`);

    const page = stagehand.context.pages()[0];

    await page.goto("https://stagehand.dev");

    const extractResult = await stagehand.extract("Extract the value proposition from the page.");
    console.log(`Extract result:\n`, extractResult);

    await stagehand.act("Click the 'Evals' button.");

    const observeResult = await stagehand.observe("What can I click on this page?");
    console.log(`Observe result:\n`, observeResult);

    const agent = stagehand.agent({
      cua: true,
      model: "google/gemini-2.5-computer-use-preview-10-2025",
      systemPrompt: "You're a helpful assistant that can control a web browser.",
    });

    const agentResult = await agent.execute("What is the most accurate model to use in Stagehand?");
    console.log(`Agent result:\n`, agentResult);

    await stagehand.close();
  }

  main().catch((err) => {
    console.error(err);
    process.exit(1);
  });

  ```
</CodeGroup>

<Tip>
  To use, set provider keys in `.env` (e.g., `OPENAI_API_KEY`). For cloud browsers, add `BROWSERBASE_API_KEY` and `BROWSERBASE_PROJECT_ID`.
</Tip>

## Next steps

Learn about the Stagehand primitives: act, extract, observe, and agent.

<CardGroup cols={2}>
  <Card title="Act" icon="arrow-pointer" href="/v3/basics/act">
    Perform actions on web pages with natural language
  </Card>

  <Card title="Extract" icon="download" href="/v3/basics/extract">
    Get structured data with Zod schemas
  </Card>

  <Card title="Observe" icon="eye" href="/v3/basics/observe">
    Discover available elements and actions
  </Card>

  <Card title="Agent" icon="robot" href="/v3/basics/agent">
    Autonomous multi-step browser workflows
  </Card>
</CardGroup>
# Installation

> Integrate Stagehand into an existing project.

Install Stagehand in your current app with the TypeScript SDK.

<Tip>
  We recommend using the Node.js runtime environment to run Stagehand scripts.

  **Bun is now supported** as long as you do not integrate Stagehand with Playwright. Playwright is not compatible with Bun.
</Tip>

<Tabs>
  <Tab title="TypeScript">
    ### Install dependencies

    <CodeGroup>
      ```bash npm theme={null}
      npm install @browserbasehq/stagehand
      ```

      ```bash pnpm theme={null}
      pnpm add @browserbasehq/stagehand
      ```

      ```bash yarn theme={null}
      yarn add @browserbasehq/stagehand
      ```

      ```bash bun icon="sparkles" theme={null}
      bun add @browserbasehq/stagehand
      ```
    </CodeGroup>

    <Tip>
      If you plan to run locally, you need to have [Chrome](https://www.google.com/chrome/) installed on your machine. For cloud browser sessions, skip this.
    </Tip>

    ### Configure environment

    Set environment variables (or a `.env` via your framework):

    <CodeGroup>
      ```bash Bash theme={null}
      OPENAI_API_KEY=your_api_key
      BROWSERBASE_API_KEY=your_api_key
      BROWSERBASE_PROJECT_ID=your_project_id
      ```
    </CodeGroup>

    ### Use in your codebase

    Add Stagehand where you need browser automation.

    ```typescript  theme={null}
    import "dotenv/config";
    import { Stagehand } from "@browserbasehq/stagehand";
    import { z } from "zod/v3";

    async function main() {
      const stagehand = new Stagehand({
        env: "BROWSERBASE"
      });

      await stagehand.init();
      const page = stagehand.context.pages()[0];

      await page.goto("https://example.com");

      // Act on the page
      await stagehand.act("Click the learn more button");

      // Extract structured data
      const description = await stagehand.extract("extract the description", z.string());

      console.log(description);
      await stagehand.close();
    }

    main().catch((err) => {
      console.error(err);
      process.exit(1);
    });
    ```
  </Tab>

  <Tab title="Python">
    <Note>
      **Python support is only available in Stagehand v2.**

      v3 currently only supports TypeScript. If you need Python support, please use v2.
    </Note>

    <Card title="Install Stagehand v2 for Python" icon="python" href="/v2/first-steps/installation#python">
      View the Python installation guide for Stagehand v2
    </Card>
  </Tab>
</Tabs>

## Next steps

<CardGroup cols={2}>
  <Card title="Configuration" icon="gear" href="/v3/configuration/browser">
    Environment, Browserbase vs Local, logging, timeouts, LLM customization
  </Card>

  <Card title="Act" icon="arrow-pointer" href="/v3/basics/act">
    Perform precise actions with natural language
  </Card>

  <Card title="Extract" icon="download" href="/v3/basics/extract">
    Typed data extraction with Zod schemas
  </Card>

  <Card title="Observe" icon="eye" href="/v3/basics/observe">
    Discover elements and suggested actions
  </Card>
</CardGroup>
# AI Rules

> Using AI to write Stagehand code faster, and better.

You're likely using AI to write code, and there's a **right and wrong way to do it.** This page is a collection of rules, configs, and copy‑paste snippets to allow your AI agents/assistants to write performant, Stagehand code as fast as possible.

## Quickstart

<CardGroup cols={2}>
  <Card title="Add MCP servers" icon="screwdriver-wrench">
    Configure Browserbase (Stagehand), Context7, DeepWiki, and Stagehand Docs in your MCP client.
  </Card>

  <Card title="Pin editor rules" icon="memo">
    Drop in `cursorrules` and `claude.md` so AI agents/assistants always emit Stagehand patterns.
  </Card>
</CardGroup>

## Using MCP Servers

MCP (Model Context Protocol) servers act as intermediaries that connect AI systems to external data sources and tools. These servers enable your coding assistant to access real-time information, execute tasks, and retrieve structured data to enhance code generation accuracy.

The following **MCP servers** provide specialized access to Stagehand documentation and related resources:

<Accordion title="Context7 by Upstash" icon="database">
  Provides semantic search across documentation and codebase context. Context7 enables AI assistants to find relevant code patterns, examples, and implementation details from your project history. It maintains contextual understanding of your development workflow and can surface related solutions from previous work.

  **Installation:**

  ```json  theme={null}
  {
    "mcpServers": {
      "context7": {
        "command": "npx",
        "args": ["-y", "@upstash/context7-mcp"]
      }
    }
  }
  ```
</Accordion>

<Accordion title="DeepWiki by Cognition" icon="book-open">
  Offers deep indexing of GitHub repositories and documentation. DeepWiki allows AI agents to understand project architecture, API references, and best practices from the entire Stagehand ecosystem. It provides comprehensive knowledge about repository structure, code relationships, and development patterns.

  **Installation:**

  ```json  theme={null}
  {
    "mcpServers": {
      "deepwiki": {
        "url": "https://mcp.deepwiki.com/mcp"
      }
    }
  }
  ```
</Accordion>

<Accordion title="Stagehand Docs by Mintlify" icon="mintbit">
  Direct access to official Stagehand documentation. This MCP server provides AI assistants with up-to-date API references, configuration options, and usage examples for accurate code generation. Mintlify auto-generates this server from the official docs, ensuring your AI assistant always has the latest information.

  **Usage:**

  ```json  theme={null}
  {
    "mcpServers": {
      "stagehand-docs": {
        "url": "https://docs.stagehand.dev/mcp"
      }
    }
  }
  ```
</Accordion>

**How MCP Servers Enhance Your Development:**

* **Real-time Documentation Access**: AI assistants can query the latest Stagehand docs, examples, and best practices
* **Context-Aware Code Generation**: Servers provide relevant code patterns and configurations based on your specific use case
* **Reduced Integration Overhead**: Standardized protocol eliminates the need for custom integrations with each documentation source
* **Enhanced Accuracy**: AI agents receive structured, up-to-date information rather than relying on potentially outdated training data

<Tip>
  **Prompting tip:**
  Explicitly ask your coding agent/assistant to use these MCP servers to fetch relevant information from the docs so they have better context and know how to write proper Stagehand code.

  ie. **"Use the stagehand-docs MCP to fetch the act/observe guidelines, then generate code that follows them. Prefer cached observe results."**
</Tip>

## Editor rule files (copy‑paste)

Drop these in `.cursorrules`, `windsurfrules`, `claude.md`, or any agent rule framework:

<Accordion title="TypeScript">
  ````md  theme={null}
  # Stagehand Project

  This is a project that uses Stagehand V3, a browser automation framework with AI-powered `act`, `extract`, `observe`, and `agent` methods.

  The main class can be imported as `Stagehand` from `@browserbasehq/stagehand`.

  **Key Classes:**

  - `Stagehand`: Main orchestrator class providing `act`, `extract`, `observe`, and `agent` methods
  - `context`: A `V3Context` object that manages browser contexts and pages
  - `page`: Individual page objects accessed via `stagehand.context.pages()[i]` or created with `stagehand.context.newPage()`

  ## Initialize

  ```typescript
  import { Stagehand } from "@browserbasehq/stagehand";

  const stagehand = new Stagehand({
    env: "LOCAL", // or "BROWSERBASE"
    verbose: 2, // 0, 1, or 2
    model: "openai/gpt-4.1-mini", // or any supported model
  });

  await stagehand.init();

  // Access the browser context and pages
  const page = stagehand.context.pages()[0];
  const context = stagehand.context;

  // Create new pages if needed
  const page2 = await stagehand.context.newPage();
  ```

  ## Act

  Actions are called on the `stagehand` instance (not the page). Use atomic, specific instructions:

  ```typescript
  // Act on the current active page
  await stagehand.act("click the sign in button");

  // Act on a specific page (when you need to target a page that isn't currently active)
  await stagehand.act("click the sign in button", { page: page2 });
  ```

  **Important:** Act instructions should be atomic and specific:

  - ✅ Good: "Click the sign in button" or "Type 'hello' into the search input"
  - ❌ Bad: "Order me pizza" or "Type in the search bar and hit enter" (multi-step)

  ### Observe + Act Pattern (Recommended)

  Cache the results of `observe` to avoid unexpected DOM changes:

  ```typescript
  const instruction = "Click the sign in button";

  // Get candidate actions
  const actions = await stagehand.observe(instruction);

  // Execute the first action
  await stagehand.act(actions[0]);
  ```

  To target a specific page:

  ```typescript
  const actions = await stagehand.observe("select blue as the favorite color", {
    page: page2,
  });
  await stagehand.act(actions[0], { page: page2 });
  ```

  ## Extract

  Extract data from pages using natural language instructions. The `extract` method is called on the `stagehand` instance.

  ### Basic Extraction (with schema)

  ```typescript
  import { z } from "zod/v3";

  // Extract with explicit schema
  const data = await stagehand.extract(
    "extract all apartment listings with prices and addresses",
    z.object({
      listings: z.array(
        z.object({
          price: z.string(),
          address: z.string(),
        }),
      ),
    }),
  );

  console.log(data.listings);
  ```

  ### Simple Extraction (without schema)

  ```typescript
  // Extract returns a default object with 'extraction' field
  const result = await stagehand.extract("extract the sign in button text");

  console.log(result);
  // Output: { extraction: "Sign in" }

  // Or destructure directly
  const { extraction } = await stagehand.extract(
    "extract the sign in button text",
  );
  console.log(extraction); // "Sign in"
  ```

  ### Targeted Extraction

  Extract data from a specific element using a selector:

  ```typescript
  const reason = await stagehand.extract(
    "extract the reason why script injection fails",
    z.string(),
    { selector: "/html/body/div[2]/div[3]/iframe/html/body/p[2]" },
  );
  ```

  ### URL Extraction

  When extracting links or URLs, use `z.string().url()`:

  ```typescript
  const { links } = await stagehand.extract(
    "extract all navigation links",
    z.object({
      links: z.array(z.string().url()),
    }),
  );
  ```

  ### Extracting from a Specific Page

  ```typescript
  // Extract from a specific page (when you need to target a page that isn't currently active)
  const data = await stagehand.extract(
    "extract the placeholder text on the name field",
    { page: page2 },
  );
  ```

  ## Observe

  Plan actions before executing them. Returns an array of candidate actions:

  ```typescript
  // Get candidate actions on the current active page
  const [action] = await stagehand.observe("Click the sign in button");

  // Execute the action
  await stagehand.act(action);
  ```

  Observing on a specific page:

  ```typescript
  // Target a specific page (when you need to target a page that isn't currently active)
  const actions = await stagehand.observe("find the next page button", {
    page: page2,
  });
  await stagehand.act(actions[0], { page: page2 });
  ```

  ## Agent

  Use the `agent` method to autonomously execute complex, multi-step tasks.

  ### Basic Agent Usage

  ```typescript
  const page = stagehand.context.pages()[0];
  await page.goto("https://www.google.com");

  const agent = stagehand.agent({
    model: "google/gemini-2.0-flash",
    executionModel: "google/gemini-2.0-flash",
  });

  const result = await agent.execute({
    instruction: "Search for the stock price of NVDA",
    maxSteps: 20,
  });

  console.log(result.message);
  ```

  ### Computer Use Agent (CUA)

  For more advanced scenarios using computer-use models:

  ```typescript
  const agent = stagehand.agent({
    cua: true, // Enable Computer Use Agent mode
    model: "anthropic/claude-sonnet-4-20250514",
    // or "google/gemini-2.5-computer-use-preview-10-2025"
    systemPrompt: `You are a helpful assistant that can use a web browser.
      Do not ask follow up questions, the user will trust your judgement.`,
  });

  await agent.execute({
    instruction: "Apply for a library card at the San Francisco Public Library",
    maxSteps: 30,
  });
  ```

  ### Agent with Custom Model Configuration

  ```typescript
  const agent = stagehand.agent({
    cua: true,
    model: {
      modelName: "google/gemini-2.5-computer-use-preview-10-2025",
      apiKey: process.env.GEMINI_API_KEY,
    },
    systemPrompt: `You are a helpful assistant.`,
  });
  ```

  ### Agent with Integrations (MCP/External Tools)

  ```typescript
  const agent = stagehand.agent({
    integrations: [`https://mcp.exa.ai/mcp?exaApiKey=${process.env.EXA_API_KEY}`],
    systemPrompt: `You have access to the Exa search tool.`,
  });
  ```

  ## Advanced Features

  ### DeepLocator (XPath Targeting)

  Target specific elements across shadow DOM and iframes:

  ```typescript
  await page
    .deepLocator("/html/body/div[2]/div[3]/iframe/html/body/p")
    .highlight({
      durationMs: 5000,
      contentColor: { r: 255, g: 0, b: 0 },
    });
  ```

  ### Multi-Page Workflows

  ```typescript
  const page1 = stagehand.context.pages()[0];
  await page1.goto("https://example.com");

  const page2 = await stagehand.context.newPage();
  await page2.goto("https://example2.com");

  // Act/extract/observe operate on the current active page by default
  // Pass { page } option to target a specific page
  await stagehand.act("click button", { page: page1 });
  await stagehand.extract("get title", { page: page2 });
  ```
  ````
</Accordion>

<Accordion title="Python">
  ```md  theme={null}
  # Stagehand Python Project

  This is a project that uses [Stagehand Python](https://github.com/browserbase/stagehand-python), which provides AI-powered browser automation with `act`, `extract`, and `observe` methods.

  `Stagehand` is a class that provides configuration and browser automation capabilities with:
  - Pages accessed via `stagehand.context.pages()` or `stagehand.context.activePage()`
  - `stagehand.context`: A StagehandContext object (extends Playwright BrowserContext)
  - `stagehand.agent()`: Create AI-powered agents for autonomous multi-step workflows
  - `stagehand.init()`: Initialize the browser session
  - `stagehand.close()`: Clean up resources

  `Page` extends Playwright's Page class with AI-powered methods:
  - `act()`: Perform actions on web elements using natural language
  - `extract()`: Extract structured data from pages using schemas
  - `observe()`: Plan actions and get selectors before executing

  `Agent` provides autonomous Computer Use Agent capabilities:
  - `execute()`: Perform complex multi-step tasks using natural language instructions

  Use the following rules to write code for this project.

  - To plan an instruction like "click the sign in button", use Stagehand `observe` to get the action to execute.

  You can also pass in the following params:

  - The result of `observe` is a list of `ObserveResult` objects that can directly be used as params for `act` like this:
    
  - When writing code that needs to extract data from the page, use Stagehand `extract`. Use Pydantic models for schemas:

  ## Initialize

  ### Configuration Options

  Key configuration options in `StagehandConfig`:

  ## Act

  You can act directly with string instructions:

  Use variables for dynamic form filling:

  **Best Practices:**
  - Cache the results of `observe` to avoid unexpected DOM changes
  - Keep actions atomic and specific (e.g., "Click the sign in button" not "Sign in to the website")
  - Use specific, descriptive instructions

  Act `action` should be as atomic and specific as possible, i.e. "Click the sign in button" or "Type 'hello' into the search input".
  AVOID actions that are more than one step, i.e. "Order me pizza" or "Send an email to Paul asking him to call me".

  ## Extract

  ### Simple String Extraction

  ### Structured Extraction with Schema (Recommended)
  Always use Pydantic models for structured data extraction:

  ### Array Extraction
  For arrays, use List types:

  ### Complex Object Extraction
  For more complex data structures:

  ## Agent System

  Stagehand provides an Agent System for autonomous web browsing using Computer Use Agents (CUA).

  ### Creating Agents

  ### Agent Execution

  **Best Practices:**
  - Be specific with instructions: `"Fill out the contact form with name 'John Doe' and submit it"`
  - Break down complex tasks into smaller steps
  - Use error handling with try/except blocks
  - Combine agents for navigation with traditional methods for precise data extraction

  ## Project Structure Best Practices

  - Store configurations in environment variables or config files
  - Use async/await patterns consistently
  - Implement main automation logic in async functions
  - Use async context managers for resource management
  - Use type hints and Pydantic models for data validation
  - Handle exceptions appropriately with try/except blocks
  ```
</Accordion>

## Security notes

* Do not embed secrets in docs or rule files; use env vars in MCP configs.
* Avoid broad actions that may trigger unintended navigation; prefer `observe` first.

## Resources/references

* Context7 MCP (Upstash)
  * [https://github.com/upstash/context7](https://github.com/upstash/context7)
* DeepWiki MCP
  * [https://mcp.deepwiki.com/](https://mcp.deepwiki.com/)
* Stagehand Docs MCP (Mintlify)
  * [https://docs.stagehand.dev/mcp](https://docs.stagehand.dev/mcp)
# Act

> Interact with a web page

## What is `act()`?

```typescript  theme={null}
await stagehand.act("click on add to cart")
```

`act` enables Stagehand to perform **individual** actions on a web page. Use it to build self-healing and deterministic automations that adapt to website changes.

## Why use `act()`?

<CardGroup cols={2}>
  <Card title="Natural Language Instructions" icon="wand-magic-sparkles" href="#using-act">
    Write automation in plain English. No selectors or complex syntax.
  </Card>

  <Card title="Precise Control" icon="crosshairs" href="#best-practices">
    Build automations step by step. Define exactly what happens at every moment.
  </Card>

  <Card title="Self-Healing" icon="bandage" href="#ensure-reliable-actions">
    Actions automatically adapt when websites change.
  </Card>

  <Card title="Caching" icon="repeat" href="#reduce-model-costs">
    Cache actions to avoid LLM calls and ensure consistent execution across runs.
  </Card>
</CardGroup>

## Using `act()`

Use `act` to perform single actions in your automation. Here's how to click a button:

```typescript  theme={null}
await page.goto("https://example-store.com");
await stagehand.act("click the add to cart button");
```

<Note>
  **iFrame and Shadow DOM Support** Stagehand automatically handles iFrame traversal and shadow DOM elements without requiring additional configuration.
</Note>

With `act`, breaking complex actions into small, single-step actions works best. If you need to orchestrate multi-step flows, use multiple `act` commands or `agent`.

<Accordion title="Suggested actions">
  | Action               | Example instruction                |
  | -------------------- | ---------------------------------- |
  | Click                | `click the button`                 |
  | Fill                 | `fill the field with <value>`      |
  | Type                 | `type <text> into the search box`  |
  | Press                | `press <key> in the search field`  |
  | Scroll               | `scroll to <position>`             |
  | Select from dropdown | `select <value> from the dropdown` |
</Accordion>

### Return value of `act()`?

When you use `act()`, Stagehand will return a `Promise<ActResult>` with the following structure:

```typescript  theme={null}
{
  success: true,
  message: 'Action [click] performed successfully on selector: xpath=/html[1]/body[1]/div[1]/span[1] → Action [click] performed successfully on selector: xpath=/html[1]/body[1]/div[2]/div[1]/section[1]/div[1]/div[1]/div[25]',
  actionDescription: 'Favorite Colour',
  actions: [
    {
      selector: 'xpath=/html[1]/body[1]/div[1]/span[1]',
      description: 'Favorite Colour',
      method: 'click',
      arguments: []
    },
    {
      selector: 'xpath=/html[1]/body[1]/div[2]/div[1]/section[1]/div[1]/div[1]/div[25]',
      description: 'Peach',
      method: 'click',
      arguments: []
    }
  ]
}
```

<Tabs>
  <Tab title="Do this" icon="check">
    Break your task into single-step actions.

    ```typescript  theme={null}
    // Break it into single-step actions
    await stagehand.act("open the filters panel");
    await stagehand.act("choose 4-star rating");
    await stagehand.act("click the apply button");
    ```
  </Tab>

  <Tab title="Don't do this" icon="xmark">
    For multi-step tasks, use [`agent()`](/basics/agent) instead.

    ```typescript  theme={null}
    // Too complex - trying to do multiple things at once
    await stagehand.act("open the filters panel, choose 4-star rating, and click apply");
    ```
  </Tab>
</Tabs>

## Advanced Configuration

You can pass additional options to configure the model, timeout, variables, and target page:

```typescript  theme={null}
// Custom model configuration
await stagehand.act("choose 'Peach' from the favorite color dropdown", {
  model: {
    modelName: "google/gemini-2.5-flash",
    apiKey: process.env.GEMINI_API_KEY
  },
  timeout: 10000
});
```

### Using with Custom Pages

You can use `act()` with pages from other browser automation libraries like Puppeteer, Playwright, or Patchright by passing the `page` option:

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";
import puppeteer from "puppeteer-core";

const stagehand = new Stagehand({
  env: "BROWSERBASE",
});
await stagehand.init();

// Connect with Puppeteer
const browser = await puppeteer.connect({
  browserWSEndpoint: stagehand.connectURL(),
  defaultViewport: null,
});

const pages = await browser.pages();
const customPage = pages[0];

await customPage.goto("https://www.example.com/blog");

// Use act with the custom Puppeteer page
await stagehand.act("click the next page button", {
  page: customPage
});
```

This works with:

* **Puppeteer**: Pass Puppeteer Page objects
* **Playwright**: Pass Playwright Page objects
* **Patchright**: Pass Patchright Page objects
* **Stagehand Page**: Use `stagehand.context.pages()[0]` or `context.activePage()` (default)

<Card title="Complete API Reference" icon="book" href="/v3/references/act">
  See the full `act()` reference for detailed parameter documentation, return values, and advanced examples.
</Card>

## Best practices

### Ensure reliable actions

Use `observe()` to discover candidate actions on the current page and plan reliably. It returns a list of suggested actions (with selector, description, method, and arguments). You can pass an observed action directly to `act` to execute it.

```typescript  theme={null}
const [action] = await stagehand.observe("click the login button");

if (action) {
  await stagehand.act(action);
}
```

<Card title="Analyze pages with observe()" icon="magnifying-glass" iconType="sharp-solid" href="/v3/basics/observe">
  Plan actions with `observe()` before executing with `act`.
</Card>

### Reduce model costs

Enable automatic action caching by specifying a `cacheDir` when initializing Stagehand. The first time an action runs, it's cached. Subsequent runs reuse the cached action without LLM calls.

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";

// Enable caching by specifying a cache directory
const stagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "act-cache" // Actions are automatically cached here
});

await stagehand.init();
const page = stagehand.context.pages()[0];

// First run - makes LLM call and caches the action
await stagehand.act("click the login button");
```

<Note>
  Caching persists across script executions. The first time you run your script, actions are cached to your local filesystem. On subsequent runs, cached actions are reused automatically, significantly reducing costs and improving performance.
</Note>

<Card title="Complete caching guide" icon="database" iconType="sharp-solid" href="/v3/best-practices/caching">
  Learn advanced caching techniques and patterns for optimal performance.
</Card>

### Secure your automations

Variables are **not shared with LLM providers**. Use them for passwords, API keys, and other sensitive data.

<Note>
  Load sensitive data from environment variables using `.env` files. Never hardcode API keys, passwords, or other secrets directly in your code.
</Note>

```typescript  theme={null}
// Variables use %variableName% syntax in the instruction
await stagehand.act("type %username% into the email field", {
  variables: { username: "user@example.com" }
});

await stagehand.act("type %password% into the password field", {
  variables: { password: process.env.USER_PASSWORD }
});

await stagehand.act("click the login button");
```

<Warning>
  When handling sensitive data, set `verbose: 0` in your Stagehand configuration to prevent secrets from appearing in logs. See the [configuration guide](/configuration/browser) for more details.
</Warning>

<Card title="User Data Best Practices" icon="shield-check" iconType="sharp-solid" href="/v3/best-practices/user-data">
  Complete guide to securing your browser automations with best practices and configurations.
</Card>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Method not supported">
    **Problem**: `act` fails with "method not supported" error

    **Solutions**:

    * Use clear and detailed instructions for what you want to accomplish
    * Review our [evals](https://stagehand.dev/evals) to find the best models for your use case
    * Use [`observe()`](/basics/observe) and verify the resulting action is within a list of expected actions

    **Solution 1: Validate with observe**

    ```typescript  theme={null}
    const prompt = "click the submit button";
    const expectedMethod = "click";

    try {
      await stagehand.act(prompt);
    } catch (error) {
      if (error.message.includes("method not supported")) {
        // Observe the same prompt to get the planned action
        const [action] = await stagehand.observe(prompt);

        if (action && action.method === expectedMethod) {
          await stagehand.act(action);
        } else {
          throw new Error(`Unsupported method: expected "${expectedMethod}", got "${action?.method}"`);
        }
      } else {
        throw error;
      }
    }
    ```

    **Solution 2: Retry with exponential backoff**

    ```typescript  theme={null}
    // Retry with exponential backoff for intermittent issues
    const prompt = "click the submit button";
    const maxRetries = 3;

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        await stagehand.act(prompt, { timeout: 10000 + (attempt * 5000) });
        break; // Success, exit retry loop
      } catch (error) {
        if (error.message.includes("method not supported") && attempt < maxRetries) {
          // Exponential backoff: wait 2^attempt seconds
          const delay = Math.pow(2, attempt) * 1000;
          console.log(`Retry ${attempt + 1}/${maxRetries} after ${delay}ms`);
          await new Promise(resolve => setTimeout(resolve, delay));
        } else {
          throw error;
        }
      }
    }
    ```
  </Accordion>

  <Accordion title="Action failed or timed out">
    **Problem**: `act` times out or fails to complete action (often due to element not found)

    **Solutions**:

    * Ensure page has fully loaded
    * Check if content is in iframes: [Learn more about working with iframes](/best-practices/working-with-iframes)
    * Increase action timeout
    * Use `observe()` first to verify element exists

    ```typescript  theme={null}
    // Handle timeout and element not found issues
    try {
      await stagehand.act("click the submit button", { timeout: 30000 });
    } catch (error) {
      // Check if page is fully loaded
      await page.waitForLoadState('domcontentloaded');

      // Use observe to check element state
      const [element] = await stagehand.observe("find the submit button");

      if (element) {
        console.log("Element found, trying more specific instruction");
        await stagehand.act("click the submit button at the bottom of the form");
      } else {
        console.log("Element not found, trying alternative selector");
        await stagehand.act("click the button with text 'Submit'");
      }
    }
    ```
  </Accordion>

  <Accordion title="Incorrect element selected">
    **Problem**: `act` performs action on wrong element

    **Solutions**:

    * Be more specific in instructions: include visual cues, position, or context
    * Use `observe()` to preview which element will be selected
    * Add contextual information: "the search button in the header"
    * Use unique identifiers when available

    ```typescript  theme={null}
    // More precise element targeting
    // Instead of:
    await stagehand.act("click the button");

    // Use specific context:
    await stagehand.act("click the red 'Delete' button next to the user John Smith");

    // Or preview with observe first:
    const [action] = await stagehand.observe("click the submit button in the checkout form");
    if (action.description.includes("checkout")) {
      await stagehand.act(action);
    }
    ```
  </Accordion>
</AccordionGroup>

## Next steps

<CardGroup cols={2}>
  <Card title="Orchestrate complex workflows with Agent" icon="robot" iconType="sharp-solid" href="/v3/basics/agent">
    Use `Agent` to autonomously execute multi-step tasks and complex workflows.
  </Card>

  <Card title="Caching actions" icon="bolt" iconType="sharp-solid" href="/v3/best-practices/caching">
    Speed up repeated automations by caching actions.
  </Card>

  <Card title="Extract data with extract()" icon="table" iconType="sharp-solid" href="/v3/basics/extract">
    Use `extract` with a data schema to pull clean, typed data from any page.
  </Card>

  <Card title="Preview actions with observe()" icon="magnifying-glass" iconType="sharp-solid" href="/v3/basics/observe">
    Preview actions with `observe()` before executing them.
  </Card>
</CardGroup>
# Extract

> Extract structured data from a webpage

## What is `extract()`?

```typescript  theme={null}
await stagehand.extract("extract the name of the repository");
```

`extract` grabs structured data from a webpage. You can define your schema with [zod](https://github.com/colinhacks/zod) (TypeScript) or JSON. If you do not want to define a schema, you can also call `extract` with just a [natural language prompt](#extract-with-just-a-prompt), or call `extract` [with no parameters](#extract-with-no-parameters).

## Why use `extract()`?

<CardGroup cols={2}>
  <Card title="Structured" icon="brackets-curly" href="#list-of-objects-extraction">
    Turn messy webpage data into clean objects that follow a schema.
  </Card>

  <Card title="Resilient" icon="dumbbell" href="#extract-with-context">
    Build resilient extractions that don't break when the website changes
  </Card>
</CardGroup>

## Using `extract()`

You can use `extract()` to extract structured data from a webpage. You can define your schema with [zod](https://github.com/colinhacks/zod) (TypeScript) or JSON. If you do not want to define a schema, you can also call `extract` with just a natural language prompt, or call `extract` with no parameters.

```typescript  theme={null}
const result = await stagehand.extract("extract the product details");
```

### Return value of `extract()`?

When you use `extract()`, Stagehand will return a `Promise<ExtractResult>` with the following structure:

<Tabs>
  <Tab title="Basic Schema">
    When extracting with a schema, the return type is inferred from your Zod schema:

    ```typescript  theme={null}
    const result = await stagehand.extract(
      "extract product details",
      z.object({
        name: z.string(),
        price: z.number(),
        inStock: z.boolean()
      })
    );
    ```

    **Example result:**

    ```typescript  theme={null}
    {
      name: "Wireless Mouse",
      price: 29.99,
      inStock: true
    }
    ```
  </Tab>

  <Tab title="Array">
    When extracting an array, you get an array of objects:

    ```typescript  theme={null}
    const apartments = await stagehand.extract(
      "extract all apartment listings",
      z.array(
        z.object({
          address: z.string(),
          price: z.string(),
          sqft: z.number()
        })
      )
    );
    ```

    **Example result:**

    ```typescript  theme={null}
    [
      {
        address: "123 Main St",
        price: "$1,200/mo",
        sqft: 750
      },
      {
        address: "456 Oak Ave",
        price: "$1,500/mo",
        sqft: 900
      }
    ]
    ```
  </Tab>

  <Tab title="Primitive">
    When extracting a single primitive value:

    ```typescript  theme={null}
    const price = await stagehand.extract(
      "extract the price",
      z.number()
    );
    ```

    **Example result:**

    ```typescript  theme={null}
    19.99
    ```

    You can also extract strings, booleans, etc.:

    ```typescript  theme={null}
    const url = await stagehand.extract(
      "extract the contact page link",
      z.string().url()
    );
    ```
  </Tab>

  <Tab title="Instruction Only">
    When calling with just an instruction (no schema):

    ```typescript  theme={null}
    const result = await stagehand.extract("extract the repository name");
    ```

    **Example result:**

    ```typescript  theme={null}
    {
      extraction: "stagehand"
    }
    ```
  </Tab>

  <Tab title="No Parameters">
    When calling with no parameters:

    ```typescript  theme={null}
    const result = await stagehand.extract();
    ```

    **Example result:**

    ```typescript  theme={null}
    {
      pageText: "Accessibility Tree:\n[0-2] RootWebArea: Page Title\n  [0-37] scrollable\n    [0-118] body\n      ..."
    }
    ```

    This returns the accessibility tree representation of the page without LLM processing.
  </Tab>
</Tabs>

## Advanced Configuration

You can pass additional options to configure the model, timeout, and selector scope:

```typescript  theme={null}
const result = await stagehand.extract("extract the repository name", {
  model: "anthropic/claude-sonnet-4-5",
  timeout: 30000,
  selector: "//header" // Focus on specific area
});
```

### Targeted Extract

Pass a selector to `extract` to target a specific element on the page.

<Tip>
  This helps reduce the context passed to the LLM, optimizing token usage/speed and improving accuracy.
</Tip>

```typescript  theme={null}
const tableData = await stagehand.extract(
  "Extract the values of the third row",
  z.object({
    values: z.array(z.string())
  }),
  {
    // xPath or CSS selector
    selector: "xpath=/html/body/div/table/" 
  }
);
```

## Best practices

### Extract with Context

You can provide additional context to your schema to help the model extract the data more accurately.

```typescript  theme={null}
const apartments = await stagehand.extract(
  "Extract ALL the apartment listings and their details, including address, price, and square feet.",
  z.array(
    z.object({
      address: z.string().describe("the address of the apartment"),
      price: z.string().describe("the price of the apartment"),
      square_feet: z.string().describe("the square footage of the apartment"),
    })
  )
);
```

### Link Extraction

<Note>
  To extract links or URLs, define the relevant field as `z.string().url()`.
</Note>

Here is how an `extract` call might look for extracting a link or URL. This also works for image links.

```typescript  theme={null}
const contactLink = await stagehand.extract(
  "extract the link to the 'contact us' page",
  z.string().url() // note the usage of z.string().url() for URL validation
);

console.log("the link to the contact us page is: ", contactLink);
```

<Tip>
  Inside Stagehand, extracting links works by asking the LLM to select an ID. Stagehand looks up that ID in a mapping of IDs -> URLs. When logging the LLM trace, you should expect to see IDs. The actual URLs will be included in the final `ExtractResult`.
</Tip>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Empty or partial results">
    **Problem**: `extract()` returns empty or incomplete data

    **Solutions**:

    * **Check your instruction clarity**: Make sure your instruction is specific and describes exactly what data you want to extract
    * **Verify the data exists**: Use `stagehand.observe()` first to confirm the data is present on the page
    * **Wait for dynamic content**: If the page loads content dynamically, use `stagehand.act("wait for the content to load")` before extracting

    **Solution: Wait for content before extracting**

    ```typescript  theme={null}
    // Wait for content before extracting
    await stagehand.act("wait for the product listings to load");
    const products = await stagehand.extract(
      "extract all product names and prices",
      z.array(z.object({
        name: z.string(),
        price: z.string()
      }))
    );
    ```
  </Accordion>

  <Accordion title="Schema validation errors">
    **Problem**: Getting schema validation errors or type mismatches

    **Solutions**:

    * **Use optional fields**: Make fields optional with `z.optional()` if the data might not always be present
    * **Use flexible types**: Consider using `z.string()` instead of `z.number()` for prices that might include currency symbols
    * **Add descriptions**: Use `.describe()` to help the model understand field requirements

    **Solution: More flexible schema**

    ```typescript  theme={null}
    const schema = z.object({
      price: z.string().describe("price including currency symbol, e.g., '$19.99'"),
      availability: z.string().optional().describe("stock status if available"),
      rating: z.number().optional()
    });
    ```
  </Accordion>

  <Accordion title="Inconsistent results">
    **Problem**: Extraction results vary between runs

    **Solutions**:

    * **Be more specific in instructions**: Instead of "extract prices", use "extract the numerical price value for each item"
    * **Use context in schema descriptions**: Add field descriptions to guide the model
    * **Combine with observe**: Use `stagehand.observe()` to understand the page structure first

    **Solution: Validate with observe first**

    ```typescript  theme={null}
    // First observe to understand the page structure
    const elements = await stagehand.observe("find all product listings");
    console.log("Found elements:", elements.map(e => e.description));

    // Then extract with specific targeting
    const products = await stagehand.extract(
      "extract name and price from each product listing shown on the page",
      z.array(z.object({
        name: z.string().describe("the product title or name"),
        price: z.string().describe("the price as displayed, including currency")
      }))
    );
    ```
  </Accordion>

  <Accordion title="Performance issues">
    **Problem**: Extraction is slow or timing out

    **Solutions**:

    * **Reduce scope**: Extract smaller chunks of data in multiple calls rather than everything at once
    * **Use targeted instructions**: Be specific about which part of the page to focus on
    * **Consider pagination**: For large datasets, extract one page at a time
    * **Increase timeout**: Use `timeoutMs` parameter for complex extractions

    **Solution: Break down large extractions**

    ```typescript  theme={null}
    // Instead of extracting everything at once
    const allData = [];
    const pageNumbers = [1, 2, 3, 4, 5];

    for (const pageNum of pageNumbers) {
      await stagehand.act(`navigate to page ${pageNum}`);

      const pageData = await stagehand.extract(
        "extract product data from the current page only",
        z.array(z.object({
          name: z.string(),
          price: z.number()
        })),
        { timeout: 60000 } // 60 second timeout
      );

      allData.push(...pageData);
    }
    ```
  </Accordion>
</AccordionGroup>

## Next steps

<CardGroup cols={2}>
  <Card title="Act" icon="play" href="/v3/basics/act">
    Execute actions efficiently
  </Card>

  <Card title="Observe" icon="magnifying-glass" href="/v3/basics/observe">
    Analyze pages and preview actions
  </Card>
</CardGroup>
# Observe

> Discover and plan executable actions on any web page

## What is `observe()`?

```typescript  theme={null}
await stagehand.observe("find the login button");
```

`observe()` discovers actionable elements on a page and returns structured actions you can execute or validate before acting. Use it to explore pages, plan multi-step workflows, cache actions, and validate elements before acting.

## Why use `observe()`?

<CardGroup cols={2}>
  <Card title="Explore" icon="compass" href="#using-observe">
    Discover what's possible on a page—find buttons, forms, links, and interactive elements
  </Card>

  <Card title="Plan" icon="map" href="#plan-then-execute">
    Map out multi-step workflows by discovering all required actions upfront
  </Card>

  <Card title="Cache" icon="database" href="/v3/best-practices/caching">
    Store discovered actions to skip LLM calls and speed up repeated workflows
  </Card>

  <Card title="Validate" icon="check" href="#validate-before-acting">
    Verify elements exist and check their properties before performing critical actions
  </Card>
</CardGroup>

## Using `observe()`

Use `observe()` to discover actionable elements on a page. Here's how to find a button:

```typescript  theme={null}
const page = stagehand.context.pages()[0];
await page.goto("https://example.com");
const actions = await stagehand.observe("find the learn more button");
```

<Note>
  **iFrame and Shadow DOM Support** Stagehand automatically handles iFrame traversal and shadow DOM elements without requiring additional configuration.
</Note>

<Accordion title="Common use cases">
  | Use Case          | Example instruction                 |
  | ----------------- | ----------------------------------- |
  | Find buttons      | `find the submit button`            |
  | Locate forms      | `find all input fields in the form` |
  | Discover links    | `find navigation links`             |
  | Identify tables   | `find the pricing table`            |
  | Map workflows     | `find all checkout steps`           |
  | Validate elements | `find the delete account button`    |
</Accordion>

### Return value of `observe()`?

When you use `observe()`, Stagehand will return a `Promise<Action[]>` with the following structure:

```typescript  theme={null}
[
  {
    description: 'Learn more button',
    method: 'click',
    arguments: [],
    selector: 'xpath=/html[1]/body[1]/shadow-demo[1]//div[1]/button[1]'
  }
]
```

<Tabs>
  <Tab title="Do this">
    Use specific, descriptive instructions.

    ```typescript  theme={null}
    // Clear and specific
    await stagehand.observe("find the primary call-to-action button in the hero section");
    await stagehand.observe("find all input fields in the checkout form");
    await stagehand.observe("find the delete account button in settings");
    ```
  </Tab>

  <Tab title="Don't do this">
    Avoid vague or data-oriented queries.

    ```typescript  theme={null}
    // Too vague
    await stagehand.observe("find buttons");

    // Use extract() for data instead
    await stagehand.observe("what is the page title?");
    ```
  </Tab>
</Tabs>

## Advanced Configuration

You can pass additional options to configure the model, timeout, and selector scope:

```typescript  theme={null}
// Custom model configuration
const actions = await stagehand.observe("find navigation links", {
  model: "openai/gpt-4o",
  timeout: 30000,
  selector: "//header" // Focus on specific area
});
```

### Using with Custom Pages

You can use `observe()` with pages from other browser automation libraries like Puppeteer, Playwright, or Patchright by passing the `page` option:

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";
import puppeteer from "puppeteer-core";

const stagehand = new Stagehand({
  env: "BROWSERBASE",
});
await stagehand.init();

// Connect with Puppeteer
const browser = await puppeteer.connect({
  browserWSEndpoint: stagehand.connectURL(),
  defaultViewport: null,
});

const pages = await browser.pages();
const customPage = pages[0];

await customPage.goto("https://www.example.com/products");

// Use observe with the custom Puppeteer page
const actions = await stagehand.observe("find all product cards", {
  page: customPage
});
```

This works with:

* **Puppeteer**: Pass Puppeteer Page objects
* **Playwright**: Pass Playwright Page objects
* **Patchright**: Pass Patchright Page objects
* **Stagehand Context Pages**: Access pages via `stagehand.context.pages()` (default)

<Card title="Complete API Reference" icon="book" href="/v3/references/observe">
  See the full `observe()` reference for detailed parameter documentation, return values, and advanced examples.
</Card>

## Best practices

### Plan then execute

Discover all actions once, then execute without additional LLM calls. This approach is 2-3x faster than separate `act()` calls.

```typescript  theme={null}
const formFields = await stagehand.observe("find all form input fields");

for (const field of formFields) {
  await stagehand.act(field); // No LLM call
}
```

<Card title="Analyze pages with observe()" icon="magnifying-glass" href="/v3/references/observe">
  Complete guide to planning actions with `observe()`.
</Card>

### Scope extractions

Use `observe()` to narrow extraction scope and reduce token usage by up to 10x.

```typescript  theme={null}
const [table] = await stagehand.observe("find the pricing table");

const pricing = await stagehand.extract({
  instruction: "extract all pricing tiers",
  schema: PricingSchema,
  selector: table.selector
});
```

<Card title="Extract structured data" icon="table" href="/v3/basics/extract">
  Learn how to use `observe()` with `extract()` for precise data extraction.
</Card>

### Validate before acting

Check elements exist and verify their properties before performing critical operations.

```typescript  theme={null}
const [deleteButton] = await stagehand.observe("find the delete account button");

if (deleteButton?.method === "click") {
  await stagehand.act(deleteButton);
} else {
  throw new Error("Delete button not found");
}
```

<Card title="Execute actions with act()" icon="play" href="/v3/basics/act">
  Learn how to execute observed actions reliably.
</Card>

### Cache observed actions

Store and reuse observed actions to eliminate redundant LLM calls. Build a simple cache:

```typescript  theme={null}
const actionCache = new Map<string, Action[]>();

async function cachedObserve(instruction: string) {
  if (actionCache.has(instruction)) {
    return actionCache.get(instruction)!;
  }

  const actions = await stagehand.observe(instruction);
  actionCache.set(instruction, actions);
  return actions;
}
```

<Card title="Complete caching guide" icon="database" href="/v3/best-practices/caching">
  Learn advanced caching techniques and patterns for optimal performance.
</Card>

## Troubleshooting

<AccordionGroup>
  <Accordion title="No elements found">
    **Problem**: `observe()` returns empty array

    **Solutions**:

    * Verify the element exists on the page
    * Use more specific instructions (e.g., "find the blue submit button" instead of "find button")
    * Ensure page has fully loaded before calling `observe()`
    * Enable verbose logging in Stagehand configuration to inspect detection behavior

    ```typescript  theme={null}
    // Check page state before observing
    const page = stagehand.context.pages()[0];
    await page.waitForLoadState('domcontentloaded');

    const actions = await stagehand.observe("find the submit button");

    if (actions.length === 0) {
      console.log("No elements found, trying alternative instruction");
      const altActions = await stagehand.observe("find the button at the bottom of the form");
    }
    ```
  </Accordion>

  <Accordion title="Inaccurate results">
    **Problem**: Descriptions or selectors don't match actual elements

    **Solutions**:

    * Use more capable models—check [model evals](https://stagehand.dev/evals) for recommendations
    * Provide more context in your instruction (e.g., "find the submit button in the checkout form")
    * Enable verbose logging and `logInferenceToFile` in Stagehand configuration to inspect LLM reasoning

    ```typescript  theme={null}
    // More specific instructions improve accuracy
    // Instead of:
    await stagehand.observe("find the button");

    // Use context:
    await stagehand.observe("find the red 'Delete' button in the user settings panel");
    ```
  </Accordion>

  <Accordion title="Wrong method suggested">
    **Problem**: The `method` field has an unexpected value

    **Solutions**:

    * Validate the method before using it: `if (action.method === "click") { ... }`
    * Check [supported actions](/v3/basics/act) for valid method names
    * Override with a specific method when needed: `await stagehand.act({ ...action, method: "click" })`

    ```typescript  theme={null}
    const [action] = await stagehand.observe("find the submit button");

    // Validate method before acting
    const validMethods = ["click", "fill", "type", "press"];
    if (action && validMethods.includes(action.method || "")) {
      await stagehand.act(action);
    } else {
      console.warn(`Unexpected method: ${action?.method}`);
    }
    ```
  </Accordion>
</AccordionGroup>

## Next steps

<CardGroup cols={2}>
  <Card title="Execute actions with act()" icon="play" href="/v3/basics/act">
    Use `act()` to execute discovered actions reliably.
  </Card>

  <Card title="Extract structured data" icon="table" href="/v3/basics/extract">
    Combine `observe()` with `extract()` for precise data extraction.
  </Card>

  <Card title="Caching actions" icon="bolt" href="/v3/best-practices/caching">
    Build action caches to eliminate redundant LLM calls.
  </Card>

  <Card title="Complete API Reference" icon="book" href="/v3/references/observe">
    Full `observe()` reference with detailed parameter documentation.
  </Card>
</CardGroup>
# Agent

> Automate complex workflows with AI powered browser agents

## What is `agent()?`

```typescript  theme={null}
await agent.execute("apply for a job at browserbase")
```

`agent` turns high level tasks into **fully autonomous** browser workflows. You can customize the agent by specifying the LLM provider and model, setting custom instructions for behavior, and configuring max steps.

<img src="https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/agent.gif?s=aa88d1c68cd28b84f1fc1366c3d9f2fc" alt="Agent" data-og-width="800" width="800" data-og-height="450" height="450" data-path="images/agent.gif" data-optimize="true" data-opv="3" />

## Why use `agent()`?

<CardGroup cols={2}>
  <Card title="Multi-Step Workflows" icon="route" href="#agent-execution-configuration">
    Execute complex sequences automatically.
  </Card>

  <Card title="Visual Understanding" icon="eye" href="/v3/best-practices/computer-use">
    Sees and understands web interfaces like humans do using computer vision.
  </Card>
</CardGroup>

## Using `agent()`

There are two ways to create agents in Stagehand:

1. Use a Computer Use Agent
2. Use Agent with any LLM (non-computer-use)

### Computer Use Agents

You can use specialized computer use models from either Google, OpenAI, or Anthropic as shown below, with `cua` set to `true`. To compare the performance of different computer use models, you can visit our [evals page](https://www.stagehand.dev/agent-evals).

<CodeGroup>
  ```typescript Google theme={null}
  const agent = stagehand.agent({
      cua: true,
      model: {
          modelName: "google/gemini-2.5-computer-use-preview-10-2025",
          apiKey: process.env.GOOGLE_GENERATIVE_AI_API_KEY
      },
      systemPrompt: "You are a helpful assistant...",
  });

  await agent.execute({
      instruction: "Go to Hacker News and find the most controversial post from today, then read the top 3 comments and summarize the debate.",
      maxSteps: 20,
      highlightCursor: true
  })
  ```

  ```typescript OpenAI theme={null}
  const agent = stagehand.agent({
      cua: true,
      model: {
          modelName: "openai/computer-use-preview",
          apiKey: process.env.OPENAI_API_KEY
      },
      systemPrompt: "You are a helpful assistant...",
  });

  await agent.execute({
      instruction: "Go to Hacker News and find the most controversial post from today, then read the top 3 comments and summarize the debate.",
      maxSteps: 20,
      highlightCursor: true
  })
  ```

  ```typescript Anthropic theme={null}
  const agent = stagehand.agent({
      cua: true,
      model: {
          modelName: "anthropic/claude-sonnet-4-20250514",
          apiKey: process.env.ANTHROPIC_API_KEY
      },
      systemPrompt: "You are a helpful assistant...",
  });

  await agent.execute({
      instruction: "Go to Hacker News and find the most controversial post from today, then read the top 3 comments and summarize the debate.",
      maxSteps: 20,
      highlightCursor: true
  })
  ```
</CodeGroup>

<Callout icon="code" color="#6ec202" iconType="regular">View or run the example template [here](https://www.browserbase.com/templates/gemini-cua)</Callout>

### Use Stagehand Agent with Any LLM

Use the agent without specifying a provider to utilize any model or LLM provider:

<Note>Non CUA agents are currently only supported in TypeScript</Note>

```typescript TypeScript theme={null}
const agent = stagehand.agent();
await agent.execute("apply for a job at Browserbase")
```

<Card title="Available Agent Models" icon="robot" href="/v3/configuration/models#agent-models-with-cua-support">
  Check out the guide on how to use different models with Stagehand Agent.
</Card>

### Return value of `agent()`?

When you use `agent()`, Stagehand will return a `Promise<AgentResult>` with the following structure:

```typescript  theme={null}
{
  success: true,
  message: "The first name and email fields have been filled successfully with 'John' and 'john@example.com'.",
  actions: [
    {
      type: 'ariaTree',
      reasoning: undefined,
      taskCompleted: true,
      pageUrl: 'https://example.com',
      timestamp: 1761598722055
    },
    {
      type: 'act',
      reasoning: undefined,
      taskCompleted: true,
      action: 'type "John" into the First Name textbox',
      playwrightArguments: {...},
      pageUrl: 'https://example.com',
      timestamp: 1761598731643
    },
    {
      type: 'close',
      reasoning: "The first name and email fields have been filled successfully.",
      taskCompleted: true,
      taskComplete: true,
      pageUrl: 'https://example.com',
      timestamp: 1761598732861
    }
  ],
  completed: true,
  usage: {
    input_tokens: 2040,
    output_tokens: 28,
    reasoning_tokens: 12,
    cached_input_tokens: 0,
    inference_time_ms: 14079
  }
}
```

## Custom Tools

Agents can be enhanced with custom tools for more granular control and better performance. Unlike MCP integrations, custom tools are defined inline and execute directly within your application.

<Note>Custom tools provide a cleaner, more performant alternative to MCP integrations when you need specific functionality.</Note>

### Defining Custom Tools

Use the `tool` helper from the [Vercel AI SDK](https://ai-sdk.dev/docs/ai-sdk-core/tools-and-tool-calling) to define custom tools:

<CodeGroup>
  ```typescript Basic Tool theme={null}
  import { tool } from "ai";
  import { z } from "zod/v3";

  const agent = stagehand.agent({
    model: "openai/gpt-5",
    tools: {
      getWeather: tool({
        description: 'Get the current weather in a location',
        inputSchema: z.object({
          location: z.string().describe('The location to get weather for'),
        }),
        execute: async ({ location }) => {
          // Your custom logic here
          const weather = await fetchWeatherAPI(location);
          return {
            location,
            temperature: weather.temp,
            conditions: weather.conditions,
          };
        },
      }),
    },
    systemPrompt: 'You are a helpful assistant with access to weather data.',
  });

  await agent.execute("What's the weather in San Francisco and should I bring an umbrella?");
  ```

  ```typescript Multiple Tools theme={null}
  import { tool } from "ai";
  import { z } from "zod/v3";

  const agent = stagehand.agent({
    cua: true,
    model: "anthropic/claude-sonnet-4-20250514",
    tools: {
      searchDatabase: tool({
        description: 'Search for records in the database',
        inputSchema: z.object({
          query: z.string().describe('The search query'),
          limit: z.number().optional().describe('Max results to return'),
        }),
        execute: async ({ query, limit = 10 }) => {
          const results = await db.search(query, limit);
          return { results };
        },
      }),

      calculatePrice: tool({
        description: 'Calculate the total price with tax',
        inputSchema: z.object({
          amount: z.number().describe('The base amount'),
          taxRate: z.number().describe('Tax rate as decimal (e.g., 0.08 for 8%)'),
        }),
        execute: async ({ amount, taxRate }) => {
          const total = amount * (1 + taxRate);
          return { total: total.toFixed(2) };
        },
      }),
    },
  });

  await agent.execute("Find products under $50 and calculate the total with 8% tax");
  ```

  ```typescript Tool with API Integration theme={null}
  import { tool } from "ai";
  import { z } from "zod/v3";

  const agent = stagehand.agent({
    model: "google/gemini-2.0-flash",
    tools: {
      sendEmail: tool({
        description: 'Send an email via SendGrid',
        inputSchema: z.object({
          to: z.string().email().describe('Recipient email address'),
          subject: z.string().describe('Email subject'),
          body: z.string().describe('Email body content'),
        }),
        execute: async ({ to, subject, body }) => {
          const response = await fetch('https://api.sendgrid.com/v3/mail/send', {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${process.env.SENDGRID_API_KEY}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              personalizations: [{ to: [{ email: to }] }],
              from: { email: 'noreply@example.com' },
              subject,
              content: [{ type: 'text/plain', value: body }],
            }),
          });

          return {
            sent: response.ok,
            messageId: response.headers.get('X-Message-Id'),
          };
        },
      }),
    },
  });

  await agent.execute("Fill out the contact form and send me a confirmation email at user@example.com");
  ```
</CodeGroup>

### Custom Tools vs MCP Integrations

| Custom Tools                           | MCP Integrations                 |
| -------------------------------------- | -------------------------------- |
| Defined inline with your code          | Connect to external services     |
| Direct function execution              | Standard protocol                |
| Better performance & optimized context | Reusable across applications     |
| Type-safe with TypeScript              | Access to pre-built integrations |
| Granular control                       | Network-based communication      |

<Tip>
  Use custom tools when you need specific functionality within your application. Use MCP integrations when connecting to external services or when you need standardized cross-application tools.
</Tip>

## MCP Integrations

Agents can be enhanced with external tools and services through MCP (Model Context Protocol) integrations. This allows your agent to access external APIs and data sources beyond just browser interactions.

<CodeGroup>
  ```typescript Pass URL theme={null}
  const agent = stagehand.agent({
      cua: true,
      model: {
          modelName: "openai/computer-use-preview",
          apiKey: process.env.OPENAI_API_KEY
      },
      integrations: [
        `https://mcp.exa.ai/mcp?exaApiKey=${process.env.EXA_API_KEY}`,
      ],
      systemPrompt: `You have access to web search through Exa. Use it to find current information before browsing.`
  });

  await agent.execute("Search for the best headphones of 2025 and go through checkout for the top recommendation");
  ```

  ```typescript Create Connection theme={null}
  import { connectToMCPServer } from "@browserbasehq/stagehand";

  const supabaseClient = await connectToMCPServer(
    `https://server.smithery.ai/@supabase-community/supabase-mcp/mcp?api_key=${process.env.SMITHERY_API_KEY}`
  );

  const agent = stagehand.agent({
      cua: true,
      model: {
          modelName: "openai/computer-use-preview",
          apiKey: process.env.OPENAI_API_KEY
      },
      integrations: [supabaseClient],
      systemPrompt: `You can interact with Supabase databases. Use these tools to store and retrieve data.`
  });

  await agent.execute("Search for restaurants and save the first result to the database");
  ```
</CodeGroup>

<Tip>
  MCP integrations enable agents to be more powerful by combining browser automation with external APIs, databases, and services. The agent can intelligently decide when to use browser actions versus external tools.
</Tip>

## Agent Execution Configuration

<Warning>
  Stagehand uses a 1288x711 viewport by default. Other viewport sizes may reduce performance. If you need to modify the viewport, you can edit in the [Browser Configuration](/v3/configuration/browser).
</Warning>

Control the maximum number of steps the agent can take to complete the task using the `maxSteps` parameter.

<CodeGroup>
  ```typescript TypeScript theme={null}
  // Set maxSteps to control how many actions the agent can take
  await agent.execute({
    instruction: "Sign me up for a library card",
    maxSteps: 15 // Agent will stop after 15 steps if task isn't complete
  });
  ```

  For complex tasks, increase the `maxSteps` limit and check task success.

  ```typescript  theme={null}
  // Complex multi-step task requiring more actions
  const result = await agent.execute({
    instruction: "Find and apply for software engineering jobs, filtering by remote work and saving 3 applications",
    maxSteps: 30, // Higher limit for complex workflows
  });

  // Check if the task completed successfully
  if (result.success === true) {
    console.log("Task completed successfully!");
  } else {
    console.log("Task failed or was incomplete");
  }
  ```
</CodeGroup>

## Best Practices

Following these best practices will improve your agent's success rate, reduce execution time, and minimize unexpected errors during task completion.

### Start on the Right Page

Navigate to your target page before executing tasks:

<Tabs>
  <Tab title="Do this">
    ```typescript  theme={null}
    await page.goto('https://github.com/browserbase/stagehand');
    await agent.execute('Get me the latest PR on the stagehand repo');
    ```
  </Tab>

  <Tab title="Don't do this">
    ```typescript  theme={null}
    await agent.execute('Go to GitHub and find the latest PR on browserbase/stagehand');
    ```
  </Tab>
</Tabs>

### Be Specific

Provide detailed instructions for better results:

<Tabs>
  <Tab title="Do this">
    ```typescript  theme={null}
    await agent.execute("Find Italian restaurants in Brooklyn that are open after 10pm and have outdoor seating");
    ```
  </Tab>

  <Tab title="Don't do this">
    ```typescript  theme={null}
    await agent.execute("Find a restaurant");
    ```
  </Tab>
</Tabs>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Agent is stopping before completing the task">
    **Problem**: Agent stops before finishing the requested task

    **Solutions**:

    * Check if the agent is hitting the maxSteps limit (default is 20)
    * Increase maxSteps for complex tasks: `maxSteps: 30` or higher
    * Break very complex tasks into smaller sequential executions

    ```typescript  theme={null}
    // Increase maxSteps for complex tasks
    await agent.execute({
      instruction: "Complete the multi-page registration form with all required information",
      maxSteps: 40 // Increased limit for complex task
    });

    // Or break into smaller tasks with success checking
    const firstResult = await agent.execute({
      instruction: "Fill out page 1 of the registration form", 
      maxSteps: 15
    });

    // Only proceed if the first task was successful
    if (firstResult.success === true) {
      await agent.execute({
        instruction: "Navigate to page 2 and complete remaining fields",
        maxSteps: 15
      });
    } else {
      console.log("First task failed, stopping execution");
    }
    ```
  </Accordion>

  <Accordion title="Agent is failing to click the proper elements">
    **Problem**: Agent clicks on wrong elements or fails to interact with the correct UI components

    **Solutions**:

    * Ensure proper viewport size: Stagehand uses `1288x711` by default (optimal for Computer Use models)
    * Avoid changing viewport dimensions as other sizes may reduce performance
  </Accordion>
</AccordionGroup>

## Next steps

<CardGroup cols={2}>
  <Card title="Act" icon="play" href="/v3/basics/act">
    Execute actions efficiently using observe results
  </Card>

  <Card title="Extract" icon="download" href="/v3/basics/extract">
    Extract structured data from observed elements
  </Card>
</CardGroup>
# Evaluations & Metrics

> Monitor performance, optimize costs, and evaluate LLM effectiveness

Evaluations help you understand how well your automation performs, which models work best for your use cases, and how to optimize for cost and reliability. This guide covers both monitoring your own workflows and running comprehensive evaluations.

## Why Evaluations Matter

* **Performance Optimization**: Identify which models and settings work best for your specific automation tasks
* **Cost Control**: Track token usage and inference time to optimize spending
* **Reliability**: Measure success rates and identify failure patterns
* **Model Selection**: Compare different LLMs on real-world tasks to make informed decisions

<Card title="Live Model Comparisons" icon="scale-balanced" href="https://www.stagehand.dev/evals">
  View real-time performance comparisons across different LLMs on the [Stagehand Evals Dashboard](https://www.stagehand.dev/evals)
</Card>

## Comprehensive Evaluations

Evaluations help you systematically test and improve your automation workflows. Stagehand provides both built-in evaluations and tools to create your own.

### Evals CLI

<img src="https://mintcdn.com/stagehand/cNbobmBIOozFHVDo/media/evals-cli.png?fit=max&auto=format&n=cNbobmBIOozFHVDo&q=85&s=f6215490cb3d017c099db4cc047941f1" alt="Evals CLI" data-og-width="856" width="856" data-og-height="592" height="592" data-path="media/evals-cli.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/stagehand/cNbobmBIOozFHVDo/media/evals-cli.png?w=280&fit=max&auto=format&n=cNbobmBIOozFHVDo&q=85&s=9e882081983b6eabb875e2ade4ae4cdc 280w, https://mintcdn.com/stagehand/cNbobmBIOozFHVDo/media/evals-cli.png?w=560&fit=max&auto=format&n=cNbobmBIOozFHVDo&q=85&s=27c7c23f3d8c3702709563041714ce05 560w, https://mintcdn.com/stagehand/cNbobmBIOozFHVDo/media/evals-cli.png?w=840&fit=max&auto=format&n=cNbobmBIOozFHVDo&q=85&s=caa9f9b11fd21d994b99c038e3f1f32b 840w, https://mintcdn.com/stagehand/cNbobmBIOozFHVDo/media/evals-cli.png?w=1100&fit=max&auto=format&n=cNbobmBIOozFHVDo&q=85&s=a6a94ce58bebb283a3d75303e0e98a46 1100w, https://mintcdn.com/stagehand/cNbobmBIOozFHVDo/media/evals-cli.png?w=1650&fit=max&auto=format&n=cNbobmBIOozFHVDo&q=85&s=ae077de6b9273f23db15c82673e08a81 1650w, https://mintcdn.com/stagehand/cNbobmBIOozFHVDo/media/evals-cli.png?w=2500&fit=max&auto=format&n=cNbobmBIOozFHVDo&q=85&s=d6394c2f184bbeea44d37c131ddccb6c 2500w" />

<Tip>
  To run evals, you'll need to clone the [Stagehand repo](https://github.com/browserbase/stagehand) and set up the CLI.

  We recommend using [Braintrust](https://www.braintrust.dev/docs/) to help visualize evals results and metrics.
</Tip>

The Stagehand CLI provides a powerful interface for running evaluations. You can run specific evals, categories, or external benchmarks with customizable settings.

Evals are grouped into:

1. **Act Evals** - These are evals that test the functionality of the `act` method.
2. **Extract Evals** - These are evals that test the functionality of the `extract` method.
3. **Observe Evals** - These are evals that test the functionality of the `observe` method.
4. **Combination Evals** - These are evals that test the functionality of the `act`, `extract`, and `observe` methods together.
5. **Experimental Evals** - These are experimental custom evals that test the functionality of the stagehand primitives.
6. **Agent Evals** - These are evals that test the functionality of `agent`.
7. **(NEW) External Benchmarks** - Run external benchmarks like WebBench, GAIA, WebVoyager, OnlineMind2Web, and OSWorld.

#### Installation

<Steps>
  <Step title="Install Dependencies">
    ```bash  theme={null}
    # From the stagehand root directory
    pnpm install
    ```
  </Step>

  <Step title="Build the CLI">
    ```bash  theme={null}
    pnpm run build:cli
    ```
  </Step>

  <Step title="Verify Installation">
    ```bash  theme={null}
    evals help
    ```
  </Step>
</Steps>

#### CLI Commands and Options

##### Basic Commands

```bash  theme={null}
# Run all evals
evals run all

# Run specific category
evals run act
evals run extract
evals run observe
evals run agent

# Run specific eval
evals run extract/extract_text

# List available evals
evals list
evals list --detailed

# Configure defaults
evals config
evals config set env browserbase
evals config set trials 5
```

##### Command Options

* **`-e, --env`**: Environment (`local` or `browserbase`)
* **`-t, --trials`**: Number of trials per eval (default: 3)
* **`-c, --concurrency`**: Max parallel sessions (default: 10)
* **`-m, --model`**: Model override
* **`-p, --provider`**: Provider override
* **`--api`**: Use Stagehand API instead of SDK

##### Running External Benchmarks

The CLI supports several industry-standard benchmarks:

```bash  theme={null}
# WebBench with filters
evals run benchmark:webbench -l 10 -f difficulty=easy -f category=READ

# GAIA benchmark
evals run b:gaia -s 100 -l 25 -f level=1

# WebVoyager
evals run b:webvoyager -l 50

# OnlineMind2Web
evals run b:onlineMind2Web

# OSWorld
evals run b:osworld -f source=Mind2Web
```

#### Configuration Files

You can view the specific evals in [`evals/tasks`](https://github.com/browserbase/stagehand/tree/main/packages/evals/tasks). Each eval is grouped into eval categories based on [`evals/evals.config.json`](https://github.com/browserbase/stagehand/blob/main/evals/evals.config.json).

#### Viewing eval results

<img src="https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/evals.png?fit=max&auto=format&n=W3kYIUy5sYF-nkqt&q=85&s=7121a71eff86fb037d0a1ff188660dc5" alt="Eval results" data-og-width="3456" width="3456" data-og-height="2234" height="2234" data-path="images/evals.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/evals.png?w=280&fit=max&auto=format&n=W3kYIUy5sYF-nkqt&q=85&s=322b9e5d965ab5e4ea6df06c58b663a6 280w, https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/evals.png?w=560&fit=max&auto=format&n=W3kYIUy5sYF-nkqt&q=85&s=aaf5f8669e64fb0146c57656fee87a91 560w, https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/evals.png?w=840&fit=max&auto=format&n=W3kYIUy5sYF-nkqt&q=85&s=45a599213aa9e7ef9ad8f987f2394924 840w, https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/evals.png?w=1100&fit=max&auto=format&n=W3kYIUy5sYF-nkqt&q=85&s=c841d5f8d327ecd0807f39550f8679e7 1100w, https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/evals.png?w=1650&fit=max&auto=format&n=W3kYIUy5sYF-nkqt&q=85&s=55c85f8ab4e265929e67b9cae955897b 1650w, https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/evals.png?w=2500&fit=max&auto=format&n=W3kYIUy5sYF-nkqt&q=85&s=a0c9929c2b6a980cea1d2fe9bd56dc3a 2500w" />

Eval results are viewable on Braintrust. You can view the results of a specific eval by going to the Braintrust URL specified in the terminal when you run `npm run evals`.

By default, each eval will run five times per model. The "Exact Match" column shows the percentage of times the eval was correct. The "Error Rate" column shows the percentage of times the eval errored out.

You can use the Braintrust UI to filter by model/eval and aggregate results across all evals.

## Creating Custom Evaluations

### Step-by-Step Guide

<Steps>
  <Step title="Create Evaluation File">
    Create a new file in `evals/tasks/your-eval.ts`:

    ```typescript  theme={null}
    import { EvalTask } from '../types';

    export const customEvalTask: EvalTask = {
      name: 'custom_task_name',
      description: 'Test specific automation workflow',
      
      // Test setup
      setup: async ({ page }) => {
        await page.goto('https://example.com');
      },
      
      // The actual test
      task: async ({ stagehand, page }) => {
        // Your automation logic
        await stagehand.act({ action: 'click the login button' });
        const result = await stagehand.extract({ 
          instruction: 'Get the user name',
          schema: { username: 'string' }
        });
        return result;
      },
      
      // Validation
      validate: (result, expected) => {
        return result.username === expected.username;
      },
      
      // Test cases
      testCases: [
        {
          input: { /* test input */ },
          expected: { username: 'john_doe' }
        }
      ],
      
      // Evaluation criteria
      scoring: {
        exactMatch: true,
        timeout: 30000,
        retries: 2
      }
    };
    ```
  </Step>

  <Step title="Add to Configuration">
    Update `evals/evals.config.json`:

    ```json  theme={null}
    {
      "categories": {
        "custom": ["custom_task_name"],
        "existing_category": ["custom_task_name"]
      }
    }
    ```
  </Step>

  <Step title="Run Your Evaluation">
    ```bash  theme={null}
    # Test your custom evaluation
    evals run custom_task_name

    # Run the entire custom category
    evals run custom

    # Run with specific settings
    evals run custom_task_name -e browserbase -t 5 -m gpt-4o
    ```
  </Step>
</Steps>

## Best Practices for Custom Evals

<AccordionGroup>
  <Accordion title="Test Design Principles">
    * **Atomic**: Each test should validate one specific capability
    * **Deterministic**: Tests should produce consistent, measurable results
    * **Realistic**: Use real-world scenarios and websites
    * **Measurable**: Define clear success/failure criteria
  </Accordion>

  <Accordion title="Performance Optimization">
    * **Parallel Execution**: Design tests to run independently
    * **Resource Management**: Clean up after each test
    * **Timeout Handling**: Set appropriate timeouts for operations
    * **Error Recovery**: Handle failures gracefully
  </Accordion>

  <Accordion title="Data Quality">
    * **Ground Truth**: Establish reliable expected outcomes
    * **Edge Cases**: Test boundary conditions and error scenarios
    * **Statistical Significance**: Run multiple iterations for reliability
    * **Version Control**: Track changes to test cases over time
  </Accordion>
</AccordionGroup>

### Troubleshooting Evaluations

<AccordionGroup>
  <Accordion title="Evaluation Timeouts">
    **Symptoms**: Tests fail with timeout errors

    **Solutions**:

    * Increase timeout in `taskConfig.ts`
    * Use faster models (Gemini 2.5 Flash, Claude Haiku 4.5)
    * Optimize test scenarios to be less complex
    * Check network connectivity to LLM providers
  </Accordion>

  <Accordion title="Inconsistent Results">
    **Symptoms**: Same test passes/fails randomly

    **Solutions**:

    * Set temperature to 0 for deterministic outputs
    * Increase repetitions for statistical significance
    * Use more capable models for complex tasks
    * Check for dynamic website content affecting tests
  </Accordion>

  <Accordion title="High Evaluation Costs">
    **Symptoms**: Token usage exceeding budget

    **Solutions**:

    * Use cost-effective models (Gemini 2.5 Flash, Claude Haiku 4.5)
    * Reduce repetitions for initial testing
    * Focus on specific evaluation categories
    * Use local browser environment to reduce Browserbase costs
  </Accordion>

  <Accordion title="Braintrust Integration Issues">
    **Symptoms**: Results not uploading to dashboard

    **Solutions**:

    * Check Braintrust API key configuration
    * Verify internet connectivity
    * Update Braintrust SDK to latest version
    * Check project permissions in Braintrust dashboard
  </Accordion>
</AccordionGroup>
# Browser

> Configure Stagehand on Browserbase or locally

Stagehand supports two primary environments:

* **Browserbase** - Cloud-managed browser infrastructure optimized for production web automation at scale
* **Local** - Run browsers directly on your machine for development and debugging

## Browserbase Environment

Browserbase provides managed cloud browser infrastructure optimized for web automation at scale. It offers advanced features like stealth mode, proxy support, and persistent contexts.

<Card icon="cloud" title="Browserbase" href="https://docs.browserbase.com" description="Explore the features and benefits of using Browserbase for scalable web automation.">
  Discover the power of cloud-managed browser infrastructure with Browserbase.
</Card>

### Environment Variables

Before getting started, set up the required environment variables:

<CodeGroup>
  ```bash .env theme={null}
  BROWSERBASE_API_KEY=your_api_key_here
  BROWSERBASE_PROJECT_ID=your_project_id_here
  ```
</CodeGroup>

<Tip>
  Get your API key and Project ID from the [Browserbase Dashboard](https://browserbase.com/overview)
</Tip>

### Using Stagehand with Browserbase

#### Basic Setup

The simplest way to get started is with default settings:

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";

const stagehand = new Stagehand({
  env: "BROWSERBASE",
});

await stagehand.init();
```

#### Advanced Configuration

Configure browser settings, proxy support, and other session parameters:

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";

const stagehand = new Stagehand({
  env: "BROWSERBASE",
  // Optional: API Key and Project ID will be pulled directly from your environment
  apiKey: process.env.BROWSERBASE_API_KEY,
  projectId: process.env.BROWSERBASE_PROJECT_ID,
  browserbaseSessionCreateParams: {
    proxies: true,
    region: "us-west-2",
    browserSettings: {
      viewport: { width: 1920, height: 1080 },
      blockAds: true,
    },
  },
});

await stagehand.init();
console.log("Session ID:", stagehand.sessionId);
```

<Accordion title="Advanced Browserbase Configuration Example">
  ```typescript  theme={null}
  const stagehand = new Stagehand({
    env: "BROWSERBASE",
    apiKey: process.env.BROWSERBASE_API_KEY,
    projectId: process.env.BROWSERBASE_PROJECT_ID,
    browserbaseSessionCreateParams: {
      projectId: process.env.BROWSERBASE_PROJECT_ID!,
      proxies: true,
      region: "us-west-2",
      timeout: 3600, // 1 hour session timeout
      keepAlive: true, // Available on Startup plan
      browserSettings: {
        advancedStealth: false, // this is a Scale Plan feature - reach out to support@browserbase.com to enable
        blockAds: true,
        solveCaptchas: true,
        recordSession: false,
        viewport: {
          width: 1920,
          height: 1080,
        },
      },
      userMetadata: {
        userId: "automation-user-123",
        environment: "production",
      },
    },
  });
  ```
</Accordion>

#### Initialization Result

After calling `stagehand.init()`, the method returns configuration information about the initialized session:

```typescript  theme={null}
const result = await stagehand.init();
console.log(result);
```

The returned object contains:

```Example  theme={null}
{
  debugUrl: 'https://www.browserbase.com/devtools/inspector.html?wss=connect.browserbase.com/debug/f8a21b4a-6fa1-4ab9-9007-fbfe61dc14f0/devtools/page/5474B0E0510C5B6E629BEB06E799CD70?debug=true',
  sessionUrl: 'https://www.browserbase.com/sessions/f8a21b4a-6fa1-4ab9-9007-fbfe61dc14f0',
  sessionId: 'f8a21b4a-6fa1-4ab9-9007-fbfe61dc14f0'
}
```

<AccordionGroup>
  <Accordion title="debugUrl">
    **Open the Browserbase [session live view](https://docs.browserbase.com/features/session-live-view)** to include a human-in-the-loop.
  </Accordion>

  <Accordion title="sessionUrl">
    **Open the [session replay](https://docs.browserbase.com/features/session-replay)** to see the full session recording.
  </Accordion>

  <Accordion title="sessionId">
    **Unique identifier** for the [Browserbase session](https://docs.browserbase.com/introduction/what-is-browserbase). This is used to identify the session in the Browserbase dashboard and to connect to the session.
  </Accordion>
</AccordionGroup>

### Alternative: Browserbase SDK

If you prefer to manage sessions directly, you can use the Browserbase SDK:

```typescript  theme={null}
import { Browserbase } from "@browserbasehq/sdk";

const bb = new Browserbase({ 
  apiKey: process.env.BROWSERBASE_API_KEY! 
});

const session = await bb.sessions.create({
  projectId: process.env.BROWSERBASE_PROJECT_ID!,
  // Add configuration options here
});
```

#### Connecting to an Existing Session

Connect to a previously created Browserbase session using its session ID:

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";

const stagehand = new Stagehand({
  env: "BROWSERBASE",
  browserbaseSessionID: "existing-session-uuid-here",
});

await stagehand.init();
console.log("Resumed Session ID:", stagehand.sessionId);
```

## Local Environment

The local environment runs browsers directly on your machine, providing full control over browser instances and configurations. Ideal for development, debugging, and scenarios requiring custom browser setups.

### Environment Comparison

| Feature                     | Browserbase                   | Local                         |
| --------------------------- | ----------------------------- | ----------------------------- |
| **Scalability**             | High (cloud-managed)          | Limited (local resources)     |
| **Stealth Features**        | Advanced fingerprinting       | Basic stealth                 |
| **Proxy Support**           | Built-in residential proxies  | Manual configuration          |
| **Session Persistence**     | Cloud context storage         | File-based user data          |
| **Geographic Distribution** | Multi-region deployment       | Single machine                |
| **Debugging**               | Session recordings & logs     | Direct DevTools access        |
| **Setup Complexity**        | Environment variables only    | Browser installation required |
| **Cost**                    | Usage-based pricing           | Infrastructure & maintenance  |
| **Best For**                | Production, scale, compliance | Development, debugging        |

### Basic Local Setup

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";

const stagehand = new Stagehand({
  env: "LOCAL"
});
  
await stagehand.init();
console.log("Session ID:", stagehand.sessionId);
```

### Advanced Local Configuration

Customize browser launch options for local development:

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";

const stagehand = new Stagehand({
  env: "LOCAL",
  localBrowserLaunchOptions: {
    headless: false, // Show browser window
    devtools: true, // Open developer tools
    viewport: { width: 1280, height: 720 },
    executablePath: '/opt/google/chrome/chrome', // Custom Chrome path
    args: [
      '--no-sandbox',
      '--disable-setuid-sandbox',
      '--disable-web-security',
      '--allow-running-insecure-content',
    ],
    userDataDir: './chrome-user-data', // Persist browser data
    preserveUserDataDir: true, // Keep data after closing
    chromiumSandbox: false, // Disable sandbox (adds --no-sandbox)
    ignoreHTTPSErrors: true, // Ignore certificate errors
    locale: 'en-US', // Set browser language
    deviceScaleFactor: 1.0, // Display scaling
    proxy: {
      server: 'http://proxy.example.com:8080',
      username: 'user',
      password: 'pass'
    },
    downloadsPath: './downloads', // Download directory
    acceptDownloads: true, // Allow downloads
    connectTimeoutMs: 30000, // Connection timeout
  },
});

await stagehand.init();
```

## Advanced Configuration

### DOM Settle Timeout

Configure how long Stagehand waits for the DOM to stabilize before taking actions.

```typescript  theme={null}
const stagehand = new Stagehand({
  env: "BROWSERBASE",
  domSettleTimeout: 3000 // Wait up to 3 seconds for DOM to settle
});
```

#### What is DOM Settling?

DOM settling ensures that:

* **Animations complete** before interacting with elements
* **Lazy-loaded content** has time to appear
* **JavaScript updates** finish before actions are taken
* **Dynamic content** is fully rendered

#### When to Adjust

Increase `domSettleTimeout` for pages with:

* Heavy animations or transitions
* Lazy-loading or infinite scroll
* Dynamic JavaScript frameworks (React, Vue, Angular)
* Complex single-page applications

```typescript  theme={null}
// For fast, static pages
const stagehand = new Stagehand({
  env: "BROWSERBASE",
  domSettleTimeout: 500 // Minimal wait
});

// For dynamic, animated pages
const stagehand = new Stagehand({
  env: "BROWSERBASE",
  domSettleTimeout: 5000 // Longer wait for stability
});
```

<Warning>
  Setting `domSettleTimeout` too low may cause actions to fail on elements that aren't ready. Setting it too high increases execution time unnecessarily.
</Warning>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Browserbase Authentication Errors">
    * Verify your `BROWSERBASE_API_KEY` and `BROWSERBASE_PROJECT_ID` are set correctly
    * Check that your API key has the necessary permissions
    * Ensure your Browserbase account has sufficient credits
  </Accordion>

  <Accordion title="Local Browser Launch Failures">
    * Install Chrome or Chromium on your system
    * Set the correct `executablePath` for your Chrome installation
    * Check that required dependencies are installed (Linux: `libnss3-dev libatk-bridge2.0-dev libgtk-3-dev libxss1 libasound2`)
  </Accordion>

  <Accordion title="Session Timeout Issues">
    * Increase session timeout in `browserbaseSessionCreateParams.timeout`
    * Use `keepAlive: true` for long-running sessions
    * Monitor session usage to avoid unexpected terminations
  </Accordion>
</AccordionGroup>
# Observability

> Track Stagehand automation with session visibility and analytics

Stagehand provides powerful observability features to help you monitor, track performance, and analyze your browser automation workflows. Focus on session monitoring, resource usage, and operational insights for both Browserbase and local environments.

## Browserbase Session Monitoring

When running on Browserbase, you gain access to comprehensive cloud-based monitoring and session management through the Browserbase API and dashboard.

<div style={{ textAlign: "center" }}>
  <img src="https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/media/observability.gif?s=bf90060651c242c21b726319d86e89f7" alt="Browserbase Session Observability" width="400" data-og-width="1112" data-og-height="720" data-path="media/observability.gif" data-optimize="true" data-opv="3" />
</div>

### Live Session Visibility

Browserbase provides real-time visibility into your automation sessions:

**Session Dashboard Features**

* Real-time browser screen recording and replay
* Network request monitoring with detailed timing
* JavaScript console logs and error tracking
* CPU and memory usage metrics
* Session status and duration tracking

**Session Management & API Access**

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";
import { Browserbase } from "@browserbasehq/sdk";

const browserbase = new Browserbase({
  apiKey: process.env.BROWSERBASE_API_KEY,
});

const stagehand = new Stagehand({
  env: "BROWSERBASE"
});

await stagehand.init();

const sessionInfo = await browserbase.sessions.retrieve(stagehand.sessionId);

console.log("Session status:", sessionInfo.status);
console.log("Session region:", sessionInfo.region);
console.log("CPU usage:", sessionInfo.avgCpuUsage);
console.log("Memory usage:", sessionInfo.memoryUsage);
console.log("Proxy bytes:", sessionInfo.proxyBytes);
```

### Session Analytics & Insights

<CardGroup>
  <Card title="Real-Time Monitoring" icon="chart-line">
    Monitor live session status, resource usage, and geographic distribution. Scale and manage concurrent sessions with real-time insights.
  </Card>

  <Card title="Session Recordings" icon="video">
    Review complete session recordings with frame-by-frame playback. Analyze network requests and debug browser interactions visually.
  </Card>

  <Card title="API Management" icon="code">
    Programmatically access session data, automate lifecycle management, and integrate with monitoring systems through our API.
  </Card>

  <Card title="Usage Monitoring" icon="chart-bar">
    Track resource consumption, session duration, and API usage. Get detailed breakdowns of costs and utilization across your automation.
  </Card>
</CardGroup>

### Session Monitoring & Filtering

Query and monitor sessions by status and metadata:

```typescript  theme={null}
import { Browserbase } from "@browserbasehq/sdk";

const browserbase = new Browserbase({
  apiKey: process.env.BROWSERBASE_API_KEY,
});

// List sessions with filtering
async function getFilteredSessions() {
  const sessions = await browserbase.sessions.list({
    status: 'RUNNING'
  });
  
  return sessions.map(session => ({
    id: session.id,
    status: session.status, // RUNNING, COMPLETED, ERROR, TIMED_OUT
    startedAt: session.startedAt,
    endedAt: session.endedAt,
    region: session.region,
    avgCpuUsage: session.avgCpuUsage,
    memoryUsage: session.memoryUsage,
    proxyBytes: session.proxyBytes,
    userMetadata: session.userMetadata
  }));
}

// Query sessions by metadata
async function querySessionsByMetadata(query: string) {
  const sessions = await browserbase.sessions.list({
    q: query
  });
  
  return sessions;
}
```

## Local Environment Monitoring

For local development, Stagehand provides performance monitoring and resource tracking capabilities directly on your machine.

### Performance Tracking

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";

const stagehand = new Stagehand({
  env: "LOCAL",
  verbose: 1, // Monitor performance without debug noise
});

await stagehand.init();

// Track local automation metrics
const startTime = Date.now();
const initialMetrics = await stagehand.metrics;

// ... perform automation tasks
const page = stagehand.context.pages()[0];
await page.goto("https://example.com");
await stagehand.act("click button");
await stagehand.extract({ instruction: "get data", schema: DataSchema });

const finalMetrics = await stagehand.metrics;
const executionTime = Date.now() - startTime;

console.log('Local Performance Summary:', {
  executionTime: `${executionTime}ms`,
  totalTokens: finalMetrics.totalPromptTokens + finalMetrics.totalCompletionTokens,
  totalInferenceTime: `${finalMetrics.totalInferenceTimeMs}ms`,
  tokensPerSecond: ((finalMetrics.totalPromptTokens + finalMetrics.totalCompletionTokens) / (executionTime / 1000)).toFixed(2)
});
```

## Resource Usage Monitoring

When running locally, monitor system resource usage and browser performance:

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";
import * as os from 'os';
import { performance } from 'perf_hooks';

class LocalResourceMonitor {
  private cpuUsage: number[] = [];
  private memoryUsage: number[] = [];
  
  startMonitoring() {
    const interval = setInterval(() => {
      // Track system resources
      const memUsage = process.memoryUsage();
      this.memoryUsage.push(memUsage.heapUsed / 1024 / 1024); // MB
      
      // Track CPU (simplified)
      const loadAvg = os.loadavg()[0];
      this.cpuUsage.push(loadAvg);
    }, 1000);
    
    return interval;
  }
  
  getResourceSummary() {
    return {
      avgMemoryUsage: this.memoryUsage.reduce((a, b) => a + b, 0) / this.memoryUsage.length,
      peakMemoryUsage: Math.max(...this.memoryUsage),
      avgCpuLoad: this.cpuUsage.reduce((a, b) => a + b, 0) / this.cpuUsage.length,
      totalDataPoints: this.cpuUsage.length
    };
  }
}

const monitor = new LocalResourceMonitor();
const interval = monitor.startMonitoring();

const stagehand = new Stagehand({ env: "LOCAL" });

// ... run automation

clearInterval(interval);
console.log('Resource Usage:', monitor.getResourceSummary());
```

<Card title="LLM Usage" icon="chart-line" href="/v3/basics/evals">
  Monitor token usage, costs, and speed. Set up automated alerting for critical failures. Implement cost tracking across different environments. Use session analytics to optimize automation workflows.
</Card>

## Real-Time Metrics & Monitoring

### Basic Usage Tracking

Monitor your automation's resource usage in real-time with `stagehand.metrics`:

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";

const stagehand = new Stagehand({ env: "BROWSERBASE" });
await stagehand.init();

// Metrics are async in V3
const metrics = await stagehand.metrics;
console.log(metrics);

// Monitor during automation
const startTime = Date.now();
const initialMetrics = await stagehand.metrics;

// ... perform automation tasks
const page = stagehand.context.pages()[0];
await page.goto("https://example.com");
await stagehand.act("click the login button");
const data = await stagehand.extract({
  instruction: "extract user info",
  schema: UserSchema
});

const finalMetrics = await stagehand.metrics;
const executionTime = Date.now() - startTime;

console.log('Automation Summary:', {
  totalTokens: finalMetrics.totalPromptTokens + finalMetrics.totalCompletionTokens,
  executionTime: `${executionTime}ms`,
  avgInferenceTime: `${finalMetrics.totalInferenceTimeMs / 3}ms`,
});
```

### Understanding Metrics Data

The metrics object provides detailed breakdown by Stagehand operation:

```typescript  theme={null}
interface StagehandMetrics {
  // Act operation metrics
  actPromptTokens: number;
  actCompletionTokens: number;
  actReasoningTokens: number;
  actCachedInputTokens: number;
  actInferenceTimeMs: number;

  // Extract operation metrics
  extractPromptTokens: number;
  extractCompletionTokens: number;
  extractReasoningTokens: number;
  extractCachedInputTokens: number;
  extractInferenceTimeMs: number;

  // Observe operation metrics
  observePromptTokens: number;
  observeCompletionTokens: number;
  observeReasoningTokens: number;
  observeCachedInputTokens: number;
  observeInferenceTimeMs: number;

  // Agent operation metrics
  agentPromptTokens: number;
  agentCompletionTokens: number;
  agentReasoningTokens: number;
  agentCachedInputTokens: number;
  agentInferenceTimeMs: number;

  // Cumulative totals
  totalPromptTokens: number;
  totalCompletionTokens: number;
  totalReasoningTokens: number;
  totalCachedInputTokens: number;
  totalInferenceTimeMs: number;
}
```

**Example metrics output:**

```typescript  theme={null}
const metrics = await stagehand.metrics;
console.log(metrics);

// {
//   actPromptTokens: 4011,
//   actCompletionTokens: 51,
//   actReasoningTokens: 12,
//   actCachedInputTokens: 0,
//   actInferenceTimeMs: 1688,
//   extractPromptTokens: 4200,
//   extractCompletionTokens: 243,
//   extractReasoningTokens: 18,
//   extractCachedInputTokens: 0,
//   extractInferenceTimeMs: 4297,
//   observePromptTokens: 347,
//   observeCompletionTokens: 43,
//   observeReasoningTokens: 5,
//   observeCachedInputTokens: 0,
//   observeInferenceTimeMs: 903,
//   agentPromptTokens: 0,
//   agentCompletionTokens: 0,
//   agentReasoningTokens: 0,
//   agentCachedInputTokens: 0,
//   agentInferenceTimeMs: 0,
//   totalPromptTokens: 8558,
//   totalCompletionTokens: 337,
//   totalReasoningTokens: 35,
//   totalCachedInputTokens: 0,
//   totalInferenceTimeMs: 6888
// }
```

## Best Practices

<AccordionGroup>
  <Accordion title="Production Monitoring">
    * Track session success rates and failure patterns
    * Monitor resource usage and scaling requirements
    * Set up automated alerting for critical failures
    * Implement cost tracking across different environments
    * Use session analytics to optimize automation workflows
  </Accordion>

  <Accordion title="Performance Optimization">
    * Compare Browserbase vs local execution times
    * Monitor token usage and inference costs across models
    * Track geographic performance differences
    * Identify bottlenecks in automation workflows
    * Optimize for cost-effectiveness and speed
  </Accordion>

  <Accordion title="Operational Insights">
    * Track session distribution across regions
    * Monitor concurrent session limits and scaling
    * Analyze failure patterns and common error scenarios
    * Use session recordings for root cause analysis
    * Implement custom metadata for workflow categorization
  </Accordion>

  <Accordion title="Integration & Alerting">
    * Integrate session APIs with monitoring dashboards
    * Set up automated notifications for session failures
    * Track SLA compliance and performance benchmarks
    * Monitor resource costs and usage patterns
    * Use analytics data for capacity planning and optimization
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Complete Observability Guide" icon="chart-line" href="v3/best-practices/history">
    Learn about history tracking, session monitoring, and resource usage monitoring.
  </Card>

  <Card title="Complete Logging Guide" icon="file-lines" href="v3/configuration/logging">
    Learn about history tracking, session monitoring, and resource usage monitoring.
  </Card>
</CardGroup>
# Logging

> Set up logging, debugging, and error tracking for Stagehand workflows

Stagehand provides comprehensive logging capabilities to help you debug automation workflows, track execution, and diagnose issues. Configure logging levels, structured output, and debugging tools for both development and production environments.

## Quick Start

Choose your logging setup based on your environment:

<CodeGroup>
  ```typescript Development theme={null}
  import { Stagehand } from "@browserbasehq/stagehand";

  const stagehand = new Stagehand({
    env: "LOCAL",
    verbose: 2,  // Full debug output
    // restOfYourConfiguration...
  });
  ```

  ```typescript Production theme={null}
  import { Stagehand } from "@browserbasehq/stagehand";

  const stagehand = new Stagehand({
    env: "BROWSERBASE",
    verbose: 1,  // Standard logging - less noise
    disablePino: true,  // Disable default console logging - no console spam
    // logger: yourProductionLogger,  // Send to observability platform like Sentry or DataDog
    // restOfYourConfiguration...
  });
  ```

  ```typescript Testing theme={null}
  import { Stagehand } from "@browserbasehq/stagehand";

  const stagehand = new Stagehand({
    env: "LOCAL",
    verbose: 1,
    // Pino automatically disabled in test environments - no worker thread issues
    // logger: yourTestLogger,  // Send to test logging framework like Jest
    // restOfYourConfiguration...
  });
  ```
</CodeGroup>

***

## Operational Logging

Real-time event logging during automation execution.

### Verbosity Level

Control how much detail you see in logs:

<Tabs>
  <Tab title="Level 2: Debug">
    **Use for:** Development, debugging specific issues

    ```typescript  theme={null}
    const stagehand = new Stagehand({
      verbose: 2,  // Maximum detail
      // restOfYourConfiguration...
    });
    ```

    <Accordion title="Example Output">
      ```
      [12:34:56] DEBUG: Capturing DOM snapshot
      [12:34:57] DEBUG: DOM contains 847 elements
      [12:34:58] DEBUG: LLM inference started
      [12:34:59] DEBUG: LLM response: {"selector": "#btn-submit", "method": "click"}
      [12:35:00] INFO: act completed successfully
      ```
    </Accordion>
  </Tab>

  <Tab title="Level 1: Info (Default)">
    **Use for:** Standard operations, staging, production

    ```typescript  theme={null}
    const stagehand = new Stagehand({
      verbose: 1,  // Default level
      // restOfYourConfiguration...
    });
    ```

    <Accordion title="Example Output">
      ```
      [12:34:56] INFO: act started
      [12:35:00] INFO: act completed successfully
      [12:35:01] INFO: extract started
      [12:35:03] INFO: extract completed
      ```
    </Accordion>
  </Tab>

  <Tab title="Level 0: Errors Only">
    **Use for:** Production with external monitoring, minimal noise

    ```typescript  theme={null}
    const stagehand = new Stagehand({
      verbose: 0,  // Errors only
      // restOfYourConfiguration...
    });
    ```

    <Accordion title="Example Output">
      ```
      [12:35:05] ERROR: act failed: element not found
      [12:35:10] ERROR: navigation timeout exceeded
      ```
    </Accordion>
  </Tab>
</Tabs>

***

### Log Destinations

Logs can be sent to different destinations, including your console and external observability platforms:

<Tabs>
  <Tab title="Pino (Default)">
    Fast, structured, colorized JSON logger with console output.

    **When to use:** Development, staging, or production without external observability; can manage multiple Stagehand instances

    ```typescript  theme={null}
    // Enabled by default - Pino handles console output automatically
    const stagehand = new Stagehand({
      verbose: 1,
      // restOfYourConfiguration...
    });
    ```

    <Accordion title="Auto-disabled when">
      * `process.env.NODE_ENV === "test"`
      * `process.env.JEST_WORKER_ID !== undefined` (Jest tests)
      * `process.env.PLAYWRIGHT_TEST_BASE_DIR !== undefined` (Playwright tests)
      * `process.env.CI === "true"` (CI/CD environments)

      **Why auto-disable?** Pino uses worker threads for pretty-printing, which can cause issues in test runners.
    </Accordion>
  </Tab>

  <Tab title="Console Fallback">
    Simple console.log/error output.

    **When to use:** Automatically activated in tests, or when `disablePino: true` without setting an external logger

    ```typescript  theme={null}
    const stagehand = new Stagehand({
      verbose: 1,
      disablePino: true, // Set to true automatically when a test is detected
      // restOfYourConfiguration...
    });
    ```

    <Accordion title="Auto-disabled when">
      * `process.env.NODE_ENV === "test"`
      * `process.env.JEST_WORKER_ID !== undefined` (Jest tests)
      * `process.env.PLAYWRIGHT_TEST_BASE_DIR !== undefined` (Playwright tests)
      * `process.env.CI === "true"` (CI/CD environments)

      **Why auto-disable?** Pino uses worker threads for pretty-printing, which can cause issues in test runners.
    </Accordion>
  </Tab>

  <Tab title="Custom Logger">
    Your custom logging function to receive all logs. Works independently of Pino - receives logs regardless of Pino setting.

    **When to use:** Development, debugging, or when you don't need querying
    capabilities.

    <Steps>
      <Step title="Create a simple logger">
        ```typescript  theme={null}
        // Simple logger without parsing (for basic console output)
        const simpleLogger = (logLine: LogLine) => {
          console.log(`[${logLine.level}] ${logLine.message}`);

          // Optional: log raw auxiliary data
          if (logLine.auxiliary) {
            console.log('  Context:', logLine.auxiliary);
          }
        };
        ```
      </Step>

      <Step title="Pass the logger in your Stagehand instance">
        Then pass the logger in your Stagehand instance:

        ```typescript  theme={null}
        const stagehand = new Stagehand({
          env: "BROWSERBASE",
          verbose: 1,
          logger: simpleLogger,
          disablePino: true,  // Avoid duplicate processing
          // restOfYourConfiguration...
        })
        ```
      </Step>
    </Steps>
  </Tab>

  <Tab title="External Logger (Production)">
    Your custom logging function to receive all logs. Works independently of Pino - receives logs regardless of Pino setting.

    **When to use:** Production with DataDog, Sentry, CloudWatch, or custom observability platforms for centralized monitoring and enable error alerting. Here's examples using Sentry and DataDog:

    <Steps>
      <Step title="Create a production logger">
        <Tabs>
          <Tab title="Sentry">
            ```typescript  theme={null}
            import * as Sentry from "@sentry/node";

            const productionLogger = (logLine: LogLine) => {
              // Send errors to Sentry
              if (logLine.level === 0) {
                Sentry.captureMessage(logLine.message, {
                  level: 'error',
                  extra: aux,
                });
              }
            }

            // Helper to parse auxiliary data to be flat, numeric, and filterable
            function parseAuxiliary(aux?: LogLine['auxiliary']): Record<string, any> {
              if (!aux) return {};
              const parsed: Record<string, any> = {};
              for (const [key, entry] of Object.entries(aux)) {
                parsed[key] = entry.type === 'object'
                  ? JSON.parse(entry.value)
                  : entry.value;
              }
              return parsed;
            }
            ```
          </Tab>

          <Tab title="DataDog">
            ```typescript  theme={null}
            import { datadogLogs } from "@datadog/browser-logs";

            const productionLogger = (logLine: LogLine) => {
              // Send all logs to DataDog
              datadogLogs.logger.log(logLine.message, {
                status: logLine.level === 0 ? 'error' : 'info',
                service: 'stagehand-automation',
                category: logLine.category,
                ...aux,
              });
            }

            // Helper to parse auxiliary data to be flat, numeric, and filterable
            function parseAuxiliary(aux?: LogLine['auxiliary']): Record<string, any> {
              if (!aux) return {};
              const parsed: Record<string, any> = {};
              for (const [key, entry] of Object.entries(aux)) {
                parsed[key] = entry.type === 'object'
                  ? JSON.parse(entry.value)
                  : entry.value;
              }
              return parsed;
            }
            ```
          </Tab>
        </Tabs>
      </Step>

      <Step title="Pass the logger in your Stagehand instance">
        ```typescript  theme={null}
        const stagehand = new Stagehand({
          env: "BROWSERBASE",
          verbose: 1,
          logger: productionLogger,
          disablePino: true,  // Avoid duplicate processing
          // restOfYourConfiguration...
        })
        ```
      </Step>
    </Steps>
  </Tab>
</Tabs>

***

## LLM Inference Debugging

<Warning>
  **Development only** - Creates large files and contains page content. Do not use in production.
</Warning>

Save complete LLM request/response dumps to disk for offline analysis. See exactly what DOM was sent to the LLM and why it chose the wrong element.

```typescript  theme={null}
const stagehand = new Stagehand({
  env: "LOCAL",
  verbose: 2,
  logInferenceToFile: true,  // Writes files to ./inference_summary/
});
```

Creates timestamped files for each LLM call:

```
./inference_summary/
├── act_summary/
│   ├── act_summary.json                      # Aggregate metrics
│   ├── 20250127_123456_act_call.txt          # LLM request
│   ├── 20250127_123456_act_response.txt      # LLM response
│   ├── 20250127_123501_act_call.txt
│   └── 20250127_123501_act_response.txt
├── extract_summary/
│   ├── extract_summary.json
│   ├── 20250127_123510_extract_call.txt
│   ├── 20250127_123510_extract_response.txt
│   ├── 20250127_123511_metadata_call.txt
│   └── 20250127_123511_metadata_response.txt
└── observe_summary/
    ├── observe_summary.json
    └── ...
```

**File Types:**

<AccordionGroup>
  <Accordion title="Call File">
    Contains the complete LLM request:

    ```json  theme={null}
    {
      "modelCall": "act",
      "messages": [
        {
          "role": "system",
          "content": "You are a browser automation assistant. You have access to these actions:\n- click\n- type\n- scroll\n..."
        },
        {
          "role": "user",
          "content": "Click the sign in button\n\nDOM:\n<html>\n  <body>\n    <button id=\"btn-1\">Sign In</button>\n    <button id=\"btn-2\">Sign Up</button>\n  </body>\n</html>"
        }
      ]
    }
    ```
  </Accordion>

  <Accordion title="Response File">
    Contains the LLM output:

    ```json  theme={null}
    {
      "modelResponse": "act",
      "rawResponse": {
        "selector": "#btn-1",
        "method": "click",
        "reasoning": "Found sign in button with ID btn-1"
      }
    }
    ```
  </Accordion>

  <Accordion title="Summary File">
    Aggregates all calls with metrics:

    ```json  theme={null}
    {
      "act_summary": [
        {
          "act_inference_type": "act",
          "timestamp": "20250127_123456",
          "LLM_input_file": "20250127_123456_act_call.txt",
          "LLM_output_file": "20250127_123456_act_response.txt",
          "prompt_tokens": 3451,
          "completion_tokens": 45,
          "inference_time_ms": 951
        },
        {
          "act_inference_type": "act",
          "timestamp": "20250127_123501",
          "LLM_input_file": "20250127_123501_act_call.txt",
          "LLM_output_file": "20250127_123501_act_response.txt",
          "prompt_tokens": 2890,
          "completion_tokens": 38,
          "inference_time_ms": 823
        }
      ]
    }
    ```
  </Accordion>
</AccordionGroup>

***

## Reference

### Logging Configuration

All logging options are passed to the Stagehand constructor:

```typescript  theme={null}
const stagehand = new Stagehand({
  // ... your other configurations (env, model, etc.)

  // Logging options:
  verbose?: 0 | 1 | 2;                   // Log level (default: 1)
  logger?: (line: LogLine) => void;      // External logger function
  disablePino?: boolean;                 // Disable Pino backend (default: false)
  logInferenceToFile?: boolean;          // Save LLM requests to disk (default: false)
});
```

| Option               | Default     | Description                                           |
| -------------------- | ----------- | ----------------------------------------------------- |
| `verbose`            | `1`         | Log level: `0` = errors only, `1` = info, `2` = debug |
| `logger`             | `undefined` | Custom logger function for external platforms         |
| `disablePino`        | `false`     | Disable Pino (auto `true` in tests)                   |
| `logInferenceToFile` | `false`     | Save LLM requests to disk (default: false)            |

### Log Structure

Each log entry follows a structured format:

```typescript  theme={null}
interface LogLine {
  message: string;              // "act completed successfully"
  level?: 0 | 1 | 2;            // error | info | debug
  category?: string;            // "action", "llm", "browser", "cache"
  timestamp?: string;           // ISO 8601 timestamp
  auxiliary?: {                 // Additional structured metadata
    [key: string]: {
      value: string;             // Serialized value
      type: "object" | "string" | "integer" | "float" | "boolean";
    };
  };
}
```

<Accordion title="Log Examples">
  <Tabs>
    <Tab title="Successful Action">
      ```json  theme={null}
      {
        "category": "action",
        "message": "act completed successfully",
        "level": 1,
        "timestamp": "2025-01-27T12:35:00.123Z",
        "auxiliary": {
          "selector": {
            "value": "#btn-submit",
            "type": "string"
          },
          "executionTime": {
            "value": "1250",
            "type": "integer"
          }
        }
      }
      ```
    </Tab>

    <Tab title="LLM Inference">
      ```json  theme={null}
      {
        "category": "llm",
        "message": "inference completed",
        "level": 1,
        "timestamp": "2025-01-27T12:34:58.456Z",
        "auxiliary": {
          "model": {
            "value": "gpt-4o",
            "type": "string"
          },
          "promptTokens": {
            "value": "3451",
            "type": "integer"
          },
          "completionTokens": {
            "value": "45",
            "type": "integer"
          }
        }
      }
      ```
    </Tab>

    <Tab title="Error">
      ```json  theme={null}
      {
        "category": "action",
        "message": "action failed: element not found",
        "level": 0,
        "timestamp": "2025-01-27T12:35:05.789Z",
        "auxiliary": {
          "selector": {
            "value": "#missing-btn",
            "type": "string"
          },
          "url": {
            "value": "https://example.com/form",
            "type": "string"
          }
        }
      }
      ```
    </Tab>
  </Tabs>
</Accordion>

***

## Next Steps

Now that you have logging configured, explore additional debugging and monitoring tools in [the Observability guide](/v3/configuration/observability):

<CardGroup cols={2}>
  <Card title="History API" icon="clock-rotate-left" href="/v3/configuration/observability#history-tracking">
    Track all LLM operations (act, extract, observe, agent) with parameters, results, and timestamps. Perfect for debugging sequences and replaying workflows.
  </Card>

  <Card title="Metrics API" icon="chart-line" href="/v3/configuration/observability#real-time-metrics--monitoring">
    Monitor token usage and performance in real-time. Track costs per operation, identify expensive calls, and optimize resource usage.
  </Card>

  <Card title="LLM Inference Debugging" icon="microscope" href="/v3/configuration/observability#detailed-inference-logging">
    Save complete LLM request/response dumps to disk. See exactly what DOM was sent to the LLM and why it made specific decisions.
  </Card>

  <Card title="Browserbase Session Monitoring" icon="video" href="/v3/configuration/observability#browserbase-session-monitoring">
    Watch your automation visually with session recordings, network monitoring, and real-time browser inspection (Browserbase only).
  </Card>
</CardGroup>
# Models

> Use any LLM model with Stagehand for optimal performance

Understand web pages, plan actions, and interact with complex interfaces with Google, OpenAI, Anthropic, xAI, DeepSeek, Perplexity, Azure, Ollama, or any other LLM model from [the Vercel AI SDK](https://sdk.vercel.ai/providers).

***

## Configuration Setup

### Quick Start

<Tip>
  Set your API key in `.env` and Stagehand handles the rest. No explicit
  configuration needed!
</Tip>

Get started with Google Gemini (recommended for speed and cost):

<CodeGroup>
  ```typescript TypeScript theme={null}
  import { Stagehand } from "@browserbasehq/stagehand";

  const stagehand = new Stagehand({
    env: "BROWSERBASE",
    model: "google/gemini-2.5-flash"
    // API key auto-loads from GOOGLE_GENERATIVE_AI_API_KEY - set in your .env
  });

  await stagehand.init();

  ```
</CodeGroup>

***

### First Class Models

Use any model from the following supported providers.

<Tabs>
  <Tab title="Google">
    <CodeGroup>
      ```typescript TypeScript theme={null}
      import { Stagehand } from "@browserbasehq/stagehand";

      const stagehand = new Stagehand({
        env: "BROWSERBASE",
        model: "google/gemini-2.5-flash"
        // API key auto-loads from GOOGLE_GENERATIVE_AI_API_KEY - set in your .env
      });

      await stagehand.init();
      ```
    </CodeGroup>

    [View all supported Google models →](https://ai.google.dev/gemini-api/docs/models)
  </Tab>

  <Tab title="Anthropic">
    <CodeGroup>
      ```typescript TypeScript theme={null}
      import { Stagehand } from "@browserbasehq/stagehand";

      const stagehand = new Stagehand({
        env: "BROWSERBASE",
        model: "anthropic/claude-haiku-4-5"
        // API key auto-loads from ANTHROPIC_API_KEY - set in your .env
      });

      await stagehand.init();

      ```
    </CodeGroup>

    [View all supported Anthropic models →](https://docs.anthropic.com/en/docs/models-overview)
  </Tab>

  <Tab title="OpenAI">
    <CodeGroup>
      ```typescript TypeScript theme={null}
      import { Stagehand } from "@browserbasehq/stagehand";

      const stagehand = new Stagehand({
        env: "BROWSERBASE",
        model: "openai/gpt-5"
        // API key auto-loads from OPENAI_API_KEY - set in your .env
      });

      await stagehand.init();
      ```
    </CodeGroup>

    [View all supported OpenAI models →](https://platform.openai.com/docs/models)
  </Tab>

  <Tab title="Azure">
    <CodeGroup>
      ```typescript TypeScript theme={null}
      import { Stagehand } from "@browserbasehq/stagehand";

      const stagehand = new Stagehand({
        env: "BROWSERBASE",
        model: "azure/gpt-5"
        // API key auto-loads from AZURE_API_KEY - set in your .env
      });

      await stagehand.init();

      ```
    </CodeGroup>

    [View all supported Azure models →](https://ai.azure.com/catalog)
  </Tab>

  <Tab title="Cerebras">
    <CodeGroup>
      ```typescript TypeScript theme={null}
      import { Stagehand } from "@browserbasehq/stagehand";

      const stagehand = new Stagehand({
        env: "BROWSERBASE",
        model: "cerebras/llama-4-scout"
        // API key auto-loads from CEREBRAS_API_KEY - set in your .env
      });

      await stagehand.init();
      ```
    </CodeGroup>

    [View all supported Cerebras models →](https://inference-docs.cerebras.ai/models/overview)
  </Tab>

  <Tab title="DeepSeek">
    <CodeGroup>
      ```typescript TypeScript theme={null}
      import { Stagehand } from "@browserbasehq/stagehand";

      const stagehand = new Stagehand({
        env: "BROWSERBASE",
        model: "deepseek/deepseek-chat"
        // API key auto-loads from DEEPSEEK_API_KEY - set in your .env
      });

      await stagehand.init();

      ```
    </CodeGroup>

    [View all supported DeepSeek models →](https://api-docs.deepseek.com/quick_start/pricing)
  </Tab>

  <Tab title="Groq">
    <CodeGroup>
      ```typescript TypeScript theme={null}
      import { Stagehand } from "@browserbasehq/stagehand";

      const stagehand = new Stagehand({
        env: "BROWSERBASE",
        model: "groq/llama-3.1-8b-instant"
        // API key auto-loads from GROQ_API_KEY - set in your .env
      });

      await stagehand.init();
      ```
    </CodeGroup>

    [View all supported Groq models →](https://console.groq.com/docs/models)
  </Tab>

  <Tab title="Mistral">
    <CodeGroup>
      ```typescript TypeScript theme={null}
      import { Stagehand } from "@browserbasehq/stagehand";

      const stagehand = new Stagehand({
        env: "BROWSERBASE",
        model: "mistral/codestral-2508"
        // API key auto-loads from MISTRAL_API_KEY - set in your .env
      });

      await stagehand.init();

      ```
    </CodeGroup>

    [View all supported Mistral models →](https://docs.mistral.ai/getting-started/models)
  </Tab>

  <Tab title="Ollama">
    <CodeGroup>
      ```typescript TypeScript theme={null}
      import { Stagehand } from "@browserbasehq/stagehand";

      const stagehand = new Stagehand({
        env: "BROWSERBASE",
        model: "ollama/llama3.2"
        // No API key required
      });

      await stagehand.init();
      ```
    </CodeGroup>

    [View all supported Ollama models →](https://ollama.com/library)
  </Tab>

  <Tab title="Perplexity">
    <CodeGroup>
      ```typescript TypeScript theme={null}
      import { Stagehand } from "@browserbasehq/stagehand";

      const stagehand = new Stagehand({
        env: "BROWSERBASE",
        model: "perplexity/sonar-reasoning"
        // API key auto-loads from PERPLEXITY_API_KEY - set in your .env
      });

      await stagehand.init();

      ```
    </CodeGroup>

    [View all supported Perplexity models →](https://docs.perplexity.ai/getting-started/models)
  </Tab>

  <Tab title="TogetherAI">
    <CodeGroup>
      ```typescript TypeScript theme={null}
      import { Stagehand } from "@browserbasehq/stagehand";

      const stagehand = new Stagehand({
        env: "BROWSERBASE",
        model: "togetherai/Qwen/Qwen3-235B-A22B-Instruct-2507-tput"
        // API key auto-loads from TOGETHER_AI_API_KEY - set in your .env
      });

      await stagehand.init();
      ```
    </CodeGroup>

    [View all supported TogetherAI models →](https://www.together.ai/models)
  </Tab>

  <Tab title="xAI">
    <CodeGroup>
      ```typescript TypeScript theme={null}
      import { Stagehand } from "@browserbasehq/stagehand";

      const stagehand = new Stagehand({
        env: "BROWSERBASE",
        model: "xai/grok-4-fast-reasoning"
        // API key auto-loads from XAI_API_KEY - set in your .env
      });

      await stagehand.init();

      ```
    </CodeGroup>

    [View all xAI models →](https://docs.x.ai/docs/models)
  </Tab>
</Tabs>

***

### Custom Models

Amazon Bedrock, Cohere, all [first class models](/v3/configuration/models#first-class-models), and any model from [the Vercel AI SDK](https://sdk.vercel.ai/providers) is supported.

Use this configuration for custom endpoints and custom retry or caching logic.

We'll use Amazon Bedrock and Google as examples below.

<AccordionGroup>
  <Accordion title="Amazon Bedrock">
    <Steps>
      <Step title="Install dependencies">
        Install the Vercel AI SDK for your provider.

        <Tabs>
          <Tab title="npm">
            ```bash  theme={null}
            npm install @ai-sdk/amazon-bedrock
            ```
          </Tab>

          <Tab title="pnpm">
            ```bash  theme={null}
            pnpm add @ai-sdk/amazon-bedrock
            ```
          </Tab>

          <Tab title="yarn">
            ```bash  theme={null}
            yarn add @ai-sdk/amazon-bedrock
            ```
          </Tab>

          <Tab title="bun">
            ```bash  theme={null}
            bun add @ai-sdk/amazon-bedrock
            ```
          </Tab>
        </Tabs>
      </Step>

      <Step title="Import, create provider, and create client">
        ```typescript  theme={null}
        import { createAmazonBedrock } from '@ai-sdk/amazon-bedrock';
        import { AISdkClient } from '@browserbasehq/stagehand';

        const bedrockProvider = createAmazonBedrock({
          region: 'us-east-1',
          accessKeyId: 'xxxxxxxxx',
          secretAccessKey: 'xxxxxxxxx',
          sessionToken: 'xxxxxxxxx',
        });

        const bedrockClient = new AISdkClient({
          model: bedrockProvider("amazon/nova-pro-latest"),
        });

        ```
      </Step>

      <Step title="Pass client to Stagehand">
        ```typescript  theme={null}
        const stagehand = new Stagehand({
          env: "BROWSERBASE",
          llmClient: bedrockClient
        });

        await stagehand.init();
        ```
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="Google">
    <Steps>
      <Step title="Install dependencies">
        Install the Vercel AI SDK for your provider.

        <Tabs>
          <Tab title="npm">
            ```bash  theme={null}
            npm install @ai-sdk/google
            ```
          </Tab>

          <Tab title="pnpm">
            ```bash  theme={null}
            pnpm add @ai-sdk/google
            ```
          </Tab>

          <Tab title="yarn">
            ```bash  theme={null}
            yarn add @ai-sdk/google
            ```
          </Tab>

          <Tab title="bun">
            ```bash  theme={null}
            bun add @ai-sdk/google
            ```
          </Tab>
        </Tabs>
      </Step>

      <Step title="Import, create provider, and create client">
        ```typescript  theme={null}
        import { createGoogle } from '@ai-sdk/google';
        import { AISdkClient } from '@browserbasehq/stagehand';

        const googleProvider = createGoogle({
          apiKey: process.env.GEMINI_API_KEY,
        });

        const googleClient = new AISdkClient({
          model: googleProvider("google/gemini-2.5-flash"),
        });

        ```
      </Step>

      <Step title="Pass client to Stagehand">
        ```typescript  theme={null}
        const stagehand = new Stagehand({
          env: "BROWSERBASE",
          llmClient: googleClient
        });

        await stagehand.init();
        ```
      </Step>
    </Steps>
  </Accordion>

  <Accordion title="All Providers">
    To implement a custom model, follow the steps for the provider you are using. See the Amazon Bedrock and Google examples above. All supported providers and models are in [the Vercel AI SDK](https://sdk.vercel.ai/providers).

    <Steps>
      <Step title="Install dependencies">
        Install the Vercel AI SDK for your provider.
      </Step>

      <Step title="Import, create provider, and create client">
        ```typescript  theme={null}
        import { createProvider } from '@ai-sdk/provider';
        import { AISdkClient } from '@browserbasehq/stagehand';

        const provider = createProvider({
          apiKey: 'xxxxxxxxx',
        });

        const providerClient = new AISdkClient({
          model: provider("model/name"),
        });

        ```
      </Step>

      <Step title="Pass client to Stagehand">
        ```typescript  theme={null}
        const stagehand = new Stagehand({
          env: "BROWSERBASE",
          llmClient: providerClient
        });

        await stagehand.init();
        ```
      </Step>
    </Steps>
  </Accordion>
</AccordionGroup>

***

## Choose a Model

Different models excel at different tasks. Consider speed, accuracy, and cost for your use case.

<Card title="Model Selection Guide" href="https://www.stagehand.dev/evals" icon="scale-balanced">
  Find detailed model comparisons and recommendations on our Model Evaluation page.
</Card>

**Quick Recommendations**

| Use Case          | Recommended Model         | Why                            |
| ----------------- | ------------------------- | ------------------------------ |
| **Production**    | `google/gemini-2.5-flash` | Fast, accurate, cost-effective |
| **Intelligence**  | `google/gemini-2.5-pro`   | Best accuracy on hard tasks    |
| **Speed**         | `google/gemini-2.5-flash` | Fastest response times         |
| **Cost**          | `google/gemini-2.5-flash` | Best value per token           |
| **Local/offline** | `ollama/qwen3`            | No API costs, full control     |

***

## Advanced Options

### Agent Models (with CUA Support)

**Default**

The Stagehand agent by default uses the same model passed to Stagehand. All models ([first class](/v3/configuration/models#first-class-models) and [custom](/v3/configuration/models#custom-models)) are supported. Here's an example with Gemini:

```typescript  theme={null}
const stagehand = new Stagehand({
  env: "BROWSERBASE",
  model: "google/gemini-2.5-flash",
  // GOOGLE_GENERATIVE_AI_API_KEY is auto-loaded from .env
  // ... other stagehand options
});

// Agent will use google/gemini-2.5-flash
const agent = stagehand.agent();
```

**Override (with CUA support)**

However, the stagehand agent also accepts a `model` parameter, which accepts any [first class](/v3/configuration/models#first-class-models) model, including [computer use agents (CUA)](/v3/configuration/models#agent-models-with-cua-support). This is useful when you'd like the agent to use a different model than the one passed to Stagehand.

<Tip>
  To use a cua model, you must pass the `cua` parameter to the `agent()` method. If a non-cua model is used, whether specified in Stagehand or overridden in the `agent()` method, an error will be thrown.
</Tip>

<Tabs>
  <Tab title="Google CUA">
    ```typescript  theme={null}
    const agent = stagehand.agent({
      cua: true,
      model: "google/gemini-2.5-computer-use-preview-10-2025",
      // GOOGLE_GENERATIVE_AI_API_KEY is auto-loaded from .env
      // ... other agent options
    });
    ```
  </Tab>

  <Tab title="Anthropic CUA">
    ```typescript  theme={null}
    const agent = stagehand.agent({
      cua: true,
      model: "anthropic/claude-3-7-sonnet-latest",
      // ANTHROPIC_API_KEY is auto-loaded from .env
      // ... other agent options
    });
    ```
  </Tab>

  <Tab title="OpenAI CUA">
    ```typescript  theme={null}
    const agent = stagehand.agent({
      cua: true,
      model: "openai/computer-use-preview",
      // OPENAI_API_KEY is auto-loaded from .env
      // ... other agent options
    });
    ```
  </Tab>

  <Tab title="Example First Class Model">
    All [first class models](/v3/configuration/models#first-class-models) are supported. Here's an example with Gemini:

    ```typescript  theme={null}
    const agent = stagehand.agent({
      model: "google/gemini-2.5-pro",
      // GOOGLE_GENERATIVE_AI_API_KEY is auto-loaded from .env
      // ... other agent options
    });
    ```
  </Tab>
</Tabs>

<Accordion title="All Supported CUA Models">
  | Provider  | Model                                            |
  | --------- | ------------------------------------------------ |
  | Google    | `google/gemini-2.5-computer-use-preview-10-2025` |
  | Anthropic | `anthropic/claude-3-7-sonnet-latest`             |
  | Anthropic | `anthropic/claude-haiku-4-5-20251001`            |
  | Anthropic | `anthropic/claude-sonnet-4-20250514`             |
  | Anthropic | `anthropic/claude-sonnet-4-5-20250929`           |
  | OpenAI    | `openai/computer-use-preview`                    |
  | OpenAI    | `openai/computer-use-preview-2025-03-11`         |
</Accordion>

<Note>
  For overriding the agent API key, using a corporate proxy, adding provider-specific options, or other advanced use cases, the agent model can also take the form of an object. To learn more, see the [Agent Reference](/v3/references/agent).
</Note>

***

### Custom Endpoints

If you need Azure OpenAI deployments or enterprise deployments.

<Tabs>
  <Tab title="OpenAI">
    For OpenAI, you can pass configuration directly without using `llmClient` using the `model` parameter:

    ```typescript  theme={null}
    const stagehand = new Stagehand({
      env: "BROWSERBASE",
      model: {
        model: "openai/gpt-5",
        apiKey: process.env.OPENAI_API_KEY,
        baseURL: "https://custom-openai-endpoint.com/v1"
      }
    });
    ```
  </Tab>

  <Tab title="Anthropic">
    For Anthropic, you can pass configuration directly without using `llmClient` using the `model` parameter:

    ```typescript  theme={null}
    const stagehand = new Stagehand({
      env: "BROWSERBASE",
      model: {
        model: "anthropic/claude-haiku-4-5",
        apiKey: process.env.ANTHROPIC_API_KEY,
        baseURL: "https://custom-anthropic-endpoint.com",
      },
    });
    ```
  </Tab>

  <Tab title="All Other Providers">
    For all other providers, use `llmClient`. Here's an example with Hugging Face:

    ```typescript  theme={null}
    // pnpm add @ai-sdk/huggingface

    import { createHuggingFace } from "@ai-sdk/huggingface";
    import { AISdkClient } from "@browserbasehq/stagehand";

    const huggingFaceProvider = createHuggingFace({
      apiKey: process.env.HUGGINGFACE_API_KEY,
      baseURL: "https://custom-huggingface-endpoint.com",
    });

    const huggingFaceClient = new AISdkClient({
      model: huggingFaceProvider("meta-llama/Llama-3.1-8B-Instruct"),
    });

    const stagehand = new Stagehand({
      env: "BROWSERBASE",
      llmClient: huggingFaceClient,
    });
    ```
  </Tab>
</Tabs>

***

### Extending the AI SDK Client

For advanced use cases like custom retries or caching logic, you can extend the `AISdkClient`:

```typescript  theme={null}
import { LLMClient } from "@browserbasehq/stagehand";

class CustomRetryClient extends LLMClient {
  async createChatCompletion(options) {
    let retries = 3;
    while (retries > 0) {
      try {
        return await super.createChatCompletion(options);
      } catch (error) {
        retries--;
        if (retries === 0) throw error;
        await new Promise((r) => setTimeout(r, 1000 * (4 - retries)));
      }
    }
  }
}
```

<Tip>
  Need custom caching? Consider using built-in [caching
  feature](/v3/best-practices/caching).
</Tip>

***

### Legacy Model Format

<Tip>
  **Recommendation:** Use `provider/model` format. Example:

  * `model: "openai/gpt-4o"` (recommended)
  * `model: "gpt-4o"` (legacy)
</Tip>

The following models work without the `provider/` prefix in the model parameter as part of legacy support:

<AccordionGroup title="Legacy Model Format">
  <Accordion title="Google">
    * `gemini-2.5-flash-preview-04-17`
    * `gemini-2.5-pro-preview-03-25`
    * `gemini-2.0-flash`
    * `gemini-2.0-flash-lite`
    * `gemini-1.5-flash`
    * `gemini-1.5-flash-8b`
    * `gemini-1.5-pro`
  </Accordion>

  <Accordion title="Anthropic">
    * `claude-3-7-sonnet-latest`
    * `claude-3-7-sonnet-20250219`
    * `claude-3-5-sonnet-latest`
    * `claude-3-5-sonnet-20241022`
    * `claude-3-5-sonnet-20240620`
  </Accordion>

  <Accordion title="OpenAI">
    * `gpt-4o`
    * `gpt-4o-mini`
    * `o1`
    * `o1-mini`
    * `o3`
    * `o3-mini`
    * `gpt-4.1`
    * `gpt-4.1-mini`
    * `gpt-4.1-nano`
    * `o4-mini`
    * `gpt-4.5-preview`
    * `gpt-4o-2024-08-06`
    * `o1-preview`
  </Accordion>

  <Accordion title="Cerebras">
    * `cerebras-llama-3.3-70b`
    * `cerebras-llama-3.1-8b`
  </Accordion>

  <Accordion title="Groq">
    * `groq-llama-3.3-70b-versatile`
    * `groq-llama-3.3-70b-specdec`
    * `moonshotai/kimi-k2-instruct`
  </Accordion>
</AccordionGroup>

***

## Troubleshooting

<AccordionGroup>
  <Accordion title="Error: API key not found">
    **Error:** `API key not found`

    **Solutions:**

    * Check `.env` file has the correct variable name for the provider you are using
    * Ensure environment variables are loaded (use `dotenv`)
    * Restart your application after updating `.env` file

    | Provider   | Environment Variable                               |
    | ---------- | -------------------------------------------------- |
    | Google     | `GOOGLE_GENERATIVE_AI_API_KEY` or `GEMINI_API_KEY` |
    | Anthropic  | `ANTHROPIC_API_KEY`                                |
    | OpenAI     | `OPENAI_API_KEY`                                   |
    | Azure      | `AZURE_API_KEY`                                    |
    | Cerebras   | `CEREBRAS_API_KEY`                                 |
    | DeepSeek   | `DEEPSEEK_API_KEY`                                 |
    | Groq       | `GROQ_API_KEY`                                     |
    | Mistral    | `MISTRAL_API_KEY`                                  |
    | Ollama     | None (local)                                       |
    | Perplexity | `PERPLEXITY_API_KEY`                               |
    | TogetherAI | `TOGETHER_AI_API_KEY`                              |
    | xAI        | `XAI_API_KEY`                                      |
  </Accordion>

  <Accordion title="Error: Model not supported">
    **Error:** `Unsupported model`

    **Solutions:**

    * Use the `provider/model` format: `openai/gpt-5`
    * Verify the model name exists in the provider's documentation
    * Check model name is spelled correctly
    * Ensure your Model API key can access the model
  </Accordion>

  <Accordion title="Model doesn't support structured outputs">
    **Error:** `Model does not support structured outputs`

    **Solutions:**

    * Check our [Model Evaluation page](https://www.stagehand.dev/evals) for recommended models
  </Accordion>

  <Accordion title="High costs or slow performance">
    **Symptoms:** Automation is expensive or slow

    **Solutions:**

    * Switch to cost-effective models (check [evals](https://www.stagehand.dev/evals) for comparisons)
    * Use faster models for simple tasks, powerful ones for complex tasks
    * Implement [caching](/v3/best-practices/caching) for repeated patterns
  </Accordion>

  <Accordion title="Python support for Stagehand v3 or custom models">
    We are working on Python support for Stagehand v3 and custom models.

    **Solutions:**

    * Request updates on Python support from our support team at [support@browserbase.com](mailto:support@browserbase.com)
  </Accordion>
</AccordionGroup>

### Need Help? Contact Support

Can't find a solution? Have a question? Reach out to our support team:

<Card title="Contact Support" icon="envelope" href="mailto:support@browserbase.com">
  Email us at [support@browserbase.com](mailto:support@browserbase.com)
</Card>

***

## Next Steps

<CardGroup cols={2}>
  <Card title="Prompting Guide" href="/v3/best-practices/prompting-best-practices" icon="brain">
    Learn how to prompt LLMs for optimal results
  </Card>

  <Card title="Run Evals" href="/v3/basics/evals" icon="flask-vial">
    Test which models work best for your specific use case
  </Card>

  <Card title="Caching Guide" href="/v3/best-practices/caching" icon="database">
    Cache responses to reduce costs and improve speed
  </Card>

  <Card title="Optimize Costs" href="/v3/best-practices/cost-optimization" icon="dollar-sign">
    Reduce LLM spending with caching and smart model selection
  </Card>
</CardGroup>
# Caching Actions

> Cache actions automatically to reduce costs and improve performance

Stagehand provides built-in action caching to reduce LLM inference calls and improve performance. Simply specify a `cacheDir` when initializing Stagehand, and actions are automatically cached and reused across runs.

## How Caching Works

When you specify a `cacheDir`:

1. **First run**: Actions use LLM inference and results are cached to a local file
2. **Subsequent runs**: Cached actions are reused automatically (no LLM calls)
3. **Cost savings**: Eliminate redundant inference calls for repeated actions
4. **Performance**: Faster execution by skipping LLM inference

## Caching with `act()`

Cache actions from `act()` by specifying a cache directory in your Stagehand constructor.

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";

const stagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "act-cache", // Specify a cache directory
});

await stagehand.init();
const page = stagehand.context.pages()[0];

await page.goto("https://browserbase.github.io/stagehand-eval-sites/sites/iframe-same-proc-scroll/");

// First run: uses LLM inference and caches
// Subsequent runs: reuses cached action
await stagehand.act("scroll to the bottom of the iframe");

// Variables work with caching too
await stagehand.act("fill the username field with %username%", {
  variables: {
    username: "fakeUsername",
  },
});
```

## Caching with `agent()`

Cache agent actions (including Computer Use Agent actions) the same way - just specify a `cacheDir`. The cache key is automatically generated based on the instruction, start URL, agent execution options, and agent configuration - subsequent runs with the same parameters will reuse cached actions.

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";

const stagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "agent-cache", // Specify a cache directory
});

await stagehand.init();
const page = stagehand.context.pages()[0];

await page.goto("https://browserbase.github.io/stagehand-eval-sites/sites/drag-drop/");

const agent = stagehand.agent({
  cua: true,
  model: {
    modelName: "google/gemini-2.5-computer-use-preview-10-2025",
    apiKey: process.env.GOOGLE_GENERATIVE_AI_API_KEY
  },
  systemPrompt: "You are a helpful assistant that can use a web browser.",
});

await page.goto("https://play2048.co/");

// First run: uses LLM inference and caches
// Subsequent runs: reuses cached actions
const result = await agent.execute({
  instruction: "play a gane of 2048",
  maxSteps: 20,
});

console.log(JSON.stringify(result, null, 2));
```

## Cache Directory Organization

You can organize your caches by using different directory names for different workflows:

```typescript  theme={null}
// Separate caches for different parts of your automation
const loginStagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "cache/login-flow"
});

const checkoutStagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "cache/checkout-flow"
});

const dataExtractionStagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "cache/data-extraction"
});
```

## Best Practices

<AccordionGroup>
  <Accordion title="Use descriptive cache directories">
    Organize caches by workflow or feature for easier management:

    ```typescript  theme={null}
    // Good: descriptive cache names
    cacheDir: "cache/login-actions"
    cacheDir: "cache/search-actions"
    cacheDir: "cache/form-submissions"

    // Avoid: generic cache names
    cacheDir: "cache"
    cacheDir: "my-cache"
    ```
  </Accordion>

  <Accordion title="Clear cache when DOM changes">
    If the website structure changes significantly, clear your cache directory to force fresh inference:

    ```bash  theme={null}
    rm -rf cache/login-actions
    ```

    Or programmatically:

    ```typescript  theme={null}
    import { rmSync } from 'fs';

    // Clear cache before running if needed
    if (shouldClearCache) {
      rmSync('cache/login-actions', { recursive: true, force: true });
    }

    const stagehand = new Stagehand({
      env: "BROWSERBASE",
      cacheDir: "cache/login-actions"
    });
    ```
  </Accordion>

  <Accordion title="Commit cache for CI/CD">
    Consider committing your cache directory to version control for consistent behavior across environments:

    ```gitignore  theme={null}
    # .gitignore
    # Don't ignore cache directories
    !cache/
    ```

    This ensures your CI/CD pipelines use the same cached actions without needing to run inference on first execution.
  </Accordion>
</AccordionGroup>
# Cost Optimization

> Minimize costs while maintaining automation performance

Cost optimization in Stagehand involves balancing LLM inference costs and browser infrastructure costs. This guide provides practical strategies to reduce your automation expenses.

## Quick Wins

Start with these simple optimizations that can reduce costs:

### 1. Use the Right Model for the Job

We don't recommend using larger, more premium models for simple tasks. See our [evaluation results](https://stagehand.dev/evals) for model performance and cost comparisons across different task types.

<CardGroup cols={2}>
  <Card title="Model Selection Guide" icon="brain" href="/configuration/models">
    Choose the right LLM for your budget and accuracy requirements
  </Card>

  <Card title="Evaluation Results" icon="chart-line" href="https://www.stagehand.dev/evals">
    See how different models perform on different tasks
  </Card>
</CardGroup>

### 2. Implement Caching

Enable automatic action caching to eliminate redundant LLM calls. Simply specify a `cacheDir` when initializing Stagehand:

```typescript  theme={null}
const stagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "action-cache", // Enable automatic caching
});

await stagehand.init();

// First run: uses LLM inference and caches
// Subsequent runs: reuses cached action (no LLM cost)
await stagehand.act("Click the sign in button");
```

<CardGroup cols={1}>
  <Card title="Caching Guide" icon="database" href="/best-practices/caching">
    Learn how to organize caches and manage cache directories
  </Card>
</CardGroup>

### 3. Optimize Browser Sessions

Reuse sessions when possible and set appropriate timeouts. See [Browser Configuration](/configuration/browser) for details:

```typescript  theme={null}
const stagehand = new Stagehand({
  env: "BROWSERBASE",
  browserbaseSessionCreateParams: {
    timeout: 1800, // 30 minutes instead of default 1 hour
    keepAlive: true, // Keep session alive between tasks
  }
});
```

<CardGroup cols={1}>
  <Card title="Browserbase Cost Optimization" icon="window-maximize" href="https://docs.browserbase.com/guides/cost-optimization">
    Optimize Browserbase infrastructure costs and session management
  </Card>
</CardGroup>

## Advanced Strategies

### Intelligent Model Switching

Automatically fall back to cheaper models for simple tasks:

```typescript  theme={null}
// Use models from least to most expensive based on task complexity
// See stagehand.dev/evals for performance comparisons
async function smartAct(prompt: string) {
  const models = ["google/gemini-2.5-flash", "openai/gpt-4o"];

  for (const model of models) {
    try {
      const stagehand = new Stagehand({
        env: "LOCAL",
        model: model
      });
      await stagehand.init();
      const [action] = await stagehand.observe(prompt);
      await stagehand.act(action);
      await stagehand.close();
      return;
    } catch (error) {
      console.log(`Falling back to ${model}...`);
      await stagehand.close();
    }
  }
}
```

### Session Pooling

Reuse browser sessions across multiple tasks:

```typescript  theme={null}
class SessionManager {
  private sessions = new Map<string, Stagehand>();
  
  async getSession(taskType: string): Promise<Stagehand> {
    if (this.sessions.has(taskType)) {
      return this.sessions.get(taskType)!;
    }
    
    const stagehand = new Stagehand({ env: "BROWSERBASE" });
    await stagehand.init();
    this.sessions.set(taskType, stagehand);
    return stagehand;
  }
}
```

## Cost Monitoring

Track your spending to identify optimization opportunities. See our [Observability Guide](/configuration/observability) for detailed metrics:

```typescript  theme={null}
// Monitor token usage
const metrics = await stagehand.metrics;
console.log(`Total tokens: ${metrics.totalPromptTokens + metrics.totalCompletionTokens}`);
console.log(`Estimated cost: $${(metrics.totalPromptTokens + metrics.totalCompletionTokens) * 0.00001}`);
```

<CardGroup cols={1}>
  <Card title="Observability & Metrics" icon="chart-line" href="/configuration/observability">
    Monitor usage patterns and track costs in real-time
  </Card>
</CardGroup>

## Budget Controls

Set spending limits to prevent unexpected costs:

```typescript  theme={null}
class BudgetGuard {
  private dailySpend = 0;
  private maxDailyBudget: number;
  
  constructor(maxDailyBudget: number = 25) {
    this.maxDailyBudget = maxDailyBudget;
  }
  
  checkBudget(estimatedCost: number): void {
    if (this.dailySpend + estimatedCost > this.maxDailyBudget) {
      throw new Error(`Daily budget exceeded: $${this.maxDailyBudget}`);
    }
    this.dailySpend += estimatedCost;
  }
}
```

## Related Resources

<CardGroup cols={2}>
  <Card title="Model Selection Guide" icon="brain" href="/configuration/models">
    Choose the right LLM for your budget and accuracy requirements
  </Card>

  <Card title="Caching Strategies" icon="database" href="/best-practices/caching">
    Reduce costs with smart action caching and observe patterns
  </Card>

  <Card title="Observability & Metrics" icon="chart-line" href="/configuration/observability">
    Monitor usage patterns and track costs in real-time
  </Card>

  <Card title="Browser Configuration" icon="window-maximize" href="/configuration/browser">
    Optimize Browserbase infrastructure costs and session management
  </Card>
</CardGroup>
# Deterministic Agent Scripts

> Use auto-caching to convert agent workflows into fast, deterministic scripts

Agent workflows are powerful for exploring and automating complex tasks, but they can be slow and non-deterministic. This guide shows you how to use Stagehand's built-in auto-caching to convert agent-discovered workflows into fast, deterministic scripts that run 10-100x faster.

## Why Use Auto-Caching with Agent?

<CardGroup cols={2}>
  <Card title="Speed" icon="bolt">
    Cached agent workflows run 10-100x faster by skipping LLM inference on subsequent runs
  </Card>

  <Card title="Cost" icon="dollar-sign">
    Eliminate repeated LLM calls—first run uses inference, subsequent runs use cache
  </Card>

  <Card title="Reliability" icon="shield-check">
    Cached actions are deterministic and more predictable than fresh agent exploration
  </Card>

  <Card title="Simplicity" icon="wand-magic-sparkles">
    Works automatically—just specify `cacheDir` and Stagehand handles everything
  </Card>
</CardGroup>

## How Auto-Caching Works

When you specify a `cacheDir`:

1. **First run**: Agent explores and executes workflow using LLM inference
2. **Actions cached**: All actions are automatically saved to local cache
3. **Subsequent runs**: Same workflow reuses cached actions (no LLM calls)
4. **Performance**: 10-100x faster execution, zero LLM tokens

The cache key is automatically generated based on:

* Agent instruction
* Start URL
* Agent execution options
* Agent configuration

## Basic Auto-Caching with Agent

Simply add `cacheDir` when initializing Stagehand:

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";

// Enable auto-caching
const stagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "agent-cache" // Automatic caching enabled
});

await stagehand.init();
const page = stagehand.context.pages()[0];

await page.goto("https://example.com");

const agent = stagehand.agent({
  cua: true,
  model: {
    modelName: "google/gemini-2.5-computer-use-preview-10-2025",
    apiKey: process.env.GOOGLE_GENERATIVE_AI_API_KEY
  },
  systemPrompt: "You are a helpful assistant that can use a web browser.",
});

// First run: Uses LLM inference (~20-30 seconds, ~50,000 tokens)
// Subsequent runs: Uses cached actions (~2-3 seconds, 0 tokens)
const result = await agent.execute({
  instruction: "Find the login form, fill in username 'demo' and password 'test123', then click submit",
  maxSteps: 10
});

console.log("Completed:", result.success);
console.log("Actions taken:", result.actions.length);

await stagehand.close();
```

That's it! The second time you run this script, it will reuse the cached agent actions automatically.

## Organizing Caches by Workflow

Use descriptive cache directories for different workflows:

```typescript  theme={null}
// Login workflow
const loginStagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "cache/login-workflow"
});

// Checkout workflow
const checkoutStagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "cache/checkout-workflow"
});

// Data extraction workflow
const extractStagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "cache/extraction-workflow"
});
```

## Complete Example: First vs Subsequent Runs

### First Run (Exploration Mode)

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";

const stagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "cache/github-search" // Enable caching
});

await stagehand.init();
const page = stagehand.context.pages()[0];

await page.goto("https://github.com");

const agent = stagehand.agent({
  cua: true,
  model: {
    modelName: "google/gemini-2.5-computer-use-preview-10-2025",
    apiKey: process.env.GOOGLE_GENERATIVE_AI_API_KEY
  },
  systemPrompt: "You are a helpful assistant that can use a web browser.",
});

console.log("First run: Exploring with agent...");
const startTime = Date.now();

const result = await agent.execute({
  instruction: "Search for 'stagehand' and click the first repository result",
  maxSteps: 10
});

const duration = Date.now() - startTime;
console.log(`First run completed in ${duration}ms`);
console.log(`Actions: ${result.actions.length}`);
console.log(`Status: ${result.success}`);

await stagehand.close();

// Output (example):
// First run completed in 25000ms
// Actions: 8
// Status: true
```

### Subsequent Runs (Cached Mode)

Run the **exact same script** again:

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";

const stagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "cache/github-search" // Same cache directory
});

await stagehand.init();
const page = stagehand.context.pages()[0];

await page.goto("https://github.com");

const agent = stagehand.agent({
  cua: true,
  model: {
    modelName: "google/gemini-2.5-computer-use-preview-10-2025",
    apiKey: process.env.GOOGLE_GENERATIVE_AI_API_KEY
  },
  systemPrompt: "You are a helpful assistant that can use a web browser.",
});

console.log("Subsequent run: Using cached actions...");
const startTime = Date.now();

const result = await agent.execute({
  instruction: "Search for 'stagehand' and click the first repository result",
  maxSteps: 10
});

const duration = Date.now() - startTime;
console.log(`Subsequent run completed in ${duration}ms`);
console.log(`Actions: ${result.actions.length}`);
console.log(`Status: ${result.success}`);

await stagehand.close();

// Output (example):
// Subsequent run completed in 2500ms  ← 10x faster!
// Actions: 8
// Status: true
```

## Using History for Analysis

While caching handles execution automatically, you can still use `stagehand.history` to analyze what happened:

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";
import fs from "fs/promises";

const stagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "cache/workflow"
});

await stagehand.init();
const page = stagehand.context.pages()[0];

await page.goto("https://example.com");

const agent = stagehand.agent({
  cua: true,
  model: {
    modelName: "google/gemini-2.5-computer-use-preview-10-2025",
    apiKey: process.env.GOOGLE_GENERATIVE_AI_API_KEY
  },
  systemPrompt: "You are a helpful assistant that can use a web browser.",
});

await agent.execute({
  instruction: "Complete the login process",
  maxSteps: 10
});

// Analyze what the agent did
const history = await stagehand.history;

console.log(`\nWorkflow Analysis:`);
console.log(`Total operations: ${history.length}`);

const agentOps = history.filter(e => e.method === 'agent');
const actOps = history.filter(e => e.method === 'act');
const navOps = history.filter(e => e.method === 'navigate');

console.log(`- Agent executions: ${agentOps.length}`);
console.log(`- Act operations: ${actOps.length}`);
console.log(`- Navigate operations: ${navOps.length}`);

// Save for documentation
await fs.writeFile(
  'workflow-analysis.json',
  JSON.stringify(history, null, 2)
);

await stagehand.close();
```

## Cache Management

### Clear Cache When Site Changes

If the website structure changes, clear the cache to force fresh exploration:

```typescript  theme={null}
import { rmSync } from 'fs';

// Clear specific workflow cache
rmSync('cache/login-workflow', { recursive: true, force: true });

// Then run with fresh exploration
const stagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "cache/login-workflow" // Will rebuild cache
});
```

### Programmatic Cache Control

```typescript  theme={null}
import { rmSync, existsSync } from 'fs';

function clearCacheIfNeeded(cacheDir: string, maxAge: number = 7 * 24 * 60 * 60 * 1000) {
  if (!existsSync(cacheDir)) {
    return; // No cache to clear
  }

  const stats = statSync(cacheDir);
  const age = Date.now() - stats.mtimeMs;

  if (age > maxAge) {
    console.log(`Cache older than ${maxAge}ms, clearing...`);
    rmSync(cacheDir, { recursive: true, force: true });
  }
}

// Clear cache if older than 7 days
clearCacheIfNeeded('cache/workflow');

const stagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "cache/workflow"
});
```

## Advanced Patterns

### Parameterized Agent Workflows

Use variables to make cached workflows reusable with different inputs:

```typescript  theme={null}
async function executeLogin(username: string, password: string) {
  const stagehand = new Stagehand({
    env: "BROWSERBASE",
    cacheDir: "cache/login"
  });

  await stagehand.init();
  const page = stagehand.context.pages()[0];

  await page.goto("https://example.com/login");

  const agent = stagehand.agent({
    model: "anthropic/claude-sonnet-4-20250514"
  });

  // Variables work with caching
  const result = await agent.execute({
    instruction: `Fill in username with "${username}" and password with "${password}", then click submit`,
    maxSteps: 5
  });

  await stagehand.close();
  return result.success;
}

// First user: Caches the workflow
await executeLogin("user1@example.com", "password123");

// Second user: Reuses cached workflow structure
await executeLogin("user2@example.com", "differentpass");
```

### Fallback to Fresh Exploration

Combine caching with fallback for resilience:

```typescript  theme={null}
async function executeWithFallback() {
  const stagehand = new Stagehand({
    env: "BROWSERBASE",
    cacheDir: "cache/workflow",
    selfHeal: true // Enable self-healing
  });

  await stagehand.init();
  const page = stagehand.context.pages()[0];

  await page.goto("https://example.com");

  const agent = stagehand.agent({
    model: "anthropic/claude-sonnet-4-20250514"
  });

  try {
    // Try with cache
    const result = await agent.execute({
      instruction: "Complete the checkout process",
      maxSteps: 15
    });

    console.log("Execution successful:", result.success);
  } catch (error) {
    console.error("Cached workflow failed:", error);

    // Clear cache and retry with fresh exploration
    rmSync('cache/workflow', { recursive: true, force: true });

    console.log("Retrying with fresh exploration...");
    const retryResult = await agent.execute({
      instruction: "Complete the checkout process",
      maxSteps: 15
    });

    console.log("Retry successful:", retryResult.success);
  }

  await stagehand.close();
}
```

### Version Control for Caches

Commit cache directories to ensure consistent behavior across environments:

```gitignore  theme={null}
# .gitignore

# Commit cache directories for deterministic CI/CD
!cache/
!cache/**/*.json
```

```typescript  theme={null}
// CI/CD pipeline will use pre-generated cache
const stagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "cache/production-workflow" // Committed to repo
});
```

## Best Practices

<AccordionGroup>
  <Accordion title="Use Descriptive Cache Names">
    Organize caches by workflow or feature:

    ```typescript  theme={null}
    // Good: descriptive cache names
    cacheDir: "cache/user-registration"
    cacheDir: "cache/product-search"
    cacheDir: "cache/checkout-flow"

    // Avoid: generic names
    cacheDir: "cache"
    cacheDir: "my-cache"
    ```
  </Accordion>

  <Accordion title="Cache Invalidation Strategy">
    Implement a strategy for refreshing caches:

    ```typescript  theme={null}
    // Option 1: Time-based invalidation
    if (isCacheOlderThan('cache/workflow', 7)) {
      clearCache('cache/workflow');
    }

    // Option 2: Version-based invalidation
    const CACHE_VERSION = 'v2';
    const cacheDir = `cache/workflow-${CACHE_VERSION}`;

    // Option 3: Manual invalidation flag
    if (process.env.CLEAR_CACHE === 'true') {
      clearCache('cache/workflow');
    }
    ```
  </Accordion>

  <Accordion title="Test in Staging First">
    Always test cached workflows in staging before production:

    ```typescript  theme={null}
    const env = process.env.NODE_ENV === 'production' ? 'production' : 'staging';

    const stagehand = new Stagehand({
      env: "BROWSERBASE",
      cacheDir: `cache/${env}-workflow`
    });
    ```
  </Accordion>

  <Accordion title="Monitor Cache Hit Rates">
    Track cache usage for optimization:

    ```typescript  theme={null}
    const cacheHit = existsSync('cache/workflow') &&
                    statSync('cache/workflow').mtimeMs < Date.now();

    if (cacheHit) {
      console.log("Cache hit - using cached workflow");
    } else {
      console.log("Cache miss - exploring with agent");
    }

    // Log metrics
    metrics.recordCacheHit(cacheHit);
    ```
  </Accordion>
</AccordionGroup>

## Performance Comparison

**Without Caching (Every Run):**

```typescript  theme={null}
const stagehand = new Stagehand({ env: "BROWSERBASE" });
// No cacheDir specified

const result = await agent.execute({
  instruction: "Complete workflow",
  maxSteps: 10
});

// Every run: ~20-30 seconds, ~50,000 tokens
```

**With Auto-Caching (First Run):**

```typescript  theme={null}
const stagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "cache/workflow"
});

const result = await agent.execute({
  instruction: "Complete workflow",
  maxSteps: 10
});

// First run: ~20-30 seconds, ~50,000 tokens (cached for next time)
```

**With Auto-Caching (Subsequent Runs):**

```typescript  theme={null}
const stagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "cache/workflow" // Reuses cache
});

const result = await agent.execute({
  instruction: "Complete workflow",
  maxSteps: 10
});

// Subsequent runs: ~2-3 seconds, 0 tokens ← 10-100x faster!
```

<Note>
  Cached agent workflows run **10-100x faster** and consume **zero LLM tokens** on subsequent runs. The first run pays the exploration cost, every run after is nearly instant.
</Note>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Cache not being used">
    **Problem**: Workflow still slow on subsequent runs

    **Solutions**:

    * Verify `cacheDir` path is correct and consistent across runs
    * Ensure instruction, URL, and agent config are identical
    * Check file permissions on cache directory
    * Look for cache hit/miss logs in verbose mode

    ```typescript  theme={null}
    const stagehand = new Stagehand({
      env: "BROWSERBASE",
      cacheDir: "cache/workflow",
      verbose: 2 // Enable debug logs
    });
    ```
  </Accordion>

  <Accordion title="Cached workflow fails">
    **Problem**: Cached actions fail on subsequent runs

    **Solutions**:

    * Website may have changed—clear cache to re-explore
    * Enable self-healing to adapt to minor changes
    * Implement fallback logic to retry with fresh exploration

    ```typescript  theme={null}
    const stagehand = new Stagehand({
      env: "BROWSERBASE",
      cacheDir: "cache/workflow",
      selfHeal: true // Adapt to changes
    });
    ```
  </Accordion>

  <Accordion title="Too many cache directories">
    **Problem**: Cache directories growing uncontrolled

    **Solutions**:

    * Use version prefixes for cache directories
    * Implement automatic cleanup of old caches
    * Share cache directories for similar workflows

    ```typescript  theme={null}
    // Versioned caches
    const CACHE_VERSION = '2024-01';
    const cacheDir = `cache/workflow-${CACHE_VERSION}`;

    // Cleanup old versions
    rmSync('cache/workflow-2023-12', { recursive: true, force: true });
    ```
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Agent Guide" icon="robot" href="/v3/basics/agent">
    Learn more about agent capabilities and configuration
  </Card>

  <Card title="Caching Guide" icon="database" href="/v3/best-practices/caching">
    Complete guide to auto-caching with act() and agent()
  </Card>

  <Card title="Observability" icon="chart-line" href="/v3/configuration/observability">
    Monitor and track history and metrics
  </Card>

  <Card title="Speed Optimization" icon="bolt" href="/v3/best-practices/speed-optimization">
    Additional techniques for faster automation
  </Card>
</CardGroup>
# Using Multiple Tabs

> Act on multiple tabs with Stagehand

Many modern web applications open new tabs when users click certain buttons or links. Without proper multitab support, automation scripts break when expected content appears in a new tab rather than the current one. Stagehand's multitab capabilities ensure your automations work seamlessly across multitab workflows.

## The Stagehand Page

Stagehand automatically adapts to multitab workflows. The active page (accessed via `context.activePage()`) always points to the most recently opened or active tab, ensuring your automations continue working even when new tabs are created.

This means you can continue using familiar patterns:

```typescript  theme={null}
const page = stagehand.context.pages()[0];
await page.goto("https://example.com");
await stagehand.act("click the button that opens a new tab");
// page now automatically points to the new tab
await stagehand.extract("get data from new tab");
```

<Warning>
  **Important**: [Stagehand Agent](/v3/basics/agent) will always operate on the active page. If you need an agent to work across specific tabs, you'll need to manage page switching manually.
</Warning>

## Manual Page Management

For more control or multitab workflows, you can manage multiple tabs explicitly:

```typescript  theme={null}
// Create a second page
await stagehand.context.newPage();
const pages = stagehand.context.pages();

const githubPage = pages[0];
const pythonPage = pages[1];

// Navigate each page to different repositories
await githubPage.goto("https://github.com/browserbase/stagehand");
await pythonPage.goto("https://github.com/browserbase/stagehand-python");

// Extract data from both pages simultaneously
const [stagehandStars, stagehandPythonStars] = await Promise.all([
  stagehand.extract("extract the repository stars", { page: githubPage }),
  stagehand.extract("extract the repository stars", { page: pythonPage })
]);

console.log(`Stagehand stars: ${stagehandStars}`);
console.log(`Stagehand-Python stars: ${stagehandPythonStars}`);
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Orchestrate complex workflows with Agent" icon="robot" iconType="sharp-solid" href="/v3/basics/agent">
    Use `Agent` to autonomously execute multi-step tasks and complex workflows.
  </Card>

  <Card title="Working with iframes" icon="frame" iconType="sharp-solid" href="/v3/best-practices/working-with-iframes">
    Learn best practices for interacting with elements inside iframes.
  </Card>

  <Card title="Browser Configuration" icon="browser" iconType="sharp-solid" href="/v3/configuration/browser">
    Manage browser contexts and sessions for complex automation scenarios.
  </Card>

  <Card title="Logging & Debugging" icon="bug" iconType="sharp-solid" href="/v3/configuration/logging">
    Handle errors gracefully and debug automation issues effectively.
  </Card>
</CardGroup>
# Deploying Stagehand

> Deploy your AI agents and automations to the cloud

<Tip>
  **🌟 Preview: Browser Functions** - Deploy your web automation code directly on Browserbase with browser functions. Scale your `act()` automations in the cloud with zero infrastructure setup. Reach out to [hello@browserbase.com](mailto:hello@browserbase.com) to get beta access.
</Tip>

## Deploy on Vercel

Securely run Stagehand on Browserbase inside a Vercel Function. This guide shows a minimal, production-safe HTTP endpoint you can call directly or on a schedule.

### 1. Install Vercel CLI

To download and install Vercel CLI, run one of the following commands:

<CodeGroup>
  ```bash pnpm theme={null}
  pnpm i -g vercel
  ```

  ```bash yarn theme={null}
  yarn global add vercel
  ```

  ```bash npm theme={null}
  npm i -g vercel
  ```

  ```bash bun theme={null}
  bun add -g vercel
  ```
</CodeGroup>

### 2. Project layout

```text  theme={null}
your-project/
  api/
    run.ts
  package.json
  tsconfig.json
  vercel.json
```

Create the structure with:

```bash  theme={null}
mkdir -p api
touch api/run.ts package.json vercel.json tsconfig.json
```

### 3. `api/run.ts` (Node.js runtime)

```typescript  theme={null}
// api/run.ts
import type { VercelRequest, VercelResponse } from "@vercel/node";
import { Stagehand } from "@browserbasehq/stagehand";
import { z } from "zod/v3";

export default async function handler(req: VercelRequest, res: VercelResponse): Promise<void> {
  try {
    const stagehand = new Stagehand({
      env: "BROWSERBASE",
      apiKey: process.env.BROWSERBASE_API_KEY!,
      projectId: process.env.BROWSERBASE_PROJECT_ID!,
      disablePino: true,
      model: {
        modelName: "google/gemini-2.5-flash",
        apiKey: process.env.GOOGLE_API_KEY!,
      },
      // optional session params
      browserbaseSessionCreateParams: {
        projectId: process.env.BROWSERBASE_PROJECT_ID!,
        region: "us-west-2",
        browserSettings: {
          blockAds: true,
        },
      },
    });

    await stagehand.init();
    const page = stagehand.context.pages()[0];

    await page.goto("https://www.stagehand.dev/");
    await stagehand.act("click the evals button");

    const fastestModel = await stagehand.extract("extract the fastest model", z.string());

    await stagehand.close();

    res.status(200).json({ ok: true, data: fastestModel });
  } catch (err: unknown) {
    const msg = err instanceof Error ? err.message : String(err);
    res.status(500).json({ ok: false, error: msg });
  }
}
```

### 4. `package.json`

```json  theme={null}
{
    "name": "bb-stagehand-on-vercel",
    "private": true,
    "type": "module",
    "engines": { "node": ">=18" },
    "dependencies": {
      "@browserbasehq/stagehand": "^3.0.0"
    },
    "devDependencies": {
      "@types/node": "^20.12.12",
      "@vercel/node": "^3.2.20",
      "typescript": "^5.2.2"
    }
}
```

### 5. `tsconfig.json`

```json  theme={null}
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "node",
    "outDir": ".vercel/output/functions",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "types": ["node"]
  },
  "include": ["api/**/*.ts"]
}
```

### 6. `vercel.json`

```json  theme={null}
{
  "$schema": "https://openapi.vercel.sh/vercel.json",
  "functions": {
    "api/run.ts": {
      "maxDuration": 60
    }
  }
}
```

See Vercel's [configuring functions](https://vercel.com/docs/functions/configuring-functions) docs for more details.

### 7. Link your project

Link your local folder to a Vercel project before configuring environment variables:

```bash  theme={null}
# authenticate if needed
vercel login

# link the current directory to a Vercel project (interactive)
vercel link
```

### 8. Environment variables

Do not commit `.env` in production. Add variables via Vercel CLI:

```bash  theme={null}
vercel env add BROWSERBASE_API_KEY
vercel env add BROWSERBASE_PROJECT_ID
# (and your model key if needed)
vercel env add GOOGLE_API_KEY
```

See also: [Browser Environment](/configuration/environment) for details on required variables.

### 9. Test locally

Replicate the Vercel environment locally to exercise your Function before deploying. Run from the project root.

```bash  theme={null}
# ensure dependencies are installed
npm install

# start the local Vercel dev server
vercel dev --listen 5005
```

### 10. Deploy

```bash  theme={null}
vercel
vercel --prod
```

### Execute the function

#### Configure Protection Bypass for Automation

Before invoking the production URL, create a Protection Bypass for Automation:

1. Generate a 32-character secret (you can use `openssl rand -hex 16`)
2. Go to your project in Vercel
3. Navigate to Settings → Deployment Protection
4. Add the secret to "Protection Bypass for Automation"

Then invoke the function with the bypass header:

```bash  theme={null}
curl -X POST \
  -H "x-vercel-protection-bypass: <your-32-character-secret>" \
  https://<your-deployment>/api/run
```

### Optional: Cron on Vercel

Hit the same endpoint on a schedule by extending `vercel.json`:

```json  theme={null}
{
  "$schema": "https://openapi.vercel.sh/vercel.json",
  "functions": {
    "api/run.ts": {
      "maxDuration": 60
    }
  }
  },
  "crons": [
    { "path": "/api/run", "schedule": "0 * * * *" }
  ]
}
```

### Features

* **No local browsers needed** with `env: "BROWSERBASE"`. [Browserbase](https://www.browserbase.com/) provides the browsers.
* **Fast functionality**: Offload browser work to Browserbase and return JSON promptly.
* **Long-running tasks**: Raise `maxDuration` and/or consider Edge runtime limits depending on plan.
# History Tracking

> Track and analyze Stagehand operations with the history API

The history API captures every Stagehand operation for debugging, auditing, and workflow analysis.

## Basic Usage

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";

const stagehand = new Stagehand({ env: "BROWSERBASE" });
await stagehand.init();
const page = stagehand.context.pages()[0];

await page.goto("https://example.com");
await stagehand.act("click login button");

// Get complete history
const history = await stagehand.history;

console.log(`Total operations: ${history.length}`);
history.forEach((entry, i) => {
  console.log(`${i + 1}. ${entry.method} at ${entry.timestamp}`);
});

await stagehand.close();
```

## History Entry Structure

```typescript  theme={null}
interface HistoryEntry {
  method: "act" | "extract" | "observe" | "navigate" | "agent";
  parameters: unknown;  // Input parameters
  result: unknown;      // Output/result
  timestamp: string;    // ISO 8601 timestamp
}
```

## Common Use Cases

### Debugging Failures

```typescript  theme={null}
try {
  await stagehand.act("click login button");
} catch (error) {
  const history = await stagehand.history;

  history.forEach((entry, i) => {
    const status = entry.result && 'error' in entry.result ? "FAILED" : "SUCCESS";
    console.log(`${i + 1}. ${status} - ${entry.method}`);
  });
}
```

### Analyzing Timing

```typescript  theme={null}
const history = await stagehand.history;

const timings = history.map((entry, i) => {
  if (i === 0) return null;
  const duration = new Date(entry.timestamp).getTime() -
                   new Date(history[i - 1].timestamp).getTime();
  return { operation: entry.method, duration };
}).filter(Boolean);

console.log("Slowest operations:",
  timings.sort((a, b) => b.duration - a.duration).slice(0, 3)
);
```

### Operation Statistics

```typescript  theme={null}
const history = await stagehand.history;

const stats = history.reduce((acc, entry) => {
  acc[entry.method] = (acc[entry.method] || 0) + 1;
  return acc;
}, {} as Record<string, number>);

console.log("Operations:", stats);
// { act: 5, extract: 2, observe: 3, navigate: 1 }
```

### Saving History

```typescript  theme={null}
import fs from "fs/promises";

const history = await stagehand.history;
const metrics = await stagehand.metrics;

await fs.writeFile(
  `workflow-report.json`,
  JSON.stringify({
    history,
    totalOps: history.length,
    totalTokens: metrics.totalPromptTokens + metrics.totalCompletionTokens
  }, null, 2)
);
```

## Filtering by Operation Type

```typescript  theme={null}
const history = await stagehand.history;

const actions = history.filter(e => e.method === 'act');
const extractions = history.filter(e => e.method === 'extract');
const agentOps = history.filter(e => e.method === 'agent');

console.log(`Actions: ${actions.length}`);
console.log(`Extractions: ${extractions.length}`);
console.log(`Agent executions: ${agentOps.length}`);
```

## Combining with Metrics

```typescript  theme={null}
const history = await stagehand.history;
const metrics = await stagehand.metrics;

const report = {
  totalOps: history.length,
  successful: history.filter(e => !e.result || !('error' in e.result)).length,
  failed: history.filter(e => e.result && 'error' in e.result).length,
  totalTokens: metrics.totalPromptTokens + metrics.totalCompletionTokens,
  avgTimePerOp: `${(metrics.totalInferenceTimeMs / history.length).toFixed(0)}ms`
};

console.log(report);
```

<Card title="Observability Guide" icon="chart-line" href="/configuration/observability">
  Learn more about metrics, logging, and monitoring
</Card>

## What's Tracked?

Only Stagehand methods are tracked in history:

```typescript  theme={null}
// Tracked
await stagehand.act("click button");              // ✓
await stagehand.extract({ instruction: "..." }); // ✓
await stagehand.observe("find elements");         // ✓
await page.goto("https://example.com");      // ✓

// Not tracked
await page.locator("button").click();        // ✗ Native Playwright
await page.click("button");                  // ✗ Native Playwright
```

## Best Practices

* **Save history for critical workflows** - Maintain audit trails for production
* **Inspect history when debugging** - Check the last operations to identify failures
* **Analyze timing periodically** - Find slow operations and optimize
* **Combine with metrics** - Get complete visibility into performance and cost

## Next Steps

<CardGroup cols={2}>
  <Card title="Deterministic Agent" icon="robot" href="/best-practices/deterministic-agent">
    Build fast, cached agent workflows
  </Card>

  <Card title="Observability" icon="chart-line" href="/configuration/observability">
    Combine history with metrics
  </Card>

  <Card title="Caching" icon="database" href="/best-practices/caching">
    Speed up workflows with caching
  </Card>

  <Card title="Logging" icon="file-lines" href="/configuration/logging">
    Configure detailed execution traces
  </Card>
</CardGroup>
# Computer Use Agents

> Incorporate Computer Use APIs from Google, Anthropic, and OpenAI with one line of code in Stagehand.

## What is a Computer Use Agent?

<iframe width="100%" height="400" src="https://www.youtube.com/embed/ODaHJzOyVCQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen />

You might've heard of [Gemini Computer Use](https://blog.google/technology/google-deepmind/gemini-computer-use-model/), [Claude Computer Use](https://www.anthropic.com/news/3-5-models-and-computer-use), or [OpenAI's Computer Using Agent](https://openai.com/index/computer-using-agent/).

These are powerful tools that can convert natural language into actions on the computer. However, you'd otherwise need to write your own code to convert these actions into Playwright commands.

Stagehand not only handles the execution of Computer Use outputs, but also lets you hot-swap between Google, OpenAI, and Anthropic models with one line of code. You can find more information on the performance of different computer use models by visiting our [evals page](https://www.stagehand.dev/agent-evals).

## How to use a Computer Use Agent in Stagehand

Stagehand lets you use Computer Use Agents with one line of code:

<Note>
  **IMPORTANT! Configure your browser dimensions**

  Computer Use Agents will often return XY-coordinates to click on the screen, so you'll need to configure your browser dimensions.

  If not specified, the default browser dimensions are 1288 x 711. You can also configure the browser dimensions in the `browserbaseSessionCreateParams` or `localBrowserLaunchOptions` options.
</Note>

### Configuring browser dimensions

Browser configuration differs by environment:

<Tabs>
  <Tab title="BROWSERBASE">
    ```typescript  theme={null}
    import { Stagehand } from "@browserbasehq/stagehand";

    const stagehand = new Stagehand({
    	env: "BROWSERBASE",
        model: "google/gemini-2.5-flash",
      
        browserbaseSessionCreateParams: {
          projectId: process.env.BROWSERBASE_PROJECT_ID!,
          browserSettings: {
    		blockAds: true,
            viewport: {
              width: 1288,
              height: 711,
            },
          },
      	},
    });

    await stagehand.init();
    ```
  </Tab>

  <Tab title="LOCAL">
    ```typescript  theme={null}
    import { Stagehand } from "@browserbasehq/stagehand";

    const stagehand = new Stagehand({
      env: "LOCAL",
      localBrowserLaunchOptions: {
        headless: false,
        viewport: {
          width: 1288,
          height: 711,
        },
      }
    });

    await stagehand.init();
    ```
  </Tab>
</Tabs>

### Direct your Computer Use Agent

Call `execute` on the agent to assign a task to the agent.

<CodeGroup>
  ```typescript Google theme={null}
  await page.goto("https://www.google.com/");
  const agent = stagehand.agent({
      cua: true,
      model: {
          modelName: "google/gemini-2.5-computer-use-preview-10-2025",
          apiKey: process.env.GOOGLE_GENERATIVE_AI_API_KEY
      },
      systemPrompt: "You are a helpful assistant...",
  });

  await agent.execute({
      instruction: "Go to Hacker News and find the most controversial post from today, then read the top 3 comments and summarize the debate.",
      maxSteps: 20,
      highlightCursor: true
  })
  ```

  ```typescript OpenAI theme={null}
  await page.goto("https://www.google.com/");
  const agent = stagehand.agent({
      cua: true,
      model: {
          modelName: "openai/computer-use-preview",
          apiKey: process.env.OPENAI_API_KEY
      },
      systemPrompt: "You are a helpful assistant...",
  });

  await agent.execute({
      instruction: "Go to Hacker News and find the most controversial post from today, then read the top 3 comments and summarize the debate.",
      maxSteps: 20,
      highlightCursor: true
  })
  ```

  ```typescript Anthropic theme={null}
  await page.goto("https://www.google.com/");
  const agent = stagehand.agent({
      cua: true,
      model: {
          modelName: "anthropic/claude-sonnet-4-20250514",
          apiKey: process.env.ANTHROPIC_API_KEY
      },
      systemPrompt: "You are a helpful assistant...",
  });

  await agent.execute({
      instruction: "Go to Hacker News and find the most controversial post from today, then read the top 3 comments and summarize the debate.",
      maxSteps: 20,
      highlightCursor: true
  })
  ```
</CodeGroup>

You can define the maximum number of steps the agent can take with `maxSteps`:

```typescript  theme={null}
await agent.execute({
	instructions: "Apply for a library card at the San Francisco Public Library",
	maxSteps: 10,
});
```

### Select Your Computer Use Model

Stagehand supports computer use models from Google, Anthropic, and OpenAI. You can find all supported models on the [models page](/v3/configuration/models#agent-models-with-cua-support).

<Tabs>
  <Tab title="Google">
    ```typescript  theme={null}
    const agent = stagehand.agent({
        cua: true,
        model: "google/gemini-2.5-computer-use-preview-10-2025",
        // GOOGLE_GENERATIVE_AI_API_KEY is auto-loaded - set in your .env
    });
    ```
  </Tab>

  <Tab title="Anthropic">
    ```typescript  theme={null}
    const agent = stagehand.agent({
        cua: true,
        model: "anthropic/claude-sonnet-4-20250514",
        // ANTHROPIC_API_KEY is auto-loaded - set in your .env
    });
    ```
  </Tab>

  <Tab title="OpenAI">
    ```typescript  theme={null}
    const agent = stagehand.agent({
        cua: true,
        model: "openai/computer-use-preview",
        // OPENAI_API_KEY is auto-loaded - set in your .env
    });
    ```
  </Tab>
</Tabs>
# Agent Fallbacks

> A failsafe when unexpected page changes add extra steps

## When to use

Use an agent fallback as a failsafe when a one step action unexpectedly becomes a multi-step flow.

## How it works

1. [`act()`](/v3/basics/act) is attempted for the direct action
2. If it fails, [`agent()`](/v3/basics/agent) figures out the new path
3. Agent completes all needed steps (open menu → click button)

### Example scenario

**Before**: Sign in button was in the header\
**After**: Sign in now requires: Click account menu → Click "Sign in" option

A single `act("click sign in")` can't handle this change. The agent fallback can discover and execute both steps.

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";

try {
  await stagehand.act("click the 'Sign In' button");
} catch (err) {
  console.log("Agent fallback triggered");

  const agent = stagehand.agent({
    model: "anthropic/claude-sonnet-4-20250514",
    systemPrompt: "You are a helpful assistant that can use a web browser.",
  });

  const result = await agent.execute({
    instruction: "Find and click Sign In button",
    maxSteps: 10,
  });

  console.log(result.success ? "Agent fallback success" : "Agent fallback failed");

  if (!result.success) throw err;
}
```

See all available agent models on the [models page](/v3/configuration/models#agent-models-with-cua-support).
# Agent Fallbacks

> A failsafe when unexpected page changes add extra steps

## When to use

Use an agent fallback as a failsafe when a one step action unexpectedly becomes a multi-step flow.

## How it works

1. [`act()`](/v3/basics/act) is attempted for the direct action
2. If it fails, [`agent()`](/v3/basics/agent) figures out the new path
3. Agent completes all needed steps (open menu → click button)

### Example scenario

**Before**: Sign in button was in the header\
**After**: Sign in now requires: Click account menu → Click "Sign in" option

A single `act("click sign in")` can't handle this change. The agent fallback can discover and execute both steps.

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";

try {
  await stagehand.act("click the 'Sign In' button");
} catch (err) {
  console.log("Agent fallback triggered");

  const agent = stagehand.agent({
    model: "anthropic/claude-sonnet-4-20250514",
    systemPrompt: "You are a helpful assistant that can use a web browser.",
  });

  const result = await agent.execute({
    instruction: "Find and click Sign In button",
    maxSteps: 10,
  });

  console.log(result.success ? "Agent fallback success" : "Agent fallback failed");

  if (!result.success) throw err;
}
```

See all available agent models on the [models page](/v3/configuration/models#agent-models-with-cua-support).
# MCP Integrations

> Using Model Context Protocol (MCP) integrations to enhance agent capabilities

## What are MCP Integrations?

MCP (Model Context Protocol) integrations allow you to connect your Stagehand agents to external tools, APIs, and services. This enables agents to perform actions beyond browser automation, such as web search, database operations, and API calls.

<Info>
  MCP integrations make your agents more powerful by combining browser automation with external capabilities. The agent can intelligently decide when to use browser actions versus external tools.
</Info>

## Connection Options

There are two options for connecting to MCP servers:

1. **Pass a URL directly** - The simplest approach for quick setup
2. **Create a connection first** - Gives you more control over the connection

<Note>
  MCP client support is currently only available in TypeScript.
</Note>

## Passing a URL

The simplest way to add MCP integrations is by providing server URLs directly in the agent configuration:

```typescript  theme={null}
const agent = stagehand.agent({
  provider: "openai",
  model: "computer-use-preview",
  integrations: [
    `https://mcp.exa.ai/mcp?exaApiKey=${process.env.EXA_API_KEY}`,
  ],
  systemPrompt: `You have access to web search through Exa. Use it to find current information before browsing.`,
  options: {
    apiKey: process.env.OPENAI_API_KEY,
  },
});

await agent.execute("Search for the best headphones of 2025 and go through checkout for the top recommendation");
```

## Creating a Connection First

Alternatively, you can establish MCP connections first and then pass the client objects:

```typescript  theme={null}
import { connectToMCPServer } from "@browserbasehq/stagehand";

// Connect to MCP server
const supabaseClient = await connectToMCPServer(
  `https://server.smithery.ai/@supabase-community/supabase-mcp/mcp?api_key=${process.env.SMITHERY_API_KEY}`
);

// You can also pass the config to start a local MCP server
const notionClient = await connectToMCPServer({
  command: "npx",
  args: ["-y", "@notionhq/notion-mcp-server"],
  env: {
    NOTION_TOKEN: process.env.NOTION_TOKEN,
  },
});

// Use the connected client
const agent = stagehand.agent({
  provider: "openai", 
  model: "computer-use-preview",
  integrations: [supabaseClient, notionClient],
  systemPrompt: `You can interact with Supabase databases and Notion. Use these tools to store and retrieve data.`,
  options: {
    apiKey: process.env.OPENAI_API_KEY,
  },
});

await agent.execute("Search for restaurants in New Brunswick, NJ and save the first result to the database");
```

## Multiple Integrations

You can combine multiple MCP integrations in a single agent:

```typescript  theme={null}
const databaseClient = await connectToMCPServer(/* database config */);

const agent = stagehand.agent({
  integrations: [
    `https://search-service.example.com/mcp?apiKey=${process.env.SEARCH_API_KEY}`,
    databaseClient
  ],
  systemPrompt: `You have access to external tools for search and data storage. Use these tools strategically to complete tasks efficiently.`
});
```

## Best Practices

### Choose the Right Connection Approach

<Tabs>
  <Tab title="Passing a URL">
    **When to use:**

    * Simple setup requirements
    * Standard API configurations
    * Getting started quickly

    **Benefits:**

    * Minimal code required
    * Automatic connection handling
    * Easy to configure
  </Tab>

  <Tab title="Creating a Connection First">
    **When to use:**

    * Custom connection options
    * Connection reuse across agents
    * Advanced error handling

    **Benefits:**

    * Full control over connections
    * Better error handling
    * Connection pooling capabilities
  </Tab>
</Tabs>

### Environment Variables

Always use environment variables for API keys and sensitive information:

```bash  theme={null}
# .env file
SEARCH_API_KEY=your_search_service_key
MCP_SERVICE_API_KEY=your_mcp_service_key
OPENAI_API_KEY=your_openai_key
DATABASE_URL=your_database_url
DATABASE_API_KEY=your_database_key
```

### Instructions Best Practices

Provide clear instructions about available tools:

<Tabs>
  <Tab title="Good Instructions">
    ```typescript  theme={null}
    systemPrompt: `You have access to:
    1. Web search tools - Use to find current information
    2. Database tools - Use to store/retrieve data
    3. Browser automation - Use for web interactions

    Always search for current information before making decisions.
    Store important data for later reference.`
    ```
  </Tab>

  <Tab title="Poor Instructions">
    ```typescript  theme={null}
    systemPrompt: "You can search and save data."
    ```
  </Tab>
</Tabs>

### Error Handling

Implement proper error handling for MCP connections:

```typescript  theme={null}
try {
  const client = await connectToMCPServer(serverUrl);
  
  const agent = stagehand.agent({
    integrations: [client],
    // ... other config
  });
  
  const result = await agent.execute(instruction);
} catch (error) {
  console.error("MCP integration failed:", error);
  // Handle fallback behavior
}
```

## Troubleshooting

<AccordionGroup>
  <Accordion title="Connection timeouts">
    **Problem:** MCP server connections timing out

    **Solutions:**

    * Verify server URLs are correct and accessible
    * Check network connectivity
    * Ensure API keys are valid and have proper permissions
    * Try connecting to servers individually to isolate issues
  </Accordion>

  <Accordion title="Tool not being used">
    **Problem:** Agent not using available MCP tools

    **Solutions:**

    * Make instructions more specific about when to use tools
    * Ensure API keys are properly configured
    * Check that the MCP server supports the expected tools
    * Verify tool descriptions are clear and actionable
  </Accordion>

  <Accordion title="Authentication errors">
    **Problem:** API key or authentication failures

    **Solutions:**

    * Verify all required environment variables are set
    * Check API key validity and permissions
    * Ensure URLs include necessary authentication parameters
    * Test MCP connections independently before using in agents
  </Accordion>
</AccordionGroup>

## Examples

### Web Search + Browser Automation

```typescript  theme={null}
const agent = stagehand.agent({
  integrations: [`https://mcp.exa.ai/mcp?exaApiKey=${process.env.EXA_API_KEY}`],
  systemPrompt: `First search for current information, then use the browser to complete tasks based on what you find.`
});

await agent.execute("Find the best laptop deals for 2025 and navigate to purchase the top recommendation");
```

### Data Extraction + Storage

```typescript  theme={null}
const supabaseClient = await connectToMCPServer(/* config */);

const agent = stagehand.agent({
  integrations: [supabaseClient],
  systemPrompt: `Extract data from websites and store it using available database tools.`
});

await agent.execute("Extract all restaurant information from this directory and save it to the database");
```

### Multi-tool Workflow

```typescript  theme={null}
const agent = stagehand.agent({
  integrations: [
    `https://mcp.exa.ai/mcp?exaApiKey=${process.env.EXA_API_KEY}`,
    supabaseClient
  ],
  systemPrompt: `Use all available tools strategically: search for current info, browse websites, and store important data.`
});

await agent.execute("Research competitor pricing, compare with our site, and store the analysis");
```

## Further Reading

<CardGroup cols={3}>
  <Card title="Agent Basics" icon="robot" href="/basics/agent">
    Learn the fundamentals of Stagehand agents
  </Card>

  <Card title="MCP Server Setup" icon="server" href="/integrations/mcp/setup">
    Set up your own MCP server
  </Card>

  <Card title="Custom Tools" icon="wrench" href="/integrations/mcp/tools">
    Create custom MCP tools
  </Card>
</CardGroup>
# Speed Optimization

> Optimize Stagehand performance for faster automation and reduced latency

Stagehand performance depends on several factors: DOM processing speed, LLM inference time, browser operations, and network latency. This guide provides proven strategies to maximize automation speed.

## Quick Performance Wins

### 1. Plan Ahead with Observe

Use a single `observe()` call to plan multiple actions, then execute them efficiently:

```typescript  theme={null}
// Instead of sequential operations with multiple LLM calls
await stagehand.act("Fill name field");        // LLM call #1
await stagehand.act("Fill email field");       // LLM call #2
await stagehand.act("Select country dropdown"); // LLM call #3

// Use single observe to plan all form fields - one LLM call
const formFields = await stagehand.observe("Find all form fields to fill");

// Execute all actions without LLM inference
for (const field of formFields) {
  await stagehand.act(field); // No LLM calls!
}
```

<Note>
  **Performance Tip**: Acting on `observe` results avoids LLM inference entirely. This approach is 2-3x faster than direct `act()` calls and is the recommended pattern for multi-step workflows.
</Note>

<Card title="Caching Guide" icon="database" href="/best-practices/caching">
  Learn advanced caching patterns and cache invalidation strategies
</Card>

### 2. Optimize DOM Processing

Reduce DOM complexity before Stagehand processes the page:

```typescript  theme={null}
// Remove heavy elements that slow down processing
await page.evaluate(() => {
  // Remove video elements
  document.querySelectorAll('video, iframe').forEach(el => el.remove());
  
  // Hide complex animations
  document.querySelectorAll('[style*="animation"]').forEach(el => {
    (el as HTMLElement).style.animation = 'none';
  });
});

// Then perform Stagehand operations
await stagehand.act("Click the submit button");
```

### 3. Set Appropriate Timeouts

Use shorter timeouts for simple operations and longer ones for complex page loads:

```typescript  theme={null}
// Simple actions - reduce action timeout
await stagehand.act("Click the login button", {
  timeout: 5000  // Default is 30000ms, reduce for simple clicks
});

// Complex page loads - optimize navigation
const page = stagehand.context.pages()[0];
await page.goto("https://heavy-spa.com", {
  waitUntil: "domcontentloaded", // Don't wait for all resources
  timeout: 15000 // Shorter than default 30s
});
```

## Performance Monitoring and Benchmarking

Track performance metrics and measure optimization impact:

### Performance Tracking

```typescript  theme={null}
class PerformanceTracker {
  private speedMetrics: Map<string, number[]> = new Map();

  async timedAct(page: Page, prompt: string): Promise<ActResult> {
    const start = Date.now();
    const result = await stagehand.act(prompt);
    const duration = Date.now() - start;
    
    if (!this.speedMetrics.has(prompt)) {
      this.speedMetrics.set(prompt, []);
    }
    this.speedMetrics.get(prompt)!.push(duration);
    
    console.log(`Action "${prompt}" took ${duration}ms`);
    return result;
  }

  getAverageTime(prompt: string): number {
    const times = this.speedMetrics.get(prompt) || [];
    return times.reduce((a, b) => a + b, 0) / times.length;
  }
}
```

Example Output:

```
Action "Fill form" took 1000ms
Action "Click submit" took 2000ms
Action "Confirm submission" took 5000ms
```

### Before vs After Benchmarking

```typescript  theme={null}
// Before optimization
console.time("workflow");
await stagehand.act("Fill form");
await stagehand.act("Click submit");
await stagehand.act("Confirm submission");
console.timeEnd("workflow"); // 8000ms

// After optimization with observe planning
console.time("workflow-optimized");
const workflowActions = await stagehand.observe("Find form, submit, and confirm elements");

// Execute actions sequentially to avoid conflicts
for (const action of workflowActions) {
  await stagehand.act(action);
}
console.timeEnd("workflow-optimized"); // 500ms
```

Example Output:

```
Workflow took 8000ms
Optimized workflow took 500ms
```

<CardGroup cols={1}>
  <Card title="Observability & Metrics" icon="chart-line" href="/configuration/observability">
    Set up comprehensive performance monitoring
  </Card>
</CardGroup>

## Related Resources

<CardGroup cols={2}>
  <Card title="Caching Strategies" icon="database" href="/best-practices/caching">
    Advanced caching patterns for maximum performance
  </Card>

  <Card title="Cost Optimization" icon="dollar-sign" href="/best-practices/cost-optimization">
    Balance speed improvements with cost considerations
  </Card>

  <Card title="Browser Configuration" icon="window-maximize" href="/configuration/browser">
    Optimize Browserbase settings for speed
  </Card>

  <Card title="Model Selection" icon="brain" href="/configuration/models">
    Choose the right model for speed vs accuracy
  </Card>
</CardGroup>
# Browserbase MCP Server

> AI-powered browser automation through Model Context Protocol integration with Stagehand

## Overview

The Browserbase MCP Server brings powerful browser automation capabilities to Claude through the Model Context Protocol (MCP). Built on top of [Stagehand](https://docs.stagehand.dev/), this integration provides AI-powered web automation using natural language commands.

<Info>
  This server enables Claude to control browsers, navigate websites, interact with web elements, and extract data—all through simple conversational commands.
</Info>

## Key Features

<CardGroup cols={2}>
  <Card title="Natural Language Automation" icon="wand-magic-sparkles">
    Control browsers using plain English commands like "click the login button" or "fill out the contact form"
  </Card>

  <Card title="Web Interaction" icon="browser">
    Navigate, click, and fill forms with ease
  </Card>

  <Card title="Data Extraction" icon="download">
    Extract structured data from any website automatically
  </Card>

  <Card title="Screenshot Capture" icon="camera">
    Capture and analyze webpage screenshots programmatically
  </Card>
</CardGroup>

## Core Benefits

<Tabs>
  <Tab title="Ease of Use">
    <CardGroup cols={2}>
      <Card title="Intuitive Commands" icon="wand-magic-sparkles">
        No need to learn complex selectors or automation syntax. Simply describe what you want to do in natural language.
      </Card>

      <Card title="Quick Setup" icon="rocket">
        Get started in minutes with our NPM package or our remote hosted URL.
      </Card>

      <Card title="Smart Automation" icon="brain">
        Stagehand's AI understands web page context and can adapt to different layouts and designs.
      </Card>
    </CardGroup>
  </Tab>

  <Tab title="Powerful Capabilities">
    <CardGroup cols={2}>
      <Card title="Full Browser Control" icon="browser">
        Navigate, click, type, scroll, and interact with any web element.
      </Card>

      <Card title="Data Intelligence" icon="chart-line">
        Extract structured information from complex web pages automatically.
      </Card>

      <Card title="Session Persistence" icon="cookie-bite">
        Maintain authentication states and context across multiple interactions.
      </Card>
    </CardGroup>
  </Tab>

  <Tab title="Enterprise Ready">
    <CardGroup cols={2}>
      <Card title="Reliable Infrastructure" icon="server">
        Built on Browserbase's cloud browser platform for consistent performance.
      </Card>

      <Card title="Scalable Architecture" icon="arrows-up-to-line">
        Handle multiple concurrent sessions and high-volume automation tasks.
      </Card>

      <Card title="Security Features" icon="shield-check">
        Stealth mode, proxy support, and advanced anti-detection capabilities.
      </Card>

      <Card title="Comprehensive Logging" icon="file-lines">
        Detailed session recordings and debugging information.
      </Card>
    </CardGroup>
  </Tab>
</Tabs>

## Use Cases

<Tabs>
  <Tab title="Web Scraping & Data Collection">
    <CardGroup cols={2}>
      <Card title="E-commerce Monitoring" icon="store">
        Track product prices, availability, and competitor information
      </Card>

      <Card title="Market Research" icon="chart-bar">
        Gather data from multiple sources for analysis and reporting
      </Card>

      <Card title="Content Aggregation" icon="newspaper">
        Collect articles, posts, and media from various websites
      </Card>

      <Card title="Lead Generation" icon="users">
        Extract contact information and business data from directories
      </Card>
    </CardGroup>
  </Tab>

  <Tab title="Testing">
    <CardGroup cols={2}>
      <Card title="Automated Testing" icon="flask">
        Create comprehensive test suites for web applications
      </Card>

      <Card title="User Journey Testing" icon="route">
        Simulate real user interactions and workflows
      </Card>

      <Card title="Performance Monitoring" icon="gauge">
        Track page load times and user experience metrics
      </Card>
    </CardGroup>
  </Tab>

  <Tab title="Workflow Automation">
    <CardGroup cols={2}>
      <Card title="Form Automation" icon="file-contract">
        Automatically fill and submit complex web forms
      </Card>

      <Card title="Report Generation" icon="chart-line">
        Extract data and generate automated reports
      </Card>

      <Card title="Social Media Management" icon="share-nodes">
        Schedule posts and monitor engagement across platforms
      </Card>

      <Card title="Administrative Tasks" icon="clipboard-check">
        Automate repetitive web-based business processes
      </Card>
    </CardGroup>
  </Tab>
</Tabs>

## Getting Started

<Steps>
  <Step title="Install the MCP Server">
    Choose from NPM installation, remote hosted URL, or local development based on your needs.
  </Step>

  <Step title="Configure Authentication">
    Set up your Browserbase API credentials in the MCP configuration.
    Get your API keys from the [Browserbase Dashboard](https://www.browserbase.com/overview).
  </Step>

  <Step title="Start Automating">
    Begin using natural language commands to control browsers through Claude.
  </Step>
</Steps>

<Tip>
  Ready to get started? Check out our [Setup Guide](/integrations/mcp/setup) for detailed installation instructions.
</Tip>

## Further Reading

<CardGroup cols={3}>
  <Card title="Setup Guide" icon="rocket" href="/integrations/mcp/setup">
    Get started with installation and configuration
  </Card>

  <Card title="Available Tools" icon="wrench" href="/integrations/mcp/tools">
    Explore all available automation tools
  </Card>

  <Card title="Configuration Options" icon="gear" href="/integrations/mcp/configuration">
    Customize your browser automation setup
  </Card>
</CardGroup>
# Browserbase MCP Server Setup

> Add the Browserbase MCP Server to Claude

## Quick Installation

<Card title="Install with Cursor" icon="arrow-pointer" href="cursor://anysphere.cursor-deeplink/mcp/install?name=browserbase&config=eyJjb21tYW5kIjoibnB4IEBicm93c2VyYmFzZWhxL21jcCIsImVudiI6eyJCUk9XU0VSQkFTRV9BUElfS0VZIjoiIiwiQlJPV1NFUkJBU0VfUFJPSkVDVF9JRCI6IiIsIkdFTUlOSV9BUElfS0VZIjoiIn19">
  One-click installation directly in Cursor with pre-configured settings
</Card>

We support multiple transport methods for our MCP server: STDIO and SHTTP. We recommend using SHTTP with our remote hosted URL to take advantage of the server at full capacity.

## Prerequisites

<Steps>
  <Step title="Get your Browserbase credentials">
    Get your Browserbase API key and project ID from the [Browserbase Dashboard](https://www.browserbase.com/overview).

    <Frame>
      <img src="https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/quickstart/api-key.png?fit=max&auto=format&n=W3kYIUy5sYF-nkqt&q=85&s=4fa3142cd69586f9602b42ff5d9d4cfe" alt="Browserbase API Key and Project ID settings" data-og-width="2926" width="2926" data-og-height="1492" height="1492" data-path="images/quickstart/api-key.png" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/quickstart/api-key.png?w=280&fit=max&auto=format&n=W3kYIUy5sYF-nkqt&q=85&s=f83a68a82134fbc7d601269d5f52e831 280w, https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/quickstart/api-key.png?w=560&fit=max&auto=format&n=W3kYIUy5sYF-nkqt&q=85&s=fb5f8234922e0ef2317cbcdddaee08c0 560w, https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/quickstart/api-key.png?w=840&fit=max&auto=format&n=W3kYIUy5sYF-nkqt&q=85&s=e04de91a96963148d29d0c20cd0dca7e 840w, https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/quickstart/api-key.png?w=1100&fit=max&auto=format&n=W3kYIUy5sYF-nkqt&q=85&s=2bc84d066c5e7c869a06e77212c1419f 1100w, https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/quickstart/api-key.png?w=1650&fit=max&auto=format&n=W3kYIUy5sYF-nkqt&q=85&s=3b6367df8efff19ce63e7a61ba8e871c 1650w, https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/quickstart/api-key.png?w=2500&fit=max&auto=format&n=W3kYIUy5sYF-nkqt&q=85&s=09cfd9141d2fee97dbd489128c24a5b2 2500w" />
    </Frame>

    Then copy your API Key and Project ID directly from the input.
  </Step>
</Steps>

## Installation Methods

<Tabs>
  <Tab title="Remote URL (SHTTP)">
    Go to [smithery.ai](https://smithery.ai/server/@browserbasehq/mcp-browserbase) and enter your API keys and configuration to get a remote hosted URL.

        <img src="https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/mcp/smithery.jpg?fit=max&auto=format&n=W3kYIUy5sYF-nkqt&q=85&s=706c0ebed12b7789443ef7ca36927af7" alt="Smithery" data-og-width="1920" width="1920" data-og-height="1129" height="1129" data-path="images/mcp/smithery.jpg" data-optimize="true" data-opv="3" srcset="https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/mcp/smithery.jpg?w=280&fit=max&auto=format&n=W3kYIUy5sYF-nkqt&q=85&s=995e20b01b0ff5124ed33b5f335be306 280w, https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/mcp/smithery.jpg?w=560&fit=max&auto=format&n=W3kYIUy5sYF-nkqt&q=85&s=d909906ff78eb6c1eb7e3ee44b1433f0 560w, https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/mcp/smithery.jpg?w=840&fit=max&auto=format&n=W3kYIUy5sYF-nkqt&q=85&s=de8f0dcd161a4a502daa07ac1e422b67 840w, https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/mcp/smithery.jpg?w=1100&fit=max&auto=format&n=W3kYIUy5sYF-nkqt&q=85&s=6ac5a086bccf259834cc7ef30839f104 1100w, https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/mcp/smithery.jpg?w=1650&fit=max&auto=format&n=W3kYIUy5sYF-nkqt&q=85&s=2b8754889ca651d35a87d63aca19f4d7 1650w, https://mintcdn.com/stagehand/W3kYIUy5sYF-nkqt/images/mcp/smithery.jpg?w=2500&fit=max&auto=format&n=W3kYIUy5sYF-nkqt&q=85&s=e5c3e8e5464ee16c9d991d47836ab7b6 2500w" />

    <CodeGroup>
      ```json Smithery theme={null}
      {
        "mcpServers": {
          "browserbase": {
            "url": "your-smithery-url.com"
          }
        }
      }
      ```
    </CodeGroup>

    When using our remote hosted server, we provide the LLM costs for Gemini, the [best performing model](https://www.stagehand.dev/evals) in [Stagehand](https://www.stagehand.dev).
  </Tab>

  <Tab title="NPM Package (STDIO)">
    The easiest way to get started locally is using our NPM package.

    <Note>
      If you would like to use a different model, you have to pass the model name and keys in the args. More info [here](https://docs.browserbase.com/integrations/mcp/configuration).
    </Note>

    <Steps>
      <Step title="Add to MCP Config">
        Go into your MCP Config JSON and add the Browserbase Server:

        <CodeGroup>
          ```json Claude Desktop theme={null}
          {
            "mcpServers": {
              "browserbase": {
                "command": "npx",
                "args": ["@browserbasehq/mcp-server-browserbase"],
                "env": {
                  "BROWSERBASE_API_KEY": "your_api_key",
                  "BROWSERBASE_PROJECT_ID": "your_project_id",
                  "GEMINI_API_KEY": "your_gemini_api_key"
                }
              }
            }
          }
          ```
        </CodeGroup>
      </Step>

      <Step title="Restart your MCP client">
        <Check>
          That's it! Reload your MCP client and Claude will be able to use Browserbase.
        </Check>
      </Step>
    </Steps>
  </Tab>

  <Tab title="Local Development">
    For local development or customization, you can run the server locally.

    <Steps>
      <Step title="Clone and build">
        ```bash  theme={null}
        # Clone the Repo
        git clone https://github.com/browserbase/mcp-server-browserbase.git
        cd mcp-server-browserbase

        # Install the dependencies and build the project
        npm install && npm run build
        ```
      </Step>

      <Step title="Choose your transport method">
        You can run locally using either STDIO or Streamable HTTP (SHTTP).

        <Tabs>
          <Tab title="STDIO">
            Add the following to your MCP Config JSON file:

            ```json  theme={null}
            {
              "mcpServers": {
                "browserbase": {
                  "command": "node",
                  "args": ["/path/to/mcp-server-browserbase/cli.js"],
                  "env": {
                    "BROWSERBASE_API_KEY": "your_api_key",
                    "BROWSERBASE_PROJECT_ID": "your_project_id",
                    "GEMINI_API_KEY": "your_gemini_api_key"
                  }
                }
              }
            }
            ```
          </Tab>

          <Tab title="SHTTP (Self-hosted)">
            First, run the server:

            ```bash  theme={null}
            node cli.js --port 8931
            ```

            Then add this to your MCP Config JSON file:

            ```json  theme={null}
            {
              "mcpServers": {
                "browserbase": {
                  "url": "http://localhost:8931/mcp",
                  "env": {
                    "BROWSERBASE_API_KEY": "your_api_key",
                    "BROWSERBASE_PROJECT_ID": "your_project_id",
                    "GEMINI_API_KEY": "your_gemini_api_key"
                  }
                }
              }
            }
            ```
          </Tab>
        </Tabs>
      </Step>

      <Step title="Restart your client">
        <Check>
          Reload your MCP client and you should be good to go!
        </Check>
      </Step>
    </Steps>
  </Tab>
</Tabs>

## Verify Installation

<Steps>
  <Step title="Restart your Claude Client">
    Restart/refresh your Claude Client app and you should see the tools available by clicking the 🔨 icon.
  </Step>

  <Step title="Test the integration">
    Get started using our MCP Server by asking Claude to navigate to any page and see your Browserbase Browser in action on the [dashboard](https://www.browserbase.com/sessions).

    <Tip>
      Try asking Claude: "Navigate to google.com and take a screenshot"
    </Tip>
  </Step>
</Steps>

## Further Reading

<CardGroup cols={3}>
  <Card title="Model Context Protocol (MCP) Docs" icon="book" href="https://modelcontextprotocol.io/introduction">
    Learn more about the MCP protocol
  </Card>

  <Card title="Browserbase Documentation" icon="globe" href="https://docs.browserbase.com">
    Explore Browserbase features and capabilities
  </Card>

  <Card title="Support" icon="headset" href="mailto:support@browserbase.com">
    Get help from our support team
  </Card>
</CardGroup>
# Browserbase MCP Server Tools

> This guide covers the specialized tools available in the Browserbase MCP server for browser automation and interaction.

## Overview

The Browserbase MCP server provides comprehensive tools for browser automation and session management. These tools allow you to perform actions like navigating pages, capturing screenshots, manipulating cookies, and managing multiple browser sessions simultaneously.

## Core Browser Automation Tools

These are the primary tools for modern web automation using natural language commands.

<Accordion title="browserbase_stagehand_navigate">
  Navigate to any URL in the browser

  <ParamField path="url" type="string" required>
    The URL to navigate to
  </ParamField>
</Accordion>

<Accordion title="browserbase_stagehand_act">
  Perform an action on the web page using natural language

  <ParamField path="action" type="string" required>
    The action to perform (e.g., "click the login button", "fill form field")
  </ParamField>
</Accordion>

<Accordion title="browserbase_stagehand_extract">
  Extract all text content from the current page (filters out CSS and JavaScript)

  <Info>No input parameters required</Info>

  <ParamField path="instruction" type="string">
    Extracted text content from the current page
  </ParamField>
</Accordion>

<Accordion title="browserbase_stagehand_observe">
  Observe and find actionable elements on the web page

  <ParamField path="instruction" type="string" required>
    Specific instruction for observation (e.g., "find the login button", "locate search form")
  </ParamField>
</Accordion>

<Accordion title="browserbase_screenshot">
  Capture a PNG screenshot of the current page

  <Info>No input parameters required</Info>

  <ResponseField name="image" type="string">
    Base-64 encoded PNG data
  </ResponseField>
</Accordion>

<Accordion title="browserbase_stagehand_get_url">
  Get the current URL of the browser page

  <Info>No input parameters required</Info>

  <ResponseField name="url" type="string">
    Complete URL including protocol, domain, path, and any query parameters or fragments
  </ResponseField>
</Accordion>

## Session Management

Manage your browser session lifecycle with create and close operations.

<Accordion title="browserbase_session_create">
  Create or reuse a cloud browser session using Browserbase with fully initialized Stagehand

  <ParamField path="sessionId" type="string">
    Optional session ID to use/reuse. If not provided, creates new session
  </ParamField>
</Accordion>

<Accordion title="browserbase_session_close">
  Close the current Browserbase session, disconnect the browser, and cleanup Stagehand instance

  <Info>No input parameters required</Info>
</Accordion>

## Resources

<Card title="Screenshot Resources" icon="camera">
  The server provides access to screenshot resources with URI-based access.

  example:

  ```
  screenshot://screenshot-name-of-the-screenshot
  ```
</Card>

## Further Reading

<CardGroup cols={3}>
  <Card title="Model Context Protocol (MCP) Docs" icon="book" href="https://modelcontextprotocol.io/introduction">
    Learn more about the MCP protocol
  </Card>

  <Card title="Stagehand Documentation" icon="robot" href="https://docs.stagehand.dev/">
    Explore Stagehand's AI-powered browser automation
  </Card>

  <Card title="Support" icon="headset" href="mailto:support@browserbase.com">
    Get help from our support team
  </Card>
</CardGroup>
# Browserbase MCP Server Configuration

> Configure your browser automation with command-line flags, environment variables, and advanced options

## Configuration Overview

The Browserbase MCP server supports extensive configuration options through command-line flags and environment variables. Configure browser behavior, proxy settings, stealth modes, model selection, and more to customize your browser automation workflows.

<Note>
  Command-line flags are only available when running the server locally (`npx @browserbasehq/mcp-server-browserbase` with flags or local development setup).
</Note>

## Environment Variables

Configure the essential Browserbase credentials and optional debugging settings:

<CardGroup cols={2}>
  <Card title="BROWSERBASE_API_KEY" icon="key">
    Your Browserbase API key for authentication
  </Card>

  <Card title="BROWSERBASE_PROJECT_ID" icon="key">
    Your Browserbase project ID
  </Card>
</CardGroup>

## Command-Line Flags

### Available Flags

| Flag                       | Description                                                                 |
| -------------------------- | --------------------------------------------------------------------------- |
| `--proxies`                | Enable Browserbase proxies for the session                                  |
| `--advancedStealth`        | Enable Browserbase Advanced Stealth (Scale Plan only)                       |
| `--keepAlive`              | Enable Browserbase Keep Alive Session                                       |
| `--contextId <contextId>`  | Specify a Browserbase Context ID to use                                     |
| `--persist [boolean]`      | Whether to persist the Browserbase context (default: true)                  |
| `--port <port>`            | Port to listen on for HTTP/SHTTP transport                                  |
| `--host <host>`            | Host to bind server to (default: localhost, use 0.0.0.0 for all interfaces) |
| `--browserWidth <width>`   | Browser viewport width (default: 1024)                                      |
| `--browserHeight <height>` | Browser viewport height (default: 768)                                      |
| `--modelName <model>`      | The model to use for Stagehand (default: gemini-2.0-flash)                  |
| `--modelApiKey <key>`      | API key for the custom model provider (required when using custom models)   |
| `--experimental`           | Enable experimental features (default: false)                               |

## Configuration Examples

### Basic Configuration

<Tabs>
  <Tab title="Remote URL (SHTTP)">
    <CodeGroup>
      ```json Direct SHTTP theme={null}
      {
        "mcpServers": {
          "browserbase": {
            "url": "your-smithery-url.com"
          }
        }
      }
      ```
    </CodeGroup>

    When using our remote hosted server, we provide the LLM costs for Gemini, the [best performing model](https://www.stagehand.dev/evals) in [Stagehand](https://www.stagehand.dev).
  </Tab>

  <Tab title="NPM Package">
    ```json  theme={null}
    {
      "mcpServers": {
        "browserbase": {
          "command": "npx",
          "args": ["@browserbasehq/mcp-server-browserbase"],
          "env": {
            "BROWSERBASE_API_KEY": "your_api_key",
            "BROWSERBASE_PROJECT_ID": "your_project_id",
            "GEMINI_API_KEY": "your_gemini_api_key"
          }
        }
      }
    }
    ```
  </Tab>

  <Tab title="Local STDIO">
    ```json  theme={null}
    {
      "mcpServers": {
        "browserbase": {
          "command": "node",
          "args": ["/path/to/mcp-server-browserbase/cli.js"],
          "env": {
            "BROWSERBASE_API_KEY": "your_api_key",
            "BROWSERBASE_PROJECT_ID": "your_project_id",
            "GEMINI_API_KEY": "your_gemini_api_key"
          }
        }
      }
    }
    ```
  </Tab>

  <Tab title="Local SHTTP">
    ```bash  theme={null}
    # Start server
    node cli.js --port 8931
    ```

    ```json  theme={null}
    {
      "mcpServers": {
        "browserbase": {
          "url": "http://localhost:8931/mcp",
          "env": {
            "BROWSERBASE_API_KEY": "your_api_key",
            "BROWSERBASE_PROJECT_ID": "your_project_id",
            "GEMINI_API_KEY": "your_gemini_api_key"
          }
        }
      }
    }
    ```
  </Tab>
</Tabs>

### Advanced Features

<Tabs>
  <Tab title="Proxies">
    Enable Browserbase proxies for IP rotation and geo-location testing.

    <Panel>
      [Learn more about Browserbase Proxies](https://docs.browserbase.com/features/proxies)
    </Panel>

    ```json  theme={null}
    {
      "mcpServers": {
        "browserbase": {
          "command": "npx",
          "args": ["@browserbasehq/mcp-server-browserbase", "--proxies"],
          "env": {
            "BROWSERBASE_API_KEY": "your_api_key",
            "BROWSERBASE_PROJECT_ID": "your_project_id",
            "GEMINI_API_KEY": "your_gemini_api_key"
          }
        }
      }
    }
    ```
  </Tab>

  <Tab title="Advanced Stealth">
    Enable advanced anti-detection features for enhanced stealth browsing.

    <Panel>
      [Learn more about Advanced Stealth](https://docs.browserbase.com/features/stealth-mode#advanced-stealth-mode)

      **Note:** Advanced Stealth is only available for Scale Plan users.
    </Panel>

    ```json  theme={null}
    {
      "mcpServers": {
        "browserbase": {
          "command": "npx",
          "args": ["@browserbasehq/mcp-server-browserbase", "--advancedStealth"],
          "env": {
            "BROWSERBASE_API_KEY": "your_api_key",
            "BROWSERBASE_PROJECT_ID": "your_project_id",
            "GEMINI_API_KEY": "your_gemini_api_key"
          }
        }
      }
    }
    ```
  </Tab>

  <Tab title="Contexts">
    Use persistent browser contexts to maintain authentication and state across sessions.

    <Panel>
      [Learn more about Browserbase Contexts](https://docs.browserbase.com/features/contexts)
    </Panel>

    ```json  theme={null}
    {
      "mcpServers": {
        "browserbase": {
          "command": "npx",
          "args": ["@browserbasehq/mcp-server-browserbase", "--contextId", "your_context_id"],
          "env": {
            "BROWSERBASE_API_KEY": "your_api_key",
            "BROWSERBASE_PROJECT_ID": "your_project_id"
          }
        }
      }
    }
    ```
  </Tab>
</Tabs>

### Browser Customization

<Tabs>
  <Tab title="Viewport Sizing">
    Customize browser window dimensions. Default is 1024x768. Recommended aspect ratios: 16:9.

    ```json  theme={null}
    {
      "mcpServers": {
        "browserbase": {
          "command": "npx",
          "args": [
            "@browserbasehq/mcp-server-browserbase",
            "--browserWidth", "1920",
            "--browserHeight", "1080"
          ],
          "env": {
            "BROWSERBASE_API_KEY": "your_api_key",
            "BROWSERBASE_PROJECT_ID": "your_project_id",
            "GEMINI_API_KEY": "your_gemini_api_key"
          }
        }
      }
    }
    ```

    **Common Resolutions:**

    * Desktop: 1920x1080, 1280x720, 1024x768
    * Mobile: 375x667 (iPhone), 360x640 (Android)
    * Tablet: 768x1024 (iPad)
  </Tab>
</Tabs>

## Model Configuration

Configure AI models for enhanced browser automation. Stagehand defaults to Google's Gemini 2.0 Flash but supports multiple providers.

<Warning>
  When using any custom model (non-default), you must provide your own API key for that model provider using the `--modelApiKey` flag.
</Warning>

<Tabs>
  <Tab title="Available Models">
    **Google Gemini** (Default)

    * `gemini-2.0-flash` (default)
    * `gemini-2.5-pro`
    * `gemini-2.5-flash`
    * `gemini-2.5-flash-lite`

    **OpenAI**

    * `gpt-5-2025-08-07`
    * `gpt-4.1-2025-04-14`
    * `gpt-4o`
    * `gpt-4o-mini`

    **Anthropic Claude**

    * `claude-sonnet-4-5`
    * `claude-haiku-4-5`

    [View full list of supported models](https://docs.stagehand.dev/v3/configuration/models#models)
  </Tab>

  <Tab title="Configuration Examples">
    <CodeGroup>
      ```json OpenAI GPT-4o theme={null}
      {
        "mcpServers": {
          "browserbase": {
            "command": "npx",
            "args": [
              "@browserbasehq/mcp-server-browserbase",
              "--modelName", "gpt-4o",
              "--modelApiKey", "your_openai_api_key"
            ],
            "env": {
              "BROWSERBASE_API_KEY": "your_api_key",
              "BROWSERBASE_PROJECT_ID": "your_project_id"
            }
          }
        }
      }
      ```

      ```json Claude Sonnet theme={null}
      {
        "mcpServers": {
          "browserbase": {
            "command": "npx",
            "args": [
              "@browserbasehq/mcp-server-browserbase",
              "--modelName", "claude-3-5-sonnet-latest",
              "--modelApiKey", "your_anthropic_api_key"
            ],
            "env": {
              "BROWSERBASE_API_KEY": "your_api_key",
              "BROWSERBASE_PROJECT_ID": "your_project_id"
            }
          }
        }
      }
      ```
    </CodeGroup>
  </Tab>
</Tabs>

## Development Configuration

<Tabs>
  <Tab title="Custom Host/Port">
    Configure custom host and port for SHTTP transport.

    ```json  theme={null}
    {
      "mcpServers": {
        "browserbase": {
          "command": "npx",
          "args": [
            "@browserbasehq/mcp-server-browserbase",
            "--host", "0.0.0.0",
            "--port", "8080"
          ],
          "env": {
            "BROWSERBASE_API_KEY": "your_api_key",
            "BROWSERBASE_PROJECT_ID": "your_project_id",
            "GEMINI_API_KEY": "your_gemini_api_key"
          }
        }
      }
    }
    ```
  </Tab>
</Tabs>

## Best Practices

<Accordion title="Performance - How can I optimize browser automation performance?">
  * Use appropriate viewport sizes for your use case
  * Enable proxies only when needed for geo-location
  * Choose efficient models (Gemini Flash for speed, GPT-4o for accuracy)
  * Reuse contexts for authentication persistence
</Accordion>

<Accordion title="Security - What security measures should I implement?">
  * Store API keys securely in environment variables
  * Use Advanced Stealth for sensitive operations
  * Implement proper session management
  * Rotate cookies and contexts regularly
</Accordion>

<Accordion title="Development - What are the recommended development practices?">
  * Enable debug mode during development
  * Use context persistence for faster iteration
  * Test with different viewport sizes
  * Monitor session usage and quotas
</Accordion>

<Accordion title="Production - How should I configure for production environments?">
  * Use NPM installation for reliability
  * Configure appropriate timeouts
  * Implement error handling and retries
  * Monitor performance and resource usage
</Accordion>

## Further Reading

<CardGroup cols={3}>
  <Card title="Browserbase Documentation" icon="globe" href="https://docs.browserbase.com">
    Complete platform documentation
  </Card>

  <Card title="Stagehand Docs" icon="robot" href="https://docs.stagehand.dev/">
    AI-powered browser automation
  </Card>

  <Card title="Support" icon="headset" href="mailto:support@browserbase.com">
    Get help from our team
  </Card>
</CardGroup>
# CrewAI Introduction

> Automate browser tasks using natural language instructions with CrewAI

## Overview

This guide shows you how to use CrewAI with Browserbase to create intelligent agents that can automate web interactions. By the end of this guide, you'll know how to:

* Set up CrewAI with the StagehandTool
* Create agents that can interact with websites
* Automate browser tasks using natural language instructions
* Extract structured data from web pages

## When You'd Use This

The CrewAI integration is perfect for scenarios where you need intelligent web automation:

* **Research automation**: Have agents research information across multiple websites
* **Data collection**: Extract structured data from e-commerce sites, job boards, or news sites
* **Form automation**: Automatically fill out and submit forms based on specific criteria
* **Multi-step workflows**: Execute complex browser workflows that require decision-making

The StagehandTool wraps the Stagehand Python SDK to provide CrewAI agents with the ability to control a real web browser and interact with websites using three core primitives:

1. **Act**: Perform actions like clicking, typing, or navigating
2. **Extract**: Extract structured data from web pages
3. **Observe**: Identify and analyze elements on the page

<CardGroup cols={1}>
  <Card title="CrewAI Configuration" icon="gear" href="/v3/integrations/crew-ai/configuration">
    Learn how to configure and use the StagehandTool with CrewAI agents for web automation tasks
  </Card>
</CardGroup>
# Use CrewAI to Automate Browser Tasks

> Create intelligent agents that can interact with websites and automate browser tasks using natural language instructions

This guide walks you through setting up CrewAI with Browserbase to create agents that can perform web automation tasks using natural language instructions.

## Step 1: Install Dependencies

Install the required packages for CrewAI and Stagehand integration:

```bash  theme={null}
pip install stagehand crewai crewai-tools
```

## Step 2: Configure Environment Variables

You'll need API keys from three services:

1. **Browserbase API Key and Project ID**: Get these from your [Browserbase dashboard](https://www.browserbase.com/)
2. **LLM API Key**: Get an API key from [OpenAI](https://platform.openai.com/api-keys) or [Anthropic](https://console.anthropic.com/)

Store your API keys securely as environment variables:

```bash  theme={null}
BROWSERBASE_API_KEY="your-browserbase-api-key"
BROWSERBASE_PROJECT_ID="your-browserbase-project-id"
OPENAI_API_KEY="your-openai-api-key"
ANTHROPIC_API_KEY="your-anthropic-api-key"
```

## Step 3: Create Your First Agent

Create a Python script with a basic CrewAI agent:

```python  theme={null}
import os
from crewai import Agent, Task, Crew
from crewai_tools import StagehandTool
from stagehand.schemas import AvailableModel

# Get API keys from environment
browserbase_api_key = os.environ.get("BROWSERBASE_API_KEY")
browserbase_project_id = os.environ.get("BROWSERBASE_PROJECT_ID")
model_api_key = os.environ.get("OPENAI_API_KEY")  # or ANTHROPIC_API_KEY

# Initialize the StagehandTool
stagehand_tool = StagehandTool(
    api_key=browserbase_api_key,
    project_id=browserbase_project_id,
    model_api_key=model_api_key,
    model_name=AvailableModel.GPT_4O,  # or AvailableModel.CLAUDE_3_7_SONNET_LATEST
)

# Create an agent with the tool
researcher = Agent(
    role="Web Researcher",
    goal="Find and summarize information from websites",
    backstory="I'm an expert at finding information online.",
    verbose=True,
    tools=[stagehand_tool],
)
```

## Step 4: Create and Run a Task

Define a task for your agent and execute it:

```python  theme={null}
# Create a task that uses the tool
research_task = Task(
    description="Go to https://www.example.com and tell me what you see on the homepage.",
    agent=researcher,
)

# Run the crew
crew = Crew(
    agents=[researcher],
    tasks=[research_task],
    verbose=True,
)

try:
    result = crew.kickoff()
    print(result)
finally:
    # Clean up resources
    stagehand_tool.close()
```

## Step 5: Run Your Script

Execute your Python script:

```bash  theme={null}
python your_crew_script.py
```

## Advanced Configuration

Customize the StagehandTool behavior with additional parameters:

```python  theme={null}
stagehand_tool = StagehandTool(
    api_key=browserbase_api_key,
    project_id=browserbase_project_id,
    model_api_key=model_api_key,
    model_name=AvailableModel.CLAUDE_3_7_SONNET_LATEST,
    dom_settle_timeout_ms=5000,  # Wait longer for DOM to settle
    headless=True,  # Run browser in headless mode
    self_heal=True,  # Attempt to recover from errors
    wait_for_captcha_solves=True,  # Wait for CAPTCHA solving
    verbose=1,  # Control logging verbosity (0-3)
)
```

## Example Tasks

<Tabs>
  <Tab title="Form Submission" value="form-submission" label="Python">
    ```python  theme={null}
    form_task = Task(
        description="""
        Submit a contact form:
        1. Go to https://example.com/contact
        2. Fill out the form with name 'John Doe', email 'john@example.com'
        3. Submit and confirm success
        """,
        agent=researcher,
    )
    ```
  </Tab>

  <Tab title="Data Extraction" value="data-extraction" label="Python">
    ```python  theme={null}
    extraction_task = Task(
        description="""
        Extract product information:
        1. Go to the products page
        2. Extract all product names, prices, and descriptions
        3. Format as structured data
        """,
        agent=researcher,
    )
    ```
  </Tab>

  <Tab title="Multi-step Navigation" value="multi-step-navigation" label="Python">
    ```python  theme={null}
    navigation_task = Task(
        description="""
        Navigate and analyze:
        1. Start at homepage
        2. Navigate to products section
        3. Filter by 'Electronics' category
        4. Find and extract details of highest-rated product
        """,
        agent=researcher,
    )
    ```
  </Tab>
</Tabs>

<CardGroup cols={2}>
  <Card title="CrewAI Documentation" icon="book" href="https://docs.crewai.com/">
    Dive into the CrewAI documentation to learn more about its capabilities and integrations.
  </Card>

  <Card title="Browserbase Documentation" icon="book" href="https://docs.browserbase.com/">
    Access the Browserbase documentation for comprehensive guides and resources.
  </Card>
</CardGroup>
# Langchain JS Introduction

> Integrate Stagehand with Langchain JS for intelligent web automation

## Overview

This guide shows you how to use Stagehand with Langchain JS to create intelligent agents that can automate web interactions. By the end of this guide, you'll know how to:

* Set up the StagehandToolkit with Langchain JS
* Create agents that can navigate and interact with websites
* Extract structured data using natural language instructions
* Build complex automation workflows with LangGraph

## When You'd Use This

The Langchain JS integration is perfect for scenarios where you need intelligent web automation with advanced reasoning:

* **AI-driven research**: Create agents that can research information across multiple websites and synthesize findings
* **Dynamic form filling**: Automatically fill out complex forms based on contextual requirements
* **Data extraction workflows**: Extract and transform data from multiple sources with intelligent navigation
* **Multi-step web processes**: Execute complex browser workflows that require decision-making and adaptation

<CardGroup cols={1}>
  <Card title="Langchain JS Configuration" icon="gear" href="/v3/integrations/langchain/configuration">
    Learn how to set up and configure the StagehandToolkit with Langchain JS agents
  </Card>
</CardGroup>
# LangChain JS Configuration

> Set up Stagehand with LangChain JS to create intelligent web automation agents

This guide walks you through integrating Stagehand with LangChain JS to build powerful web automation workflows using natural language instructions.

## Step 1: Install Dependencies

Install the required packages for LangChain JS and Stagehand integration:

```bash  theme={null}
npm install @langchain/langgraph @langchain/community @langchain/core @browserbasehq/stagehand
```

## Step 2: Configure Environment Variables

For remote browser automation, set up your Browserbase credentials:

```bash  theme={null}
BROWSERBASE_API_KEY="your-browserbase-api-key"
BROWSERBASE_PROJECT_ID="your-browserbase-project-id"
```

## Step 3: Create a Stagehand Instance

Initialize Stagehand with your preferred configuration:

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";

// For local development
const stagehand = new Stagehand({
    env: "LOCAL",
    verbose: 2,
    enableCaching: false,
});

// For production with Browserbase
const stagehand = new Stagehand({
    env: "BROWSERBASE",
    verbose: 1,
    enableCaching: true,
});
```

## Step 4: Generate the StagehandToolkit

Create the toolkit that provides LangChain-compatible tools:

```typescript  theme={null}
import { StagehandToolkit } from '@langchain/community/agents/toolkits/stagehand';

const stagehandToolkit = await StagehandToolkit.fromStagehand(stagehand);
```

## Step 5: Use Individual Tools

The toolkit provides four specialized tools for web automation:

### Available Tools

* **stagehand\_navigate**: Navigate to specific URLs
* **stagehand\_act**: Perform browser actions (clicking, typing, etc.)
* **stagehand\_extract**: Extract structured data using schemas
* **stagehand\_observe**: Analyze page elements and possible actions

### Basic Tool Usage

```typescript  theme={null}
import { z } from "zod";

// Navigate to a website
const navigateTool = stagehandToolkit.tools.find(
    (t) => t.name === "stagehand_navigate"
);
await navigateTool.invoke("https://www.google.com");

// Perform an action
const actionTool = stagehandToolkit.tools.find(
    (t) => t.name === "stagehand_act"
);
await actionTool.invoke('Search for "OpenAI"');

// Observe the page
const observeTool = stagehandToolkit.tools.find(
    (t) => t.name === "stagehand_observe"
);
const result = await observeTool.invoke(
    "What actions can be performed on the current page?"
);
console.log(JSON.parse(result));

// Extract structured data
const extractTool = stagehandToolkit.tools.find(
    (t) => t.name === "stagehand_extract"
);
const extractResult = await extractTool.invoke({
    instruction: "Extract the main heading and description",
    schema: z.object({
        heading: z.string(),
        description: z.string(),
    }),
});
console.log(extractResult);
```

## Step 6: Build LangGraph Agents

Integrate with LangGraph for complex automation workflows:

```typescript  theme={null}
import { createReactAgent } from "@langchain/langgraph/prebuilt";

// Create an LLM
const llm = new ChatOpenAI({
    model: "gpt-4",
    temperature: 0,
});

// Create an agent with Stagehand tools
const agent = createReactAgent({
    llm,
    tools: stagehandToolkit.tools,
});

// Execute a complex workflow
const result = await agent.invoke({
    messages: [
        {
            role: "user", 
            content: "Go to example.com, find the contact form, and extract all the form fields"
        }
    ]
});
```

## Advanced Configuration

### Custom Stagehand Configuration

```typescript  theme={null}
const stagehand = new Stagehand({
    env: "BROWSERBASE",
    verbose: 2,
    enableCaching: true,
    headless: true,
    domSettleTimeoutMs: 5000,
});
```

### Error Handling

```typescript  theme={null}
try {
    const result = await agent.invoke({
        messages: [{ role: "user", content: "Navigate to invalid-url.com" }]
    });
} catch (error) {
    console.error("Automation failed:", error);
} finally {
    // Clean up resources
    await stagehand.close();
}
```

## Example Workflows

<Tabs>
  <Tab title="Data Extraction" value="data-extraction" label="TypeScript">
    ```typescript  theme={null}
    const extractionAgent = createReactAgent({
        llm,
        tools: stagehandToolkit.tools,
    });

    const result = await extractionAgent.invoke({
        messages: [{
            role: "user",
            content: `
                Go to news-website.com and extract:
                1. All article headlines
                2. Publication dates  
                3. Author names
                Format as structured JSON
            `
        }]
    });
    ```
  </Tab>

  <Tab title="Form Automation" value="form-automation" label="TypeScript">
    ```typescript  theme={null}
    const formAgent = createReactAgent({
        llm,
        tools: stagehandToolkit.tools,
    });

    const result = await formAgent.invoke({
        messages: [{
            role: "user", 
            content: `
                Navigate to contact-form.com and:
                1. Fill out the contact form with:
                   - Name: John Doe
                   - Email: john@example.com
                   - Message: Inquiry about services
                2. Submit the form
                3. Confirm submission success
            `
        }]
    });
    ```
  </Tab>

  <Tab title="Multi-site Research" value="multi-site-research" label="TypeScript">
    ```typescript  theme={null}
    const researchAgent = createReactAgent({
        llm,
        tools: stagehandToolkit.tools,
    });

    const result = await researchAgent.invoke({
        messages: [{
            role: "user",
            content: `
                Research product pricing by:
                1. Visit competitor1.com and extract pricing info
                2. Visit competitor2.com and extract pricing info  
                3. Compare features and prices
                4. Provide summary analysis
            `
        }]
    });
    ```
  </Tab>
</Tabs>

<CardGroup cols={1}>
  <Card title="LangChain JS Documentation" icon="book" href="https://js.langchain.com/docs/integrations/tools/stagehand/">
    Official LangChain JS documentation for the Stagehand integration
  </Card>
</CardGroup>
# Next.js + Vercel

> Build and deploy a Stagehand‑powered Next.js app to Vercel

## Overview

The Stagehand + Next.js Quickstart is a production‑ready template that pairs Stagehand's AI browser automation with a modern Next.js app, deployable in one click on Vercel.

<CardGroup cols={3}>
  <Card title="Deploy Template" icon="rocket" href="https://vercel.com/templates/ai/stagehand-next-js-quickstart">
    One‑click deploy to Vercel with environment setup
  </Card>

  <Card title="Live Demo" icon="globe" href="https://stagehand-nextjs-quickstart.vercel.app">
    See the deployed template in action
  </Card>

  <Card title="Source Code" icon="github" href="https://github.com/browserbase/stagehand-nextjs-quickstart">
    Browse the repository on GitHub (Stagehand v2)
  </Card>
</CardGroup>

## What you get

<CardGroup cols={2}>
  <Card title="App Router project" icon="browser">
    Next.js App Router scaffold with Tailwind styling
  </Card>

  <Card title="Server‑safe automation" icon="shield-check">
    Uses Browserbase for cloud browsers (works on Vercel functions)
  </Card>

  <Card title="Prewired config" icon="gear">
    `stagehand.config.ts` with model + provider switching
  </Card>

  <Card title="Automation ready" icon="robot">
    Example usage of Stagehand primitives
  </Card>
</CardGroup>

## Requirements

* **Node 18+** locally
* **Model key**: OpenAI or Anthropic (or plug a custom client)
* **Browserbase keys**: `BROWSERBASE_API_KEY` and `BROWSERBASE_PROJECT_ID` for cloud browsers

<Tip>
  Local Playwright browsers are not available on Vercel. Set Stagehand to Browserbase when deploying.
</Tip>

## Links

<CardGroup cols={2}>
  <Card title="Walkthrough" icon="rocket" href="/integrations/vercel/configuration">
    Run locally and deploy to Vercel in minutes
  </Card>
</CardGroup>
# Use Stagehand in Next.js

> Next.js is a popular framework for developing web-based applications in production. It powers Stagehand apps like [Director](https://director.ai), [Brainrot](https://brainrot.run) and [Open Operator](https://operator.browserbase.com).

<Card title="Check out the Stagehand Next.js Quickstart" icon="github" href="https://github.com/browserbase/stagehand-nextjs-quickstart">
  Clone our [GitHub repo](https://github.com/browserbase/stagehand-nextjs-quickstart) to get started with Stagehand (v2) in Next.js.
</Card>

## Add Stagehand to an existing Next.js project

If you'd like to start from scratch, you can run:

<Tabs>
  <Tab title="npm">
    ```bash  theme={null}
    npm create next-app@latest stagehand-nextjs --yes
    cd stagehand-nextjs
    ```
  </Tab>

  <Tab title="pnpm">
    ```bash  theme={null}
    pnpm create next-app@latest stagehand-nextjs --yes
    cd stagehand-nextjs
    ```
  </Tab>

  <Tab title="yarn">
    ```bash  theme={null}
    yarn create next-app@latest stagehand-nextjs --yes
    cd stagehand-nextjs
    ```
  </Tab>
</Tabs>

If you'd like to add Stagehand to an existing Next.js project, you can do so by installing the dependencies:

<Tabs>
  <Tab title="npm">
    ```bash  theme={null}
    npm install @browserbasehq/stagehand @browserbasehq/sdk playwright zod
    ```
  </Tab>

  <Tab title="pnpm">
    ```bash  theme={null}
    pnpm add @browserbasehq/stagehand @browserbasehq/sdk playwright zod
    ```
  </Tab>

  <Tab title="yarn">
    ```bash  theme={null}
    yarn add @browserbasehq/stagehand @browserbasehq/sdk playwright zod
    ```
  </Tab>
</Tabs>

### Add environment variables

Next, let's add the environment variables to a `.env` file.

```env  theme={null}
BROWSERBASE_API_KEY=your-browserbase-api-key
BROWSERBASE_PROJECT_ID=your-browserbase-project-id
OPENAI_API_KEY=your-openai-api-key
```

### Write a server action

Next, let's define our `main` function as a server action in `app/stagehand/main.ts`. This file will have the following three functions:

1. **`main`: Run the main Stagehand script**
2. **`runStagehand`: Initialize and run the `main` function**
3. **`startBBSSession`: Start a Browserbase session**

```ts app/stagehand/main.ts theme={null}
// 🤘 Welcome to Stagehand!
// This file is from the [Stagehand docs](https://docs.stagehand.dev/sections/examples/nextjs).

"use server";

import { Stagehand } from "@browserbasehq/stagehand";
import { z } from "zod/v3";
import { Browserbase } from "@browserbasehq/sdk";

/**
 * Run the main Stagehand script
 */
async function main(stagehand: Stagehand) {
  // You can use the `page` instance to write any Playwright code
  // For more info: https://playwright.dev/docs/pom
  const page = stagehand.context.activePage();

  // In this example, we'll get the title of the Stagehand quickstart page
  await page?.goto("https://docs.stagehand.dev/");
  await stagehand.act("click the quickstart link");
  const { title } = await stagehand.extract(
    "extract the main heading of the page",
    z.object({
      title: z.string(),
    }),
  );

  return title;
}

/**
 * Initialize and run the main() function
 */
export async function runStagehand(sessionId?: string) {
  const stagehand = new Stagehand({
    env: "BROWSERBASE",
    apiKey: process.env.BROWSERBASE_API_KEY,
    projectId: process.env.BROWSERBASE_PROJECT_ID,
    verbose: 1,
    logger: console.log,
    browserbaseSessionID: sessionId,
    disablePino: true,
  });
  await stagehand.init();
  const result = await main(stagehand);
  console.log(result);
  await stagehand.close();
}

/**
 * Start a Browserbase session
 */
export async function startBBSSession() {
  const browserbase = new Browserbase();
  const session = await browserbase.sessions.create({
    projectId: process.env.BROWSERBASE_PROJECT_ID!,
  });
  const debugUrl = await browserbase.sessions.debug(session.id);
  return {
    sessionId: session.id,
    debugUrl: debugUrl.debuggerFullscreenUrl,
  };
}
```

### Create a client component

Next, let's create a client component that will start a Browserbase session and run the `main` function with the server actions we just defined. We'll first create a Browserbase session and embed the session in an iframe before running the `main` function.

```tsx app/components/stagehandEmbed.tsx theme={null}
"use client";

import { useCallback, useState } from "react";
import { runStagehand, startBBSSession } from "@/app/stagehand/main";

export function StagehandEmbed() {
  const [sessionId, setSessionId] = useState<string | null>(null);
  const [debugUrl, setDebugUrl] = useState<string | null>(null);

  const startSession = useCallback(async () => {
    const { sessionId, debugUrl } = await startBBSSession();
    setSessionId(sessionId);
    setDebugUrl(debugUrl);
    await runStagehand(sessionId);
  }, []);

  return (
    <div>
      {!sessionId && <button onClick={startSession}>Start Session</button>}
      {sessionId && debugUrl && (
        <iframe src={debugUrl} className="w-full h-full" />
      )}
    </div>
  );
}
```

### Use the `StagehandEmbed` component

Now, we can use the `StagehandEmbed` component in our app.

```tsx app/page.tsx theme={null}
import { StagehandEmbed } from "@/app/components/stagehandEmbed";

export default function Home() {
	return (
		<main>
			<StagehandEmbed />
		</main>
	)
}
```

### Run the app

To run the app, you can use the following command:

<Tabs>
  <Tab title="npm">
    ```bash  theme={null}
    npm run dev
    ```
  </Tab>

  <Tab title="pnpm">
    ```bash  theme={null}
    pnpm dev
    ```
  </Tab>

  <Tab title="yarn">
    ```bash  theme={null}
    yarn dev
    ```
  </Tab>
</Tabs>

### Deploy the app

To deploy the app, you can use the following commands. First, install the Vercel CLI:

<Tabs>
  <Tab title="npm">
    ```bash  theme={null}
    npm add -g vercel
    ```
  </Tab>

  <Tab title="pnpm">
    ```bash  theme={null}
    pnpm add -g vercel
    ```
  </Tab>

  <Tab title="yarn">
    ```bash  theme={null}
    yarn add -g vercel
    ```
  </Tab>
</Tabs>

Then, run the following command to deploy the app:

```bash  theme={null}
vercel
```

## References

<CardGroup cols={2}>
  <Card title="Deploy Template (v2)" icon="rocket" href="https://vercel.com/templates/ai/stagehand-next-js-quickstart">
    One‑click deploy the Stagehand Next.js template on Vercel (Stagehand v2)
  </Card>

  <Card title="Source Cod (v2)" icon="github" href="https://github.com/browserbase/stagehand-nextjs-quickstart">
    Browse the complete template repository on GitHub (Stagehand v2)
  </Card>
</CardGroup>
# Playwright

> Use Stagehand with Playwright for browser automation

## Overview

Stagehand v3 can work seamlessly with Playwright, allowing you to use Playwright's `Page` objects directly with Stagehand's AI-powered methods like `act()`, `extract()`, and `observe()`.

## Installation

First, install both Stagehand and Playwright:

```bash  theme={null}
npm install @browserbasehq/stagehand playwright-core
```

## Quickstart

### Basic Setup

Connect Playwright to Stagehand's browser instance using Chrome DevTools Protocol (CDP):

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";
import { chromium } from "playwright-core";

const stagehand = new Stagehand({
  env: "BROWSERBASE", // or "LOCAL"
  model: "openai/gpt-5",
});

await stagehand.init();

// Connect Playwright to Stagehand's browser
const browser = await chromium.connectOverCDP({
  wsEndpoint: stagehand.connectURL(),
});

const pwContext = browser.contexts()[0];
const pwPage = pwContext.pages()[0];
```

### Using Playwright Pages with Stagehand

Once connected, you can use Playwright's `Page` objects with Stagehand's AI-powered methods:

```typescript  theme={null}
// Navigate using Playwright
await pwPage.goto("https://example.com");

// Use Stagehand's AI methods with the Playwright page
await stagehand.act("click the login button", { page: pwPage });

const data = await stagehand.extract(
  "extract the article title",
  z.object({ title: z.string() }),
  { page: pwPage }
);
```

## Multi-Page Example

Stagehand works great with multiple Playwright pages:

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";
import { chromium } from "playwright-core";
import { z } from "zod/v3";

// Initialize Stagehand
const stagehand = new Stagehand({
  env: "BROWSERBASE",
  model: "openai/gpt-5",
});

await stagehand.init();

// Connect Playwright
const browser = await chromium.connectOverCDP({
  wsEndpoint: stagehand.connectURL(),
});

const pwContext = browser.contexts()[0];
const pwPage1 = pwContext.pages()[0];

// Create a second page
const pwPage2 = await pwContext.newPage();

// Navigate both pages
await pwPage1.goto("https://docs.stagehand.dev/first-steps/introduction");
await pwPage2.goto("https://docs.stagehand.dev/configuration/observability");

// Extract data from both pages concurrently
const [page1Data, page2Data] = await Promise.all([
  stagehand.extract(
    "extract the names of the four stagehand primitives",
    z.array(z.string()),
    { page: pwPage1 }
  ),
  stagehand.extract(
    "extract the list of session dashboard features",
    z.array(z.string()),
    { page: pwPage2 }
  ),
]);

console.log("Page 1 primitives:", page1Data);
console.log("Page 2 features:", page2Data);
```

## Complete Example

Here's a full working example:

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";
import { chromium } from "playwright-core";
import { z } from "zod/v3";

async function main() {
  // Initialize Stagehand
  const stagehand = new Stagehand({
    env: "BROWSERBASE",
    model: "openai/gpt-5",
    verbose: 1,
  });

  await stagehand.init();
  console.log("Stagehand initialized");

  // Connect Playwright to Stagehand's browser
  const browser = await chromium.connectOverCDP({
    wsEndpoint: stagehand.connectURL(),
  });

  const pwContext = browser.contexts()[0];
  const pwPage = pwContext.pages()[0];

  // Navigate and interact
  await pwPage.goto("https://example.com");

  // Use Stagehand's AI methods
  const actions = await stagehand.observe("find the main heading", {
    page: pwPage,
  });

  console.log("Found actions:", actions);

  // Extract data
  const heading = await stagehand.extract(
    "extract the main heading text",
    z.object({ heading: z.string() }),
    { page: pwPage }
  );

  console.log("Heading:", heading);

  // Cleanup
  await stagehand.close();
}

main();
```

## Key Points

* **Connect via CDP**: Use `chromium.connectOverCDP()` with `stagehand.connectURL()` as the WebSocket endpoint
* **Pass the page**: Always pass the Playwright `page` object to Stagehand methods using the `{ page }` option
* **Multi-page support**: Create multiple pages with `pwContext.newPage()` and pass them to Stagehand methods
* **Concurrent operations**: Use `Promise.all()` to run multiple Stagehand operations in parallel across different pages

## Environment Variables

When using Browserbase, set your credentials:

```bash  theme={null}
BROWSERBASE_API_KEY=your_api_key
BROWSERBASE_PROJECT_ID=your_project_id
```

For OpenAI (or other providers):

```bash  theme={null}
OPENAI_API_KEY=your_api_key
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Agent" icon="robot" href="/v3/references/agent">
    Automate entire workflows
  </Card>

  <Card title="Act" icon="play" href="/v3/references/act">
    Execute actions on web pages
  </Card>

  <Card title="Extract" icon="ufo-beam" href="/v3/references/extract">
    Extract structured data from pages
  </Card>

  <Card title="Observe" icon="eye" href="/v3/references/observe">
    Observe and find elements on pages
  </Card>
</CardGroup>
# Puppeteer

> Use Stagehand with Puppeteer for browser automation

## Overview

Stagehand v3 can work seamlessly with Puppeteer, allowing you to use Puppeteer's `Page` objects directly with Stagehand's AI-powered methods like `act()`, `extract()`, and `observe()`.

## Installation

First, install both Stagehand and Puppeteer:

```bash  theme={null}
npm install @browserbasehq/stagehand puppeteer-core
```

## Quickstart

### Basic Setup

Connect Puppeteer to Stagehand's browser instance:

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";
import puppeteer from "puppeteer-core";

const stagehand = new Stagehand({
  env: "LOCAL", // or "BROWSERBASE"
  model: "openai/gpt-5",
});

await stagehand.init();

// Connect Puppeteer to Stagehand's browser
const browser = await puppeteer.connect({
  browserWSEndpoint: stagehand.connectURL(),
  defaultViewport: null,
});

const pages = await browser.pages();
const ppPage = pages[0];
```

### Using Puppeteer Pages with Stagehand

Once connected, you can use Puppeteer's `Page` objects with Stagehand's AI-powered methods:

```typescript  theme={null}
// Navigate using Puppeteer
await ppPage.goto("https://example.com");

// Use Stagehand's AI methods with the Puppeteer page
await stagehand.act("click the sign in button", { page: ppPage });

const data = await stagehand.extract(
  "extract the page title",
  z.object({ title: z.string() }),
  { page: ppPage }
);
```

## Advanced: Multi-Page Usage

Create and manage multiple Puppeteer pages with Stagehand:

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";
import puppeteer from "puppeteer-core";
import { z } from "zod/v3";

async function multiPageExample() {
  const stagehand = new Stagehand({
    env: "BROWSERBASE",
    model: "openai/gpt-5",
  });

  await stagehand.init();

  // Connect Puppeteer
  const browser = await puppeteer.connect({
    browserWSEndpoint: stagehand.connectURL(),
    defaultViewport: null,
  });

  // Get the first page
  const pages = await browser.pages();
  const ppPage1 = pages[0];

  // Create a second page
  const ppPage2 = await browser.newPage();

  // Navigate both pages
  await ppPage1.goto("https://example.com");
  await ppPage2.goto("https://another-site.com");

  // Use Stagehand on different pages
  await stagehand.act("click the button", { page: ppPage1 });

  const data = await stagehand.extract(
    "extract the title",
    z.object({ title: z.string() }),
    { page: ppPage2 }
  );

  console.log("Extracted from page 2:", data);

  await stagehand.close();
}
```

## Observe + Act Pattern

The recommended pattern for reliable automation:

```typescript  theme={null}
// Step 1: Observe to find candidate actions
const actions = await stagehand.observe(
  "find the submit button",
  { page: ppPage }
);

// Step 2: Execute the first action
if (actions.length > 0) {
  await stagehand.act(actions[0], { page: ppPage });
}
```

This pattern helps avoid DOM changes between observation and action execution.

## Key Points

* **Connect via WebSocket**: Use `puppeteer.connect()` with `stagehand.connectURL()` as the `browserWSEndpoint`
* **Pass the page**: Always pass the Puppeteer `page` object to Stagehand methods using the `{ page }` option
* **Disable viewport**: Set `defaultViewport: null` to use Stagehand's viewport settings
* **Multi-page support**: Create multiple pages with `browser.newPage()` and pass them to Stagehand methods

## Environment Variables

When using Browserbase, set your credentials:

```bash  theme={null}
BROWSERBASE_API_KEY=your_api_key
BROWSERBASE_PROJECT_ID=your_project_id
```

For OpenAI (or other providers):

```bash  theme={null}
OPENAI_API_KEY=your_api_key
```

## Comparison: Stagehand Native vs Puppeteer

| Feature         | Stagehand Native                         | With Puppeteer                             |
| --------------- | ---------------------------------------- | ------------------------------------------ |
| **Setup**       | Simple - use `stagehand.context.pages()` | Requires `puppeteer.connect()`             |
| **Page Access** | `stagehand.context.pages()[0]`           | `await browser.pages()`                    |
| **AI Methods**  | `stagehand.act("click")`                 | `stagehand.act("click", { page: ppPage })` |
| **Best For**    | Pure Stagehand workflows                 | Existing Puppeteer codebases               |

## Next Steps

<CardGroup cols={2}>
  <Card title="Agent" icon="robot" href="/v3/references/agent">
    Automate entire workflows
  </Card>

  <Card title="Act" icon="play" href="/v3/references/act">
    Execute actions on web pages
  </Card>

  <Card title="Extract" icon="ufo-beam" href="/v3/references/extract">
    Extract structured data from pages
  </Card>

  <Card title="Observe" icon="eye" href="/v3/references/observe">
    Observe and find elements on pages
  </Card>
</CardGroup>
# Selenium

> Use Stagehand with Selenium to operate the same browser in tandem

## Overview

Stagehand v3 can work alongside Selenium WebDriver, allowing both tools to operate on the same browser session simultaneously. This enables you to combine Stagehand's AI-powered automation with Selenium's precise element interactions.

<Warning>
  **Browserbase Only**: This integration requires Browserbase. It does not work with `env: "LOCAL"` because Selenium needs a remote WebDriver endpoint.
</Warning>

## Installation

Install Stagehand, Selenium, and the Browserbase SDK:

```bash  theme={null}
npm install @browserbasehq/stagehand selenium-webdriver @browserbasehq/sdk
```

## Quickstart

### Create Shared Session

Use the Browserbase SDK to create a session that both tools can connect to:

```typescript  theme={null}
import http from "http";
import { Builder, Key } from "selenium-webdriver";
import Browserbase from "@browserbasehq/sdk";
import { Stagehand } from "@browserbasehq/stagehand";

const bb = new Browserbase({
  apiKey: process.env.BROWSERBASE_API_KEY,
});

// Create shared session
const session = await bb.sessions.create({
  projectId: process.env.BROWSERBASE_PROJECT_ID,
});

console.log("Session created:", session.id);
```

### Connect Stagehand

Initialize Stagehand with the session ID:

```typescript  theme={null}
const stagehand = new Stagehand({
  env: "BROWSERBASE",
  browserbaseSessionID: session.id,
  model: "openai/gpt-5",
  verbose: 2,
});

await stagehand.init();
```

### Connect Selenium

Use a custom HTTP agent with the session's signing key:

```typescript  theme={null}
// Create custom HTTP agent with signing key
const customHttpAgent = new http.Agent({});
(customHttpAgent as any).addRequest = (req: any, options: any) => {
  req.setHeader("x-bb-signing-key", session.signingKey);
  (http.Agent.prototype as any).addRequest.call(customHttpAgent, req, options);
};

// Connect Selenium WebDriver
const driver = new Builder()
  .forBrowser("chrome")
  .usingHttpAgent(customHttpAgent)
  .usingServer(session.seleniumRemoteUrl)
  .build();
```

### Use Both Tools Together

Now both Stagehand and Selenium operate on the same browser:

```typescript  theme={null}
// Navigate with Stagehand
const page = stagehand.context.pages()[0];
await page.goto("https://www.google.com");

// Extract page content with Stagehand AI
const pageContent = await stagehand.extract();
console.log("Page content:", pageContent);

// Use Selenium for precise element interaction
const searchBox = await driver.findElement({ name: "q" });
await searchBox.sendKeys("Browserbase automation");
await searchBox.sendKeys(Key.RETURN);

// Wait for results
await driver.sleep(2000);

console.log("Search completed!");
```

## Key Points

* **Shared Session**: Both tools connect to the same Browserbase session
* **Signing Key**: Selenium requires the session's `signingKey` in HTTP headers
* **Remote URL**: Use `session.seleniumRemoteUrl` for Selenium's server endpoint
* **Concurrent Usage**: Both tools can operate on the browser simultaneously
* **Cleanup**: Close both Stagehand (`await stagehand.close()`) and Selenium (`await driver.quit()`)

## Next Steps

<CardGroup cols={2}>
  <Card title="Agent" icon="robot" href="/v3/references/agent">
    Automate entire workflows
  </Card>

  <Card title="Act" icon="play" href="/v3/references/act">
    Execute actions on web pages
  </Card>

  <Card title="Extract" icon="ufo-beam" href="/v3/references/extract">
    Extract structured data from pages
  </Card>

  <Card title="Observe" icon="eye" href="/v3/references/observe">
    Observe and find elements on pages
  </Card>
</CardGroup>
# Stagehand

> Complete API reference for the Stagehand class

<CardGroup cols={1}>
  <Card title="Getting Started" icon="rocket" href="/v3/getting-started">
    Learn how to initialize and use Stagehand
  </Card>
</CardGroup>

## Overview

The `Stagehand` class is the main entry point for Stagehand v3. It manages browser lifecycle, provides AI-powered automation methods, and handles both local and remote browser environments.

```typescript  theme={null}
import { Stagehand } from "@browserbasehq/stagehand";

const stagehand = new Stagehand(options);
await stagehand.init();
```

## Constructor

### new Stagehand()

Create a new Stagehand instance.

```typescript  theme={null}
const stagehand = new Stagehand(options: V3Options);
```

**V3Options Interface:**

```typescript  theme={null}
interface V3Options {
  env: "LOCAL" | "BROWSERBASE";

  // Browserbase options (required when env = "BROWSERBASE")
  apiKey?: string;
  projectId?: string;
  browserbaseSessionID?: string;
  browserbaseSessionCreateParams?: Browserbase.Sessions.SessionCreateParams;

  // Local browser options
  localBrowserLaunchOptions?: LocalBrowserLaunchOptions;

  // AI/LLM configuration
  model?: ModelConfiguration;
  llmClient?: LLMClient;
  systemPrompt?: string;

  // Behavior options
  selfHeal?: boolean;
  experimental?: boolean;
  domSettleTimeout?: number;
  cacheDir?: string;

  // Logging options
  verbose?: 0 | 1 | 2;
  logInferenceToFile?: boolean;
  disablePino?: boolean;
  logger?: (line: LogLine) => void;
}
```

### Configuration Parameters

<ParamField path="env" type="&#x22;LOCAL&#x22; | &#x22;BROWSERBASE&#x22;" required>
  Environment to run the browser in.

  * **`"LOCAL"`** - Run browser locally using Chrome/Chromium
  * **`"BROWSERBASE"`** - Run browser on Browserbase cloud platform
</ParamField>

#### Browserbase Options

<ParamField path="apiKey" type="string" optional>
  Browserbase API key. Required when `env` is `"BROWSERBASE"`.

  Can also be set via `BROWSERBASE_API_KEY` environment variable.
</ParamField>

<ParamField path="projectId" type="string" optional>
  Browserbase project ID. Required when `env` is `"BROWSERBASE"`.

  Can also be set via `BROWSERBASE_PROJECT_ID` environment variable.
</ParamField>

<ParamField path="browserbaseSessionID" type="string" optional>
  Resume an existing Browserbase session by ID instead of creating a new one.
</ParamField>

<ParamField path="browserbaseSessionCreateParams" type="object" optional>
  Additional parameters for Browserbase session creation. See [Browserbase documentation](https://docs.browserbase.com) for details.
</ParamField>

#### Local Browser Options

<ParamField path="localBrowserLaunchOptions" type="LocalBrowserLaunchOptions" optional>
  Configuration for local Chrome/Chromium browser.

  <Expandable title="LocalBrowserLaunchOptions">
    <ParamField path="headless" type="boolean" optional>
      Run browser in headless mode.

      **Default:** `true`
    </ParamField>

    <ParamField path="executablePath" type="string" optional>
      Path to Chrome/Chromium executable.
    </ParamField>

    <ParamField path="args" type="string[]" optional>
      Additional Chrome launch arguments.
    </ParamField>

    <ParamField path="userDataDir" type="string" optional>
      Path to user data directory for browser profile.
    </ParamField>

    <ParamField path="viewport" type="{ width: number; height: number }" optional>
      Default viewport size.
    </ParamField>

    <ParamField path="devtools" type="boolean" optional>
      Auto-open DevTools for each tab.

      **Default:** `false`
    </ParamField>

    <ParamField path="proxy" type="object" optional>
      Proxy configuration.

      **Properties:** `server`, `bypass`, `username`, `password`
    </ParamField>

    <ParamField path="ignoreHTTPSErrors" type="boolean" optional>
      Ignore HTTPS certificate errors.

      **Default:** `false`
    </ParamField>

    <ParamField path="cdpUrl" type="string" optional>
      Attach to existing Chrome instance via CDP WebSocket URL.
    </ParamField>
  </Expandable>
</ParamField>

#### AI/LLM Configuration

<ParamField path="model" type="ModelConfiguration" optional>
  Configure the AI model to use for automation. Can be either:

  * A string in the format `"provider/model"` (e.g., `"openai/gpt-4o"`, `"anthropic/claude-3-5-sonnet-20241022"`)
  * An object with detailed configuration

  <Expandable title="Model Configuration Object">
    <ParamField path="modelName" type="string" required>
      The model name (e.g., "gpt-4o", "claude-3-5-sonnet-20241022", "gemini-2.5-flash")
    </ParamField>

    <ParamField path="apiKey" type="string" optional>
      API key for the model provider (overrides environment variables)
    </ParamField>

    <ParamField path="baseURL" type="string" optional>
      Base URL for the API endpoint (for custom endpoints or proxies)
    </ParamField>
  </Expandable>
</ParamField>

<ParamField path="llmClient" type="LLMClient" optional>
  Provide a custom LLM client implementation instead of using the default.
</ParamField>

<ParamField path="systemPrompt" type="string" optional>
  Custom system prompt to guide AI behavior across all operations.
</ParamField>

#### Behavior Options

<ParamField path="selfHeal" type="boolean" optional>
  Enable self-healing mode where actions can recover from failures.

  **Default:** `true`
</ParamField>

<ParamField path="experimental" type="boolean" optional>
  Enable experimental features (may change between versions).

  **Default:** `false`
  <Warning>**Use with caution in production**. Experimental features may break or change between versions without notice.</Warning>
</ParamField>

<ParamField path="domSettleTimeout" type="number" optional>
  Default timeout for waiting for DOM to stabilize (in milliseconds).

  **Default:** `30000`
</ParamField>

<ParamField path="cacheDir" type="string" optional>
  Directory path for caching action observations to improve performance.
</ParamField>

#### Logging Options

<ParamField path="verbose" type="0 | 1 | 2" optional>
  Logging verbosity level.

  * **`0`** - Minimal logging
  * **`1`** - Standard logging (default)
  * **`2`** - Detailed debug logging

  **Default:** `1`
</ParamField>

<ParamField path="logInferenceToFile" type="boolean" optional>
  Log AI inference details to files for debugging.

  **Default:** `false`
</ParamField>

<ParamField path="disablePino" type="boolean" optional>
  Disable the Pino logging backend (useful for custom logging integrations).

  **Default:** `false`
</ParamField>

<ParamField path="logger" type="(line: LogLine) => void" optional>
  Custom logger function to receive log events.
</ParamField>

## Methods

### init()

Initialize the Stagehand instance and launch the browser.

```typescript  theme={null}
await stagehand.init(): Promise<void>
```

**Must be called before using any other methods.**

### close()

Close the browser and clean up resources.

```typescript  theme={null}
await stagehand.close(options?: { force?: boolean }): Promise<void>
```

<ParamField path="force" type="boolean" optional>
  Force close even if already closing.

  **Default:** `false`
</ParamField>

### agent()

Create an AI agent instance for autonomous multi-step workflows.

```typescript  theme={null}
stagehand.agent(config?: AgentConfig): AgentInstance
```

See the [agent() reference](/v3/references/agent) for detailed documentation.

## Properties

### page

Access pages for browser automation. Pages are accessed through the context.

```typescript  theme={null}
// Get the first page (created automatically on init)
const page = stagehand.context.pages()[0];

// Or get the active page
const activePage = stagehand.context.activePage();

// Create a new page
const newPage = await stagehand.context.newPage();
```

**Type:** [`Page`](/v3/references/page)

The page object provides methods for:

* Navigation (`goto()`, `reload()`, `goBack()`, `goForward()`)
* Interaction (`click()`, `type()`, `keyPress()`, `locator()`, `deepLocator()`)
* Inspection (`url()`, `title()`, `screenshot()`)
* JavaScript evaluation (`evaluate()`)

<Note>
  **Important:** AI-powered methods ([`act()`](/v3/references/act), [`extract()`](/v3/references/extract), [`observe()`](/v3/references/observe)) are called on the stagehand instance, not on the page object.
</Note>

### context

Access the browser context for managing multiple pages.

```typescript  theme={null}
const context = stagehand.context;
```

**Type:** `V3Context`

The context object provides:

* `newPage()` - Create a new page/tab
* `pages()` - Get all open pages
* `setActivePage(page)` - Switch active page

### metrics

Get usage metrics for AI operations.

```typescript  theme={null}
const metrics = await stagehand.metrics;
```

**Returns:** `Promise<StagehandMetrics>`

**StagehandMetrics Interface:**

```typescript  theme={null}
interface StagehandMetrics {
  // Act metrics
  actPromptTokens: number;
  actCompletionTokens: number;
  actReasoningTokens: number;
  actCachedInputTokens: number;
  actInferenceTimeMs: number;

  // Extract metrics
  extractPromptTokens: number;
  extractCompletionTokens: number;
  extractReasoningTokens: number;
  extractCachedInputTokens: number;
  extractInferenceTimeMs: number;

  // Observe metrics
  observePromptTokens: number;
  observeCompletionTokens: number;
  observeReasoningTokens: number;
  observeCachedInputTokens: number;
  observeInferenceTimeMs: number;

  // Agent metrics
  agentPromptTokens: number;
  agentCompletionTokens: number;
  agentReasoningTokens: number;
  agentCachedInputTokens: number;
  agentInferenceTimeMs: number;

  // Totals
  totalPromptTokens: number;
  totalCompletionTokens: number;
  totalReasoningTokens: number;
  totalCachedInputTokens: number;
  totalInferenceTimeMs: number;
}
```

### history

Get the history of all operations performed.

```typescript  theme={null}
const history = await stagehand.history;
```

**Returns:** `Promise<ReadonlyArray<HistoryEntry>>`

**HistoryEntry Interface:**

```typescript  theme={null}
interface HistoryEntry {
  method: "act" | "extract" | "observe" | "navigate";
  parameters: unknown;
  result: unknown;
  timestamp: string;
}
```

## Code Examples

<Tabs>
  <Tab title="Browserbase">
    ```typescript  theme={null}
    import { Stagehand } from "@browserbasehq/stagehand";

    // Remote browser on Browserbase
    const stagehand = new Stagehand({
      env: "BROWSERBASE",
      apiKey: process.env.BROWSERBASE_API_KEY,
      projectId: process.env.BROWSERBASE_PROJECT_ID,
      model: "anthropic/claude-3-5-sonnet-20241022"
    });

    await stagehand.init();
    const page = stagehand.context.pages()[0];

    await page.goto("https://example.com");
    const data = await stagehand.extract("get page title", z.object({
      title: z.string()
    }));

    await stagehand.close();
    ```
  </Tab>

  <Tab title="Local">
    ```typescript  theme={null}
    import { Stagehand } from "@browserbasehq/stagehand";

    // Local browser
    const stagehand = new Stagehand({
      env: "LOCAL",
      model: "openai/gpt-4o"
    });

    await stagehand.init();
    const page = stagehand.context.pages()[0];

    // Use the page
    await page.goto("https://example.com");
    await stagehand.act("click the login button");

    // Cleanup
    await stagehand.close();
    ```
  </Tab>

  <Tab title="Custom Model Config">
    ```typescript  theme={null}
    import { Stagehand } from "@browserbasehq/stagehand";

    const stagehand = new Stagehand({
      env: "LOCAL",
      model: {
        modelName: "gpt-4o",
        apiKey: process.env.OPENAI_API_KEY,
        baseURL: "https://custom-proxy.com/v1"
      },
      systemPrompt: "You are a helpful automation assistant.",
      verbose: 2,
      selfHeal: true
    });

    await stagehand.init();
    ```
  </Tab>

  <Tab title="Multi-Page">
    ```typescript  theme={null}
    import { Stagehand } from "@browserbasehq/stagehand";

    const stagehand = new Stagehand({ env: "LOCAL" });
    await stagehand.init();

    // Get the first page
    const page1 = stagehand.context.pages()[0];
    await page1.goto("https://example.com");

    // Create second page
    const page2 = await stagehand.context.newPage();
    await page2.goto("https://another-site.com");

    // Switch active page
    stagehand.context.setActivePage(page2);

    // Now context.activePage() returns page2
    await stagehand.act("click the button");

    await stagehand.close();
    ```
  </Tab>

  <Tab title="With Metrics">
    ```typescript  theme={null}
    import { Stagehand } from "@browserbasehq/stagehand";

    const stagehand = new Stagehand({
      env: "LOCAL",
      model: "openai/gpt-4o"
    });

    await stagehand.init();
    const page = stagehand.context.pages()[0];

    await page.goto("https://example.com");
    await stagehand.act("fill out the form");
    await stagehand.extract("get form data", schema);

    // Get usage metrics
    const metrics = await stagehand.metrics;
    console.log("Total tokens used:", metrics.totalPromptTokens + metrics.totalCompletionTokens);
    console.log("Act operations:", {
      tokens: metrics.actPromptTokens + metrics.actCompletionTokens,
      time: metrics.actInferenceTimeMs
    });

    await stagehand.close();
    ```
  </Tab>

  <Tab title="With Custom Logger">
    ```typescript  theme={null}
    import { Stagehand } from "@browserbasehq/stagehand";

    const stagehand = new Stagehand({
      env: "LOCAL",
      verbose: 2,
      logger: (logLine) => {
        console.log(`[${logLine.category}] ${logLine.message}`);
        if (logLine.auxiliary) {
          console.log("Details:", logLine.auxiliary);
        }
      }
    });

    await stagehand.init();
    // All operations will now log through your custom logger
    ```
  </Tab>
</Tabs>

## Error Handling

Stagehand methods may throw the following errors:

* **StagehandInitError** - Failed to initialize Stagehand
* **StagehandNotInitializedError** - Methods called before `init()`
* **BrowserbaseSessionNotFoundError** - Browserbase session not found
* **MissingLLMConfigurationError** - No LLM API key or client configured
* **MissingEnvironmentVariableError** - Required environment variable not set
* **StagehandEnvironmentError** - Invalid environment configuration

Always handle errors appropriately:

```typescript  theme={null}
try {
  const stagehand = new Stagehand({ env: "LOCAL" });
  await stagehand.init();
  // ... use stagehand
} catch (error) {
  console.error("Stagehand error:", error.message);
} finally {
  await stagehand?.close();
}
```

## Best Practices

1. **Always call `init()`** before using any other methods
2. **Always call `close()`** when done to clean up resources
3. **Use try-finally** to ensure cleanup even on errors
4. **Set appropriate timeouts** based on your use case
5. **Enable `selfHeal`** for more robust automation
6. **Use metrics** to monitor token usage and costs
7. **Configure custom logger** for production debugging
8. **Cache directory** can significantly improve performance for repeated actions

## Environment Variables

Stagehand recognizes the following environment variables:

* `BROWSERBASE_API_KEY` - Browserbase API key
* `BROWSERBASE_PROJECT_ID` - Browserbase project ID
* `OPENAI_API_KEY` - OpenAI API key
* `ANTHROPIC_API_KEY` - Anthropic API key
* `GOOGLE_API_KEY` - Google AI API key

These can be overridden by passing values in the constructor options.
# act()

> Complete API reference for the act() method

<CardGroup cols={1}>
  <Card title="Act" icon="arrow-pointer" href="/v3/basics/act">
    See how to use act() to perform browser actions
  </Card>
</CardGroup>

### Method Signatures

<Tabs>
  <Tab title="TypeScript">
    ```typescript  theme={null}
    // String instruction only
    await stagehand.act(instruction: string): Promise<ActResult>

    // Action only - Deterministic (no LLM)
    await stagehand.act(action: Action): Promise<ActResult>

    // String instruction with options
    await stagehand.act(instruction: string, options: ActOptions): Promise<ActResult>

    ```

    **Action Interface:**

    ```typescript  theme={null}
    interface Action {
      selector: string;
      description: string;
      method: string;
      arguments: string[];
    }
    ```

    **ActOptions Interface:**

    ```typescript  theme={null}
    interface ActOptions {
      model?: ModelConfiguration;
      variables?: Record<string, string>;
      timeout?: number;
      page?: PlaywrightPage | PuppeteerPage | PatchrightPage | Page;
    }

    // ModelConfiguration can be either a string or an object
    type ModelConfiguration =
      | string  // Format: "provider/model" (e.g., "openai/gpt-4o", "anthropic/claude-3-5-sonnet-20241022")
      | {
          modelName: string;  // The model name
          apiKey?: string;    // Optional: API key override
          baseURL?: string;   // Optional: Base URL override
          // Additional provider-specific options
        }
    ```
  </Tab>
</Tabs>

### Parameters

<ParamField path="instruction | action" type="string | Action" required>
  * **Instruction**: Natural language description of the action to perform. Use `%variableName%` syntax to reference variables.
  * **Action**: A deterministic action to perform:

  <Expandable title="Action">
    <ParamField path="selector" type="string" required>
      The selector (XPath, CSS selector, etc.) used to target the element
    </ParamField>

    <ParamField path="description" type="string" required>
      Description of the action - used for self-healing
    </ParamField>

    <ParamField path="method" type="string" required>
      The method used (e.g., "click", "fill", "type")
    </ParamField>

    <ParamField path="arguments" type="string[]" required>
      Arguments passed to the method
    </ParamField>
  </Expandable>
</ParamField>

<ParamField path="model" type="ModelConfiguration" optional>
  Configure the AI model to use for this action. Can be either:

  * A string in the format `"provider/model"` (e.g., `openai/gpt-5`, `google/gemini-2.5-flash`)
  * An object with detailed configuration

  <Expandable title="Model Configuration Object">
    <ParamField path="modelName" type="string" required>
      The model name (e.g., `anthropic/claude-sonnet-4-5`, `google/gemini-2.5-flash`)
    </ParamField>

    <ParamField path="apiKey" type="string" optional>
      API key for the model provider (overrides default)
    </ParamField>

    <ParamField path="baseURL" type="string" optional>
      Base URL for the API endpoint (for custom endpoints or proxies)
    </ParamField>
  </Expandable>
</ParamField>

<ParamField path="variables" type="Record<string, string>" optional>
  Key-value pairs for variable substitution using `%variableName%` syntax in your instruction. Variables are **not shared with LLM providers**, making them ideal for sensitive data like passwords and API keys.

  **Example:**

  ```typescript  theme={null}
  await stagehand.act("type %password% into the password field", {
    variables: { password: process.env.USER_PASSWORD }
  });
  ```
</ParamField>

<ParamField path="timeout" type="number" optional>
  Maximum time in **milliseconds** to wait for the action to complete. Default varies by configuration.
</ParamField>

<ParamField path="page" type="PlaywrightPage | PuppeteerPage | PatchrightPage | Page" optional>
  Optional: Specify which page to perform the action on. Supports multiple browser automation libraries:

  * **Playwright**: Native Playwright Page objects
  * **Puppeteer**: Puppeteer Page objects
  * **Patchright**: Patchright Page objects
  * **Stagehand Page**: Stagehand's wrapped Page object

  If not specified, defaults to the current "active" page in your Stagehand instance.
</ParamField>

### Returns `Promise<ActResult>`

<ResponseField name="success" type="boolean" required>
  Whether the action completed successfully
</ResponseField>

<ResponseField name="message" type="string" required>
  Human-readable message describing the result
</ResponseField>

<ResponseField name="actionDescription" type="string" required>
  Instruction that was used to perform the action
</ResponseField>

<ResponseField name="actions" type="Action[]">
  Array of actions that were executed

  <Expandable title="Action">
    <ResponseField name="selector" type="string">
      The selector (XPath) used to target the element
    </ResponseField>

    <ResponseField name="description" type="string">
      Description of the action
    </ResponseField>

    <ResponseField name="method" type="string">
      The method used (e.g., "click", "fill", "type")
    </ResponseField>

    <ResponseField name="arguments" type="string[]">
      Arguments passed to the method
    </ResponseField>
  </Expandable>
</ResponseField>

**Example Response:**

```json  theme={null}
{
  "success": true,
  "message": "Action completed successfully",
  "actionDescription": "Clicked the submit button",
  "actions": [
    {
      "selector": "/html/body/form/button[1]",
      "description": "Submit button at bottom of form",
      "method": "click",
      "arguments": []
    }
  ]
}
```

### Built-in Support

<Note>
  **Iframe and Shadow DOM interactions are supported out of the box.** Stagehand automatically handles iframe traversal and shadow DOM elements without requiring additional configuration or flags.
</Note>

### Code Examples

<Tabs>
  <Tab title="Basic Usage">
    ```typescript  theme={null}
    import { Stagehand } from "@browserbasehq/stagehand";

    // Initialize with Browserbase (API key and project ID from environment variables)
    // Set BROWSERBASE_API_KEY and BROWSERBASE_PROJECT_ID in your environment
    const stagehand = new Stagehand({ env: "BROWSERBASE" });
    await stagehand.init();
    const page = stagehand.context.pages()[0];

    await page.goto("https://example.com");

    // Simple action
    await stagehand.act("click the login button");
    ```
  </Tab>

  <Tab title="Variables">
    ```typescript  theme={null}
    // Variables are NOT shared with LLM providers
    await stagehand.act("type %username% into the email field", {
      variables: { username: "user@example.com" }
    });

    await stagehand.act("type %password% into the password field", {
      variables: { password: process.env.USER_PASSWORD }
    });

    await stagehand.act("click the login button");
    ```
  </Tab>

  <Tab title="Custom Model">
    ```typescript  theme={null}
    // Using string format
    await stagehand.act("choose 'Peach' from the favorite color dropdown", {
      model: "google/gemini-2.5-flash",
      timeout: 10000
    });

    // Using object format with custom configuration
    await stagehand.act("choose 'Peach' from the favorite color dropdown", {
      model: {
        modelName: "gemini-2.5-flash",
        apiKey: process.env.GOOGLE_API_KEY,
        baseURL: "https://custom-api-endpoint.com"
      },
      timeout: 10000
    });
    ```
  </Tab>

  <Tab title="Multi-Page">
    ```typescript  theme={null}
    // Create multiple pages
    const page1 = stagehand.context.pages()[0];
    const page2 = await stagehand.context.newPage();

    // Perform actions on specific pages
    await stagehand.act("click the first link", { page: page1 });
    await stagehand.act("click the second link", { page: page2 });
    ```
  </Tab>

  <Tab title="Caching">
    <Tip>
      **Auto-caching is now available in v3.** See the [caching guide](/v3/best-practices/caching) for more details.
    </Tip>

    ```typescript  theme={null}
    // Observe first to plan the action
    const [action] = await stagehand.observe("click the submit button");

    // Cache and reuse the action
    if (action) {
      await stagehand.act(action);
    }

    // Later, reuse the same cached action
    await stagehand.act(action);
    ```
  </Tab>
</Tabs>

### Error Types

The following errors may be thrown by the `act()` method:

* **StagehandError** - Base class for all Stagehand-specific errors
* **StagehandElementNotFoundError** - Target element could not be located using the provided selector(s)
* **StagehandClickError** - Failed to click on the target element
* **StagehandEvalError** - Error occurred while evaluating JavaScript in the page context
* **StagehandDomProcessError** - Error occurred while processing the DOM
* **StagehandIframeError** - Unable to resolve iframe for the target element
* **ContentFrameNotFoundError** - Unable to obtain content frame for the selector
* **XPathResolutionError** - XPath does not resolve in the current page or frames
* **StagehandShadowRootMissingError** - No shadow root present on the resolved host element
* **LLMResponseError** - Error in LLM response processing
* **MissingLLMConfigurationError** - No LLM API key or client configured
* **UnsupportedModelError** - The specified model is not supported for this operation
* **InvalidAISDKModelFormatError** - Model string does not follow the required `provider/model` format
# extract()

> Complete API reference for the extract() method

<CardGroup cols={1}>
  <Card title="Extract" icon="ufo-beam" href="/v3/basics/extract">
    See how to use extract() to extract structured data from web pages
  </Card>
</CardGroup>

### Method Signatures

<Tabs>
  <Tab title="TypeScript">
    ```typescript  theme={null}
    // No parameters (raw page content)
    await stagehand.extract(): Promise<{ pageText: string }>

    // Options only (for example, for targeted extraction)
    await stagehand.extract(options: ExtractOptions): Promise<{ pageText: string }>

    // String instruction only
    await stagehand.extract(instruction: string): Promise<{ extraction: string }>

    // With schema
    await stagehand.extract<T extends ZodTypeAny>(
      instruction: string,
      schema: T,
      options?: ExtractOptions
    ): Promise<z.infer<T>>
    ```

    **ExtractOptions Interface:**

    ```typescript  theme={null}
    interface ExtractOptions {
      model?: ModelConfiguration;
      timeout?: number;
      selector?: string;
      page?: PlaywrightPage | PuppeteerPage | PatchrightPage | Page;
    }

    // ModelConfiguration can be either a string or an object
    type ModelConfiguration =
      | string  // Format: "provider/model" (e.g., "openai/gpt-5-mini", "anthropic/claude-sonnet-4-5")
      | {
          modelName: string;  // The model name
          apiKey?: string;    // Optional: API key override
          baseURL?: string;   // Optional: Base URL override
          // Additional provider-specific options
        }
    ```
  </Tab>
</Tabs>

### Parameters

<ParamField path="instruction" type="string" optional>
  Natural language description of what data to extract. If omitted with no schema, returns raw page text.
</ParamField>

<ParamField path="schema" type="ZodTypeAny" optional>
  Zod schema defining the structure of data to extract. Ensures type safety and validation. The return type is automatically inferred from the schema.
</ParamField>

<ParamField path="model" type="ModelConfiguration" optional>
  Configure the AI model to use for this action. Can be either:

  * A string in the format `"provider/model"` (e.g., `openai/gpt-5`, `google/gemini-2.5-flash`)
  * An object with detailed configuration

  <Expandable title="Model Configuration Object">
    <ParamField path="modelName" type="string" required>
      The model name (e.g., `anthropic/claude-sonnet-4-5`, `google/gemini-2.5-flash`)
    </ParamField>

    <ParamField path="apiKey" type="string" optional>
      API key for the model provider (overrides default)
    </ParamField>

    <ParamField path="baseURL" type="string" optional>
      Base URL for the API endpoint (for custom endpoints or proxies)
    </ParamField>
  </Expandable>
</ParamField>

<ParamField path="timeout" type="number" optional>
  Maximum time in milliseconds to wait for the extraction to complete. Default varies by configuration.
</ParamField>

<ParamField path="selector" type="string" optional>
  Optional selector (XPath, CSS selector, etc.) to limit extraction scope to a specific part of the page. Reduces token usage and improves accuracy.
</ParamField>

<ParamField path="page" type="PlaywrightPage | PuppeteerPage | PatchrightPage | Page" optional>
  Optional: Specify which page to perform the extraction on. Supports multiple browser automation libraries:

  * **Playwright**: Native Playwright Page objects
  * **Puppeteer**: Puppeteer Page objects
  * **Patchright**: Patchright Page objects
  * **Stagehand Page**: Stagehand's wrapped Page object

  If not specified, defaults to the current "active" page in your Stagehand instance.
</ParamField>

### Built-in Support

<Note>
  **Iframe and Shadow DOM interactions are supported out of the box.** Stagehand automatically handles iframe traversal and shadow DOM elements without requiring additional configuration or flags.
</Note>

### Response Types

<Tabs>
  <Tab title="With Schema">
    **Returns:** `Promise<z.infer<T>>` where T is your schema

    The returned object will be strictly typed according to your Zod schema definition.
  </Tab>

  <Tab title="String Only">
    **Returns:** `Promise<{ extraction: string }>`

    `extraction`: Simple string extraction without schema validation.
  </Tab>

  <Tab title="No Parameters">
    **Returns:** `Promise<{ pageText: string }>`

    `pageText`: Raw accessibility tree representation of page content.
  </Tab>
</Tabs>

### Code Examples

<Tabs>
  <Tab title="Single Object">
    ```typescript  theme={null}
    import { Stagehand } from "@browserbasehq/stagehand";
    import { z } from 'zod';

    // Initialize with Browserbase (API key and project ID from environment variables)
    // Set BROWSERBASE_API_KEY and BROWSERBASE_PROJECT_ID in your environment
    const stagehand = new Stagehand({ env: "BROWSERBASE" });
    await stagehand.init();
    const page = stagehand.context.pages()[0];

    await page.goto("https://example.com/product");

    // Schema definition
    const ProductSchema = z.object({
      name: z.string(),
      price: z.number(),
      inStock: z.boolean()
    });

    // Extraction with v3 API
    const product = await stagehand.extract(
      "extract product details", 
      ProductSchema
    );
    ```

    #### Example Response

    ```json  theme={null}
    {
      "name": "Product Name",
      "price": 100,
      "inStock": true
    }
    ```
  </Tab>

  <Tab title="Arrays">
    ```typescript  theme={null}
    import { z } from 'zod';

    // Schema definition
    const ApartmentListingsSchema = z.array(
      z.object({
        address: z.string(),
        price: z.string(),
        bedrooms: z.number()
      })
    );

    // Extraction with v3 API
    const listings = await stagehand.extract(
      "extract all apartment listings",
      ApartmentListingsSchema
    );
    ```

    #### Example Response

    ```json  theme={null}
    [
      {
        "address": "123 Main St",
        "price": "$100,000",
        "bedrooms": 3
      },
      {
        "address": "456 Elm St",
        "price": "$150,000",
        "bedrooms": 2
      }
    ]
    ```
  </Tab>

  <Tab title="URLs">
    ```typescript  theme={null}
    import { z } from 'zod';

    // Schema definition
    const NavigationSchema = z.object({
      links: z.array(z.object({
        text: z.string(),
        url: z.string().url()  // URL validation
      }))
    });

    // Extraction with v3 API
    const links = await stagehand.extract(
      "extract navigation links",
      NavigationSchema
    );
    ```

    #### Example Response

    ```json  theme={null}
    {
      "links": [
        {
          "text": "Home",
          "url": "https://example.com"
        }
      ]
    }
    ```
  </Tab>

  <Tab title="Scoped">
    ```typescript  theme={null}
    import { z } from 'zod';

    const ProductSchema = z.object({
      name: z.string(),
      price: z.number(),
      description: z.string()
    });

    // Extract from specific page section with v3 API
    const data = await stagehand.extract(
      "extract product info from this section",
      ProductSchema,
      { selector: "/html/body/div/div" }
    );
    ```

    #### Example Response

    ```json  theme={null}
    {
      "name": "Product Name",
      "price": 100,
      "description": "Product description"
    }
    ```
  </Tab>

  <Tab title="Schema-less">
    ```typescript  theme={null}
    // String only extraction
    const title = await stagehand.extract("get the page title");
    // Returns: { extraction: "Page Title" }

    // Raw page content
    const content = await stagehand.extract();
    // Returns: { pageText: "Accessibility Tree: ..." }
    ```

    #### Example Response

    ```json  theme={null}
    {
      "extraction": "Page Title"
    }
    ```
  </Tab>

  <Tab title="Advanced">
    ```typescript  theme={null}
    import { z } from 'zod';

    // Schema with descriptions and validation
    const ProductSchema = z.object({
      price: z.number().describe("Product price in USD"),
      rating: z.number().min(0).max(5).describe("Customer rating out of 5"),
      available: z.boolean().describe("Whether product is in stock"),
      tags: z.array(z.string()).optional()
    });

    // Nested schema
    const EcommerceSchema = z.object({
      product: z.object({
        name: z.string(),
        price: z.object({
          current: z.number(),
          original: z.number().optional()
        })
      }),
      reviews: z.array(z.object({
        rating: z.number(),
        comment: z.string()
      }))
    });
    ```

    #### Example Response

    ```json  theme={null}
    {
      "product": {
        "name": "Product Name",
        "price": {
          "current": 100,
          "original": 120
        }
      },
      "reviews": [
        {
          "rating": 4,
          "comment": "Great product!"
        }
      ]
    }
    ```
  </Tab>
</Tabs>

### Additional Examples

<Tabs>
  <Tab title="Custom Model">
    ```typescript  theme={null}
    import { z } from 'zod';

    const DataSchema = z.object({
      title: z.string(),
      content: z.string()
    });

    // Using string format
    const data1 = await stagehand.extract(
      "extract article data",
      DataSchema,
      { model: "openai/gpt-5-mini" }
    );

    // Using object format with custom configuration
    const data2 = await stagehand.extract(
      "extract article data",
      DataSchema,
      {
        model: {
          modelName: "claude-3-5-sonnet-20241022",
          apiKey: process.env.ANTHROPIC_API_KEY
        }
      }
    );
    ```
  </Tab>

  <Tab title="Multi-Page">
    ```typescript  theme={null}
    import { z } from 'zod';

    const page1 = stagehand.context.pages()[0];
    const page2 = await stagehand.context.newPage();

    const Schema = z.object({ title: z.string() });

    const data1 = await stagehand.extract("get title", Schema, { page: page1 });
    const data2 = await stagehand.extract("get title", Schema, { page: page2 });
    ```
  </Tab>
</Tabs>

### Error Types

The following errors may be thrown by the `extract()` method:

* **StagehandError** - Base class for all Stagehand-specific errors
* **ZodSchemaValidationError** - Extracted data does not match the provided Zod schema
* **StagehandDomProcessError** - Error occurred while processing the DOM
* **StagehandEvalError** - Error occurred while evaluating JavaScript in the page context
* **StagehandIframeError** - Unable to resolve iframe for the target element
* **ContentFrameNotFoundError** - Unable to obtain content frame for the selector
* **XPathResolutionError** - XPath does not resolve in the current page or frames
* **StagehandShadowRootMissingError** - No shadow root present on the resolved host element
* **LLMResponseError** - Error in LLM response processing
* **MissingLLMConfigurationError** - No LLM API key or client configured
* **UnsupportedModelError** - The specified model is not supported for this operation
* **InvalidAISDKModelFormatError** - Model string does not follow the required `provider/model` format
# observe()

> Complete API reference for the observe() method

<CardGroup cols={1}>
  <Card title="Observe" icon="magnifying-glass" href="/v3/basics/observe">
    See how to use observe() to discover actionable elements and analyze web page structure
  </Card>
</CardGroup>

### Method Signatures

<Tabs>
  <Tab title="TypeScript">
    ```typescript  theme={null}
    // String instruction only
    await stagehand.observe(instruction: string): Promise<Action[]>

    // String instruction with options
    await stagehand.observe(instruction: string, options: ObserveOptions): Promise<Action[]>
    ```

    **ObserveOptions Interface:**

    ```typescript  theme={null}
    interface ObserveOptions {
      model?: ModelConfiguration;
      timeout?: number;
      selector?: string;
      page?: PlaywrightPage | PuppeteerPage | PatchrightPage | Page;
    }

    // ModelConfiguration can be either a string or an object
    type ModelConfiguration =
      | string  // Format: "provider/model" (e.g., "openai/gpt-4o", "anthropic/claude-3-5-sonnet-20241022")
      | {
          modelName: string;  // The model name
          apiKey?: string;    // Optional: API key override
          baseURL?: string;   // Optional: Base URL override
          // Additional provider-specific options
        }
    ```
  </Tab>
</Tabs>

### Parameters

<ParamField path="instruction" type="string" required>
  Natural language description of elements or actions to discover. If not provided, defaults to finding all interactive elements on the page.
</ParamField>

<ParamField path="model" type="ModelConfiguration" optional>
  Configure the AI model to use for this observation. Can be either:

  * A string in the format `"provider/model"` (e.g., `"openai/gpt-4o"`, `"anthropic/claude-3-5-sonnet-20241022"`)
  * An object with detailed configuration

  <Expandable title="Model Configuration Object">
    <ParamField path="modelName" type="string" required>
      The model name (e.g., "gpt-4o", "claude-3-5-sonnet-20241022", "gemini-2.5-flash")
    </ParamField>

    <ParamField path="apiKey" type="string" optional>
      API key for the model provider (overrides default)
    </ParamField>

    <ParamField path="baseURL" type="string" optional>
      Base URL for the API endpoint (for custom endpoints or proxies)
    </ParamField>
  </Expandable>
</ParamField>

<ParamField path="timeout" type="number" optional>
  Maximum time in milliseconds to wait for the observation to complete. Default varies by configuration.
</ParamField>

<ParamField path="selector" type="string" optional>
  Optional XPath selector to focus the observation on a specific part of the page. Useful for narrowing down the search area.
</ParamField>

<ParamField path="page" type="PlaywrightPage | PuppeteerPage | PatchrightPage | Page" optional>
  Optional: Specify which page to perform the observation on. Supports multiple browser automation libraries:

  * **Playwright**: Native Playwright Page objects
  * **Puppeteer**: Puppeteer Page objects
  * **Patchright**: Patchright Page objects
  * **Stagehand Page**: Stagehand's wrapped Page object

  If not specified, defaults to the current "active" page in your Stagehand instance.
</ParamField>

### Returns `Promise<Action[]>`

Array of discovered actionable elements, ordered by relevance.

<ResponseField name="selector" type="string">
  XPath selector that precisely locates the element on the page.
</ResponseField>

<ResponseField name="description" type="string">
  Human-readable description of the element and its purpose.
</ResponseField>

<ResponseField name="method" type="string" optional>
  Suggested interaction method for the element (e.g., `"click"`, `"fill"`, `"type"`).
</ResponseField>

<ResponseField name="arguments" type="string[]" optional>
  Additional parameters for the suggested action, if applicable.
</ResponseField>

**Action Interface:**

```typescript  theme={null}
interface Action {
  selector: string;        // XPath selector to locate element
  description: string;     // Human-readable description
  method?: string;         // Suggested action method
  arguments?: string[];    // Additional action parameters
}
```

**Example Response:**

```json  theme={null}
[
  {
    "selector": "/html/body/div[1]/header/nav/button[1]",
    "description": "Login button in the navigation bar",
    "method": "click",
    "arguments": []
  },
  {
    "selector": "/html/body/main/form/input[1]",
    "description": "Email input field in the login form",
    "method": "fill",
    "arguments": []
  }
]
```

### Built-in Support

<Note>
  **Iframe and Shadow DOM interactions are supported out of the box.** Stagehand automatically handles iframe traversal and shadow DOM elements without requiring additional configuration or flags.
</Note>

### Code Examples

<Tabs>
  <Tab title="Basic Usage">
    ```typescript  theme={null}
    import { Stagehand } from "@browserbasehq/stagehand";

    // Initialize with Browserbase (API key and project ID from environment variables)
    // Set BROWSERBASE_API_KEY and BROWSERBASE_PROJECT_ID in your environment
    const stagehand = new Stagehand({ env: "BROWSERBASE" });
    await stagehand.init();
    const page = stagehand.context.pages()[0];

    await page.goto("https://example.com");

    // Basic element discovery
    const buttons = await stagehand.observe("find all clickable buttons");
    const formFields = await stagehand.observe("locate form input fields");

    // Working with results
    const [loginButton] = await stagehand.observe("find the login button");
    if (loginButton) {
      console.log("Found:", loginButton.description);
      console.log("Selector:", loginButton.selector);
      await stagehand.act(loginButton); // Execute the action
    }
    ```
  </Tab>

  <Tab title="Custom Model">
    ```typescript  theme={null}
    // Using string format model
    const elements = await stagehand.observe("find important call-to-action buttons", {
      model: "openai/gpt-4o",
      timeout: 45000
    });

    // Using object format with custom configuration
    const actions = await stagehand.observe("find navigation links", {
      model: {
        modelName: "claude-3-5-sonnet-20241022",
        apiKey: process.env.ANTHROPIC_API_KEY
      },
      timeout: 30000
    });
    ```
  </Tab>

  <Tab title="Scoped">
    ```typescript  theme={null}
    // Focus observation on a specific part of the page
    const tableActions = await stagehand.observe("find all table rows", {
      selector: "/html/body/main/table"
    });
    ```
  </Tab>

  <Tab title="Multi-Page">
    ```typescript  theme={null}
    // Observe on specific pages
    const page1 = stagehand.context.pages()[0];
    const page2 = await stagehand.context.newPage();

    const page1Actions = await stagehand.observe("find navigation", { page: page1 });
    const page2Actions = await stagehand.observe("find buttons", { page: page2 });
    ```
  </Tab>

  <Tab title="Filter Results">
    ```typescript  theme={null}
    const submitButtons = await stagehand.observe("find all submit buttons");
    const primarySubmit = submitButtons.find(btn =>
      btn.description.toLowerCase().includes('primary')
    );
    ```
  </Tab>
</Tabs>

### Integration Patterns

```typescript  theme={null}
// Observe → Act workflow
const actions = await stagehand.observe("find checkout elements");
for (const action of actions) {
  await stagehand.act(action);
  await page.waitForTimeout(1000);
}

// Observe → Extract workflow
const tables = await stagehand.observe("find data tables");
if (tables.length > 0) {
  const data = await stagehand.extract({
    instruction: "extract the table data",
    selector: tables[0].selector,
    schema: DataSchema
  });
}

// Element validation
const requiredElements = await stagehand.observe("find the login form");
if (requiredElements.length === 0) {
  throw new Error("Login form not found");
}
```

### Error Types

The following errors may be thrown by the `observe()` method:

* **StagehandError** - Base class for all Stagehand-specific errors
* **StagehandDomProcessError** - Error occurred while processing the DOM
* **StagehandEvalError** - Error occurred while evaluating JavaScript in the page context
* **StagehandIframeError** - Unable to resolve iframe for the target element
* **ContentFrameNotFoundError** - Unable to obtain content frame for the selector
* **XPathResolutionError** - XPath does not resolve in the current page or frames
* **StagehandShadowRootMissingError** - No shadow root present on the resolved host element
* **LLMResponseError** - Error in LLM response processing
* **MissingLLMConfigurationError** - No LLM API key or client configured
* **UnsupportedModelError** - The specified model is not supported for this operation
* **InvalidAISDKModelFormatError** - Model string does not follow the required `provider/model` format
# agent()

> Complete API reference for the agent() method

<CardGroup cols={1}>
  <Card title="Agent" icon="robot" href="/v3/basics/agent">
    See how to use agent() to create autonomous AI agents for multi-step browser workflows
  </Card>
</CardGroup>

### Agent Creation

<Tabs>
  <Tab title="TypeScript">
    ```typescript  theme={null}
    // Create agent instance
    const agent = stagehand.agent(config?: AgentConfig): AgentInstance
    ```

    **AgentConfig Interface:**

    ```typescript  theme={null}
    interface AgentConfig {
      systemPrompt?: string;
      integrations?: (Client | string)[];
      tools?: ToolSet;
      cua?: boolean;
      model?: string | AgentModelConfig<string>;
      executionModel?: string | AgentModelConfig<string>;
    }

    // AgentModelConfig for advanced configuration
    type AgentModelConfig<TModelName extends string = string> = {
      modelName: TModelName;
    } & Record<string, unknown>;
    ```

    **AgentInstance Interface:**

    ```typescript  theme={null}
    interface AgentInstance {
      execute: (instructionOrOptions: string | AgentExecuteOptions) => Promise<AgentResult>;
    }
    ```
  </Tab>
</Tabs>

### Agent Configuration

<ParamField path="systemPrompt" type="string" optional>
  Custom system prompt to provide to the agent. Overrides the default system prompt and defines agent behavior.
</ParamField>

<ParamField path="model" type="string | AgentModelConfig" optional>
  The model to use for agent functionality. Can be either:

  * A string in the format `"provider/model"` (e.g., `"openai/computer-use-preview"`, `"anthropic/claude-sonnet-4-20250514"`)
  * An object with `modelName` and additional provider-specific options

  **Available CUA Models:**

  * `"openai/computer-use-preview"`
  * `"openai/computer-use-preview-2025-03-11"`
  * `"anthropic/claude-3-7-sonnet-latest"`
  * `"anthropic/claude-haiku-4-5-20251001"`
  * `"anthropic/claude-sonnet-4-20250514"`
  * `"anthropic/claude-sonnet-4-5-20250929"`
  * `"google/gemini-2.5-computer-use-preview-10-2025"`

  <Expandable title="AgentModelConfig Object">
    <ParamField path="modelName" type="string" required>
      The model name
    </ParamField>

    <ParamField path="[key: string]" type="unknown" optional>
      Additional provider-specific options (e.g., `apiKey`, `baseURL`)
    </ParamField>
  </Expandable>
</ParamField>

<ParamField path="executionModel" type="string | AgentModelConfig" optional>
  The model to use for tool execution (observe/act calls within agent tools). If not specified, inherits from the main model configuration.

  **Format:** `"provider/model"` (e.g., `"openai/gpt-4o-mini"`, `"google/gemini-2.0-flash-exp"`)
</ParamField>

<ParamField path="cua" type="boolean" optional>
  Indicates whether Computer Use Agent (CUA) mode is enabled. When false, the agent uses standard tool-based operation instead of computer control.
</ParamField>

<ParamField path="integrations" type="(Client | string)[]" optional>
  MCP (Model Context Protocol) integrations for external tools and services.

  **Array of:** MCP server URLs (strings) or connected Client objects
</ParamField>

<ParamField path="tools" type="ToolSet" optional>
  Custom tool definitions to extend agent capabilities using the AI SDK ToolSet format.
</ParamField>

### Execute Method

<Tabs>
  <Tab title="TypeScript">
    ```typescript  theme={null}
    // String instruction
    await agent.execute(instruction: string): Promise<AgentResult>

    // With options
    await agent.execute(options: AgentExecuteOptions): Promise<AgentResult>
    ```

    **AgentExecuteOptions Interface:**

    ```typescript  theme={null}
    interface AgentExecuteOptions {
      instruction: string;
      maxSteps?: number;
      page?: PlaywrightPage | PuppeteerPage | PatchrightPage | Page;
      highlightCursor?: boolean;
    }
    ```
  </Tab>
</Tabs>

### Execute Parameters

<ParamField path="instruction" type="string" required>
  High-level task description in natural language.
</ParamField>

<ParamField path="maxSteps" type="number" optional>
  Maximum number of actions the agent can take before stopping.

  **Default:** Varies by configuration
</ParamField>

<ParamField path="page" type="PlaywrightPage | PuppeteerPage | PatchrightPage | Page" optional>
  Optional: Specify which page to perform the agent execution on. Supports multiple browser automation libraries:

  * **Playwright**: Native Playwright Page objects
  * **Puppeteer**: Puppeteer Page objects
  * **Patchright**: Patchright Page objects
  * **Stagehand Page**: Stagehand's wrapped Page object

  If not specified, defaults to the current "active" page in your Stagehand instance.
</ParamField>

<ParamField path="highlightCursor" type="boolean" optional>
  Whether to show a visual cursor on the page during agent execution. Useful for debugging and demonstrations.

  **Default:** `false`
</ParamField>

### Response

**Returns:** `Promise<AgentResult>`

**AgentResult Interface:**

```typescript  theme={null}
interface AgentResult {
  success: boolean;
  message: string;
  actions: AgentAction[];
  completed: boolean;
  metadata?: Record<string, unknown>;
  usage?: {
    input_tokens: number;
    output_tokens: number;
    reasoning_tokens?: number;
    cached_input_tokens?: number;
    inference_time_ms: number;
  };
}

// AgentAction can contain various tool-specific fields
interface AgentAction {
  type: string;
  reasoning?: string;
  taskCompleted?: boolean;
  action?: string;
  timeMs?: number;        // wait tool
  pageText?: string;      // ariaTree tool
  pageUrl?: string;       // ariaTree tool
  instruction?: string;   // various tools
  [key: string]: unknown; // Additional tool-specific fields
}
```

<ResponseField name="success" type="boolean">
  Whether the task was completed successfully.
</ResponseField>

<ResponseField name="message" type="string">
  Description of the execution result and status.
</ResponseField>

<ResponseField name="actions" type="AgentAction[]">
  Array of individual actions taken during execution. Each action contains tool-specific data.
</ResponseField>

<ResponseField name="completed" type="boolean">
  Whether the agent believes the task is fully complete.
</ResponseField>

<ResponseField name="metadata" type="Record<string, unknown>" optional>
  Additional execution metadata and debugging information.
</ResponseField>

<ResponseField name="usage" type="object" optional>
  Token usage and performance metrics.

  <Expandable title="Usage Metrics">
    <ResponseField name="input_tokens" type="number">
      Number of input tokens used
    </ResponseField>

    <ResponseField name="output_tokens" type="number">
      Number of output tokens generated
    </ResponseField>

    <ResponseField name="reasoning_tokens" type="number" optional>
      Number of reasoning tokens (if supported by the model)
    </ResponseField>

    <ResponseField name="cached_input_tokens" type="number" optional>
      Number of cached input tokens (if supported by the model)
    </ResponseField>

    <ResponseField name="inference_time_ms" type="number">
      Total inference time in milliseconds
    </ResponseField>
  </Expandable>
</ResponseField>

### Example Response

```json  theme={null}
{
  "success": true,
  "message": "Task completed successfully",
  "actions": [
    {
      "type": "act",
      "instruction": "click the submit button",
      "reasoning": "User requested to submit the form",
      "taskCompleted": false
    },
    {
      "type": "observe",
      "instruction": "check if submission was successful",
      "taskCompleted": true
    }
  ],
  "completed": true,
  "metadata": {
    "steps_taken": 2
  },
  "usage": {
    "input_tokens": 1250,
    "output_tokens": 340,
    "reasoning_tokens": 42,
    "cached_input_tokens": 0,
    "inference_time_ms": 2500
  }
}
```

### Code Examples

<Tabs>
  <Tab title="Basic Usage">
    ```typescript  theme={null}
    import { Stagehand } from "@browserbasehq/stagehand";

    // Initialize with Browserbase (API key and project ID from environment variables)
    // Set BROWSERBASE_API_KEY and BROWSERBASE_PROJECT_ID in your environment
    const stagehand = new Stagehand({
      env: "BROWSERBASE",
      model: "anthropic/claude-sonnet-4-20250514"
    });
    await stagehand.init();

    const page = stagehand.context.pages()[0];
    // Create agent with default configuration
    const agent = stagehand.agent();

    // Navigate to a page
    await page.goto("https://www.google.com");

    // Execute a task
    const result = await agent.execute("Search for 'Stagehand automation' and click the first result");

    console.log(result.message);
    console.log(`Completed: ${result.completed}`);
    console.log(`Actions taken: ${result.actions.length}`);
    ```
  </Tab>

  <Tab title="Custom Configuration">
    ```typescript  theme={null}
    // Create agent with custom model and system prompt
    const agent = stagehand.agent({
      model: "openai/computer-use-preview",
      systemPrompt: "You are a helpful assistant that can navigate websites efficiently. Always verify actions before proceeding.",
      executionModel: "openai/gpt-4o-mini"  // Use faster model for tool execution
    });

    const page = stagehand.context.pages()[0];
    await page.goto("https://example.com");

    const result = await agent.execute({
      instruction: "Fill out the contact form with test data",
      maxSteps: 10,
      highlightCursor: true
    });
    ```
  </Tab>

  <Tab title="Advanced Model Config">
    ```typescript  theme={null}
    // Using AgentModelConfig for advanced configuration
    const agent = stagehand.agent({
      model: {
        modelName: "anthropic/claude-sonnet-4-20250514",
        apiKey: process.env.ANTHROPIC_API_KEY,
        baseURL: "https://custom-proxy.com/v1"
      }
    });

    const result = await agent.execute("Complete the checkout process");
    ```
  </Tab>

  <Tab title="Multi-Page">
    ```typescript  theme={null}
    const page1 = stagehand.context.pages()[0];
    const page2 = await stagehand.context.newPage();

    const agent = stagehand.agent();

    // Execute on specific page
    await page2.goto("https://example.com/dashboard");
    const result = await agent.execute({
      instruction: "Export the data table",
      page: page2
    });
    ```
  </Tab>

  <Tab title="MCP Integrations">
    ```typescript  theme={null}
    import { Client } from "@modelcontextprotocol/sdk/client/index.js";

    // Create agent with MCP integrations
    const agent = stagehand.agent({
      model: "anthropic/claude-sonnet-4-20250514",
      integrations: [
        "https://mcp-server.example.com",  // MCP server URL
        mcpClientInstance  // Or pre-connected Client object
      ]
    });

    const result = await agent.execute("Use the external tool to process this data");
    ```
  </Tab>

  <Tab title="Custom Tools">
    ```typescript  theme={null}
    import { tool } from "ai";
    import { z } from "zod/v3";

    // Define custom tools using AI SDK format
    const customTools = {
      calculateTotal: tool({
        description: "Calculate the total of items in cart",
        parameters: z.object({
          items: z.array(z.object({
            price: z.number(),
            quantity: z.number()
          }))
        }),
        execute: async ({ items }) => {
          const total = items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
          return { total };
        }
      })
    };

    const agent = stagehand.agent({
      model: "openai/computer-use-preview",
      tools: customTools
    });

    const result = await agent.execute("Calculate the total cost of items in the shopping cart");
    ```
  </Tab>
</Tabs>

### Error Types

The following errors may be thrown by the `agent()` method:

* **StagehandError** - Base class for all Stagehand-specific errors
* **StagehandInitError** - Agent was not properly initialized
* **MissingLLMConfigurationError** - No LLM API key or client configured
* **UnsupportedModelError** - The specified model is not supported for agent functionality
* **UnsupportedModelProviderError** - The specified model provider is not supported
* **InvalidAISDKModelFormatError** - Model string does not follow the required `provider/model` format
* **MCPConnectionError** - Failed to connect to MCP server
* **StagehandDefaultError** - General execution error with detailed message
# context

> Complete API reference for the browser context

<CardGroup cols={1}>
  <Card title="Stagehand" icon="wand-magic-sparkles" href="/v3/references/stagehand">
    Learn about the main Stagehand object
  </Card>
</CardGroup>

## Overview

The `context` object manages the browser context, which is a container for multiple pages (tabs). It provides methods for creating new pages, accessing existing pages, and managing which page is currently active.

Access the context through your Stagehand instance:

```typescript  theme={null}
const stagehand = new Stagehand({ env: "BROWSERBASE" });
await stagehand.init();
const context = stagehand.context;
```

## Methods

### newPage()

Create a new page (tab) in the browser.

```typescript  theme={null}
await context.newPage(url?: string): Promise<Page>
```

<ParamField path="url" type="string" optional>
  The URL to navigate to in the new page.

  **Default:** `"about:blank"`
</ParamField>

**Returns:** `Promise<Page>` - The newly created page object.

The new page is automatically set as the active page.

### pages()

Get all open pages in the browser context.

```typescript  theme={null}
context.pages(): Page[]
```

**Returns:** `Page[]` - Array of all open pages, ordered from oldest to newest.

### activePage()

Get the currently active page.

```typescript  theme={null}
context.activePage(): Page | undefined
```

**Returns:** `Page | undefined` - The most recently used page, or `undefined` if no pages exist.

The active page is determined by:

1. Most recently interacted with page
2. Most recently created page if no interaction history
3. `undefined` if all pages have been closed

### setActivePage()

Set a specific page as the active page.

```typescript  theme={null}
context.setActivePage(page: Page): void
```

<ParamField path="page" type="Page" required>
  The page to set as active. Must be a page that exists in this context.
</ParamField>

This method:

* Marks the page as most recently used
* Brings the tab to the foreground (in headed mode)
* Makes it the default page for subsequent operations

### close()

Close the browser context and all associated pages.

```typescript  theme={null}
await context.close(): Promise<void>
```

This method:

* Closes the CDP connection
* Cleans up all pages
* Clears all internal mappings

**Note:** This is typically called internally by `stagehand.close()`. You usually don't need to call this directly.

## Code Examples

<Tabs>
  <Tab title="Basic Usage">
    ```typescript  theme={null}
    import { Stagehand } from "@browserbasehq/stagehand";

    // Initialize with Browserbase (API key and project ID from environment variables)
    // Set BROWSERBASE_API_KEY and BROWSERBASE_PROJECT_ID in your environment
    const stagehand = new Stagehand({ env: "BROWSERBASE" });
    await stagehand.init();
    const context = stagehand.context;

    // Create a new page
    const page1 = await context.newPage("https://example.com");
    console.log("Created page 1");

    // Create another page
    const page2 = await context.newPage("https://another-site.com");
    console.log("Created page 2");

    // Get all pages
    const allPages = context.pages();
    console.log(`Total pages: ${allPages.length}`);

    await stagehand.close();
    ```
  </Tab>

  <Tab title="Multi-Page Workflow">
    ```typescript  theme={null}
    import { Stagehand } from "@browserbasehq/stagehand";

    const stagehand = new Stagehand({ env: "LOCAL" });
    await stagehand.init();
    const context = stagehand.context;

    // Start with main page
    const mainPage = context.pages()[0];
    await mainPage.goto("https://example.com");

    // Open additional pages
    const dashboardPage = await context.newPage("https://example.com/dashboard");
    const settingsPage = await context.newPage("https://example.com/settings");

    // Work with specific page
    context.setActivePage(dashboardPage);
    await stagehand.act("click the export button");

    // Switch to another page
    context.setActivePage(settingsPage);
    await stagehand.act("enable notifications");

    // Back to main page
    context.setActivePage(mainPage);
    await stagehand.act("click the logout button");

    await stagehand.close();
    ```
  </Tab>

  <Tab title="Page Management">
    ```typescript  theme={null}
    import { Stagehand } from "@browserbasehq/stagehand";

    const stagehand = new Stagehand({ env: "LOCAL" });
    await stagehand.init();
    const context = stagehand.context;

    // Create multiple pages
    const pages = await Promise.all([
      context.newPage("https://site1.com"),
      context.newPage("https://site2.com"),
      context.newPage("https://site3.com"),
    ]);

    console.log(`Opened ${pages.length} pages`);

    // Get the active page
    const active = context.activePage();
    console.log(`Active page URL: ${active?.url()}`);

    // Iterate through all pages
    for (const page of context.pages()) {
      console.log(`Page URL: ${page.url()}`);
      console.log(`Page title: ${await page.title()}`);
    }

    await stagehand.close();
    ```
  </Tab>

  <Tab title="Parallel Operations">
    ```typescript  theme={null}
    import { Stagehand } from "@browserbasehq/stagehand";
    import { z } from "zod/v3";

    const stagehand = new Stagehand({ env: "LOCAL" });
    await stagehand.init();
    const context = stagehand.context;

    // Create pages for different sites
    const page1 = await context.newPage("https://site1.com");
    const page2 = await context.newPage("https://site2.com");
    const page3 = await context.newPage("https://site3.com");

    const schema = z.object({
      title: z.string(),
      description: z.string()
    });

    // Extract data from all pages in parallel
    const results = await Promise.all([
      stagehand.extract("get page info", schema, { page: page1 }),
      stagehand.extract("get page info", schema, { page: page2 }),
      stagehand.extract("get page info", schema, { page: page3 })
    ]);

    console.log("Extracted data:", results);

    await stagehand.close();
    ```
  </Tab>

  <Tab title="Active Page Tracking">
    ```typescript  theme={null}
    import { Stagehand } from "@browserbasehq/stagehand";

    const stagehand = new Stagehand({ env: "LOCAL" });
    await stagehand.init();
    const context = stagehand.context;

    // Create pages
    const homePage = await context.newPage("https://example.com");
    const aboutPage = await context.newPage("https://example.com/about");
    const contactPage = await context.newPage("https://example.com/contact");

    // The last created page (contactPage) is now active
    console.log("Active:", context.activePage()?.url());
    // Output: "https://example.com/contact"

    // Switch to home page
    context.setActivePage(homePage);
    console.log("Active:", context.activePage()?.url());
    // Output: "https://example.com"

    // Now act on the active page (homePage)
    await stagehand.act("click the header link");

    await stagehand.close();
    ```
  </Tab>
</Tabs>

## Working with Active Pages

The context tracks which page is currently active:

```typescript  theme={null}
const stagehand = new Stagehand({ env: "LOCAL" });
await stagehand.init();

// Get the current active page
const activePage = stagehand.context.activePage();

// Create a new page - it becomes active
const newPage = await stagehand.context.newPage();

// Now context.activePage() returns newPage
await newPage.goto("https://example.com");
```

## Relationship Between Context and Page

* **Context** manages the browser-level state and multiple pages
* **Page** represents a single tab/window with content
* Creating a new page via `context.newPage()` automatically sets it as active
* You can explicitly control the active page with `context.setActivePage()`
* Use `context.activePage()` to get the currently active page

```typescript  theme={null}
// Get the active page
const activePage = stagehand.context.activePage();

// Or get the first page directly
const firstPage = stagehand.context.pages()[0];
```

## Best Practices

1. **Create pages explicitly** - Use `context.newPage()` instead of relying on popups or window\.open
2. **Track page references** - Store page objects in variables for easier management
3. **Set active page before operations** - Ensure the correct page is active before calling Stagehand methods
4. **Clean up properly** - Call `stagehand.close()` to close all pages and the context
5. **Handle page order** - Remember that `context.pages()` returns pages in creation order
6. **Use parallel operations** - Work with multiple pages simultaneously for better performance

## Common Patterns

### Tab Management

```typescript  theme={null}
// Keep track of pages by purpose
const pages = {
  home: await context.newPage("https://example.com"),
  dashboard: await context.newPage("https://example.com/dashboard"),
  settings: await context.newPage("https://example.com/settings")
};

// Switch between tabs
context.setActivePage(pages.dashboard);
await stagehand.act("view report");

context.setActivePage(pages.settings);
await stagehand.act("update preferences");
```

### Bulk Data Collection

```typescript  theme={null}
const urls = [
  "https://site1.com",
  "https://site2.com",
  "https://site3.com"
];

// Open all pages
const pages = await Promise.all(
  urls.map(url => context.newPage(url))
);

// Extract data from each
const data = await Promise.all(
  pages.map(page => stagehand.extract("get data", schema, { page }))
);
```

### Conditional Page Management

```typescript  theme={null}
// Only create a page if needed
if (needsDashboard) {
  const dashboard = await context.newPage("https://example.com/dashboard");
  context.setActivePage(dashboard);
  await stagehand.act("generate report");
}

// Check if we have multiple pages
if (context.pages().length > 1) {
  console.log("Multiple tabs open");
}
```

## Error Handling

Context methods may throw the following errors:

* **Timeout errors** - `newPage()` timeout waiting for page to attach
* **CDP errors** - Connection errors with Chrome DevTools Protocol
* **Invalid page errors** - Attempting to set an active page that doesn't exist in the context

Always handle errors appropriately:

```typescript  theme={null}
try {
  const page = await context.newPage("https://example.com");
} catch (error) {
  console.error("Failed to create page:", error.message);
}
```

## Type Definitions

```typescript  theme={null}
interface V3Context {
  newPage(url?: string): Promise<Page>;
  pages(): Page[];
  activePage(): Page | undefined;
  setActivePage(page: Page): void;
  close(): Promise<void>;
}
```
# page

> Complete API reference for the Stagehand Page object

<CardGroup cols={1}>
  <Card title="Page" icon="browser" href="/v3/references/page">
    Learn about the Stagehand Page object and browser navigation
  </Card>
</CardGroup>

## Overview

The `page` object is the main interface for interacting with browser pages in Stagehand. It provides standard browser automation capabilities for navigation, interaction, and page inspection.

Access the page object through your Stagehand instance:

```typescript  theme={null}
const stagehand = new Stagehand({ env: "LOCAL" });
await stagehand.init();
const page = stagehand.context.pages()[0];
```

## Navigation Methods

### goto()

Navigate the page to a URL and wait for a lifecycle state.

```typescript  theme={null}
await page.goto(url: string, options?: GotoOptions): Promise<Response | null>
```

Returns a [Response](/v3/references/response) when the navigation produces a network document request, otherwise `null` (e.g. `data:` URLs or same-document navigations).

<ParamField path="url" type="string" required>
  The URL to navigate to. Can be absolute or relative.
</ParamField>

<ParamField path="waitUntil" type="LoadState" optional>
  When to consider navigation succeeded.

  **Options:**

  * `"load"` - Wait for the load event
  * `"domcontentloaded"` - Wait for DOMContentLoaded event (default)
  * `"networkidle"` - Wait for network to be idle

  **Default:** `"domcontentloaded"`
</ParamField>

<ParamField path="timeoutMs" type="number" optional>
  Maximum time to wait for navigation in milliseconds.

  **Default:** `15000`
</ParamField>

### reload()

Reload the current page.

```typescript  theme={null}
await page.reload(options?: ReloadOptions): Promise<Response | null>
```

Resolves with a [Response](/v3/references/response) for the refreshed document when one is reported, otherwise `null`.

<ParamField path="waitUntil" type="LoadState" optional>
  When to consider reload complete. See `goto()` for options.
</ParamField>

<ParamField path="timeoutMs" type="number" optional>
  Maximum time to wait for reload in milliseconds.

  **Default:** `15000`
</ParamField>

<ParamField path="ignoreCache" type="boolean" optional>
  Whether to bypass the browser cache.

  **Default:** `false`
</ParamField>

### goBack()

Navigate back in browser history.

```typescript  theme={null}
await page.goBack(options?: NavigationOptions): Promise<Response | null>
```

Returns a [Response](/v3/references/response) when the history entry triggers a network fetch; otherwise `null`.

<ParamField path="waitUntil" type="LoadState" optional>
  When to consider navigation complete.
</ParamField>

<ParamField path="timeoutMs" type="number" optional>
  Maximum time to wait in milliseconds.

  **Default:** `15000`
</ParamField>

### goForward()

Navigate forward in browser history.

```typescript  theme={null}
await page.goForward(options?: NavigationOptions): Promise<Response | null>
```

Returns a [Response](/v3/references/response) when the navigation loads a new document from the network; otherwise `null`.

<ParamField path="waitUntil" type="LoadState" optional>
  When to consider navigation complete.
</ParamField>

<ParamField path="timeoutMs" type="number" optional>
  Maximum time to wait in milliseconds.

  **Default:** `15000`
</ParamField>

## Page Information

### url()

Get the current page URL (synchronous).

```typescript  theme={null}
page.url(): string
```

**Returns:** The current page URL as a string.

### title()

Get the current page title.

```typescript  theme={null}
await page.title(): Promise<string>
```

**Returns:** The page title as a string.

## Interaction Methods

### click()

Click at absolute page coordinates.

```typescript  theme={null}
await page.click(x: number, y: number, options?: ClickOptions): Promise<void | string>
```

<ParamField path="x" type="number" required>
  X coordinate in CSS pixels.
</ParamField>

<ParamField path="y" type="number" required>
  Y coordinate in CSS pixels.
</ParamField>

<ParamField path="options" type="object" optional>
  Optional click configuration.

  <Expandable title="properties">
    <ParamField path="button" type="string">
      Mouse button to use: `"left"` | `"right"` | `"middle"`

      Default: `"left"`
    </ParamField>

    <ParamField path="clickCount" type="number">
      Number of consecutive clicks.

      Default: `1`
    </ParamField>

    <ParamField path="returnXpath" type="boolean">
      If `true`, returns the XPath of the clicked element instead of void.

      Default: `false`
    </ParamField>
  </Expandable>
</ParamField>

### type()

Type text into the page (dispatches keyboard events).

```typescript  theme={null}
await page.type(text: string, options?: TypeOptions): Promise<void>
```

<ParamField path="text" type="string" required>
  The text to type.
</ParamField>

<ParamField path="options" type="object" optional>
  Optional typing configuration.

  <Expandable title="properties">
    <ParamField path="delay" type="number">
      Delay between key presses in milliseconds.
    </ParamField>

    <ParamField path="withMistakes" type="boolean">
      Simulates typing with occasional mistakes and corrections.

      Default: `false`
    </ParamField>
  </Expandable>
</ParamField>

### locator()

Create a locator for querying elements.

```typescript  theme={null}
page.locator(selector: string): Locator
```

<ParamField path="selector" type="string" required>
  CSS selector or XPath for the element.
</ParamField>

**Returns:** A `Locator` object for interacting with the element.

## Evaluation

### evaluate()

Evaluate JavaScript code in the page context.

```typescript  theme={null}
await page.evaluate<R, Arg>(
  pageFunctionOrExpression: string | ((arg: Arg) => R | Promise<R>),
  arg?: Arg
): Promise<R>
```

<ParamField path="pageFunctionOrExpression" type="string | function" required>
  JavaScript expression as a string or a function to execute in the page context.
</ParamField>

<ParamField path="arg" type="any" optional>
  Optional argument to pass to the function.
</ParamField>

**Returns:** The result of the evaluation (must be JSON-serializable).

## Screenshot

### screenshot()

Capture a screenshot of the page.

```typescript  theme={null}
await page.screenshot(options?: ScreenshotOptions): Promise<Buffer>
```

<ParamField path="fullPage" type="boolean" optional>
  Capture the entire scrollable page instead of just the current viewport.

  **Default:** `false`
</ParamField>

<ParamField path="clip" type="ScreenshotClip" optional>
  Limit the capture to the provided rectangle in CSS pixels (`{ x, y, width, height }`).
  Cannot be combined with `fullPage`.
</ParamField>

<ParamField path="type" type="'png' | 'jpeg'" optional>
  Image format for the screenshot.

  **Default:** `"png"`
</ParamField>

<ParamField path="quality" type="number" optional>
  JPEG quality (0–100). Only used when `type` is `"jpeg"`.
</ParamField>

<ParamField path="scale" type="'css' | 'device'" optional>
  Rendering scale. Use `"css"` for one pixel per CSS pixel, or `"device"` for the
  device pixel ratio.

  **Default:** `"device"`
</ParamField>

<ParamField path="animations" type="'allow' | 'disabled'" optional>
  Control CSS/Web animations and transitions. `"disabled"` fast-forwards finite
  animations and pauses infinite ones before capture.

  **Default:** `"allow"`
</ParamField>

<ParamField path="caret" type="hide | initial" optional>
  Hide the text caret during capture (`"hide"`) or leave it untouched (`"initial"`).

  **Default:** `"hide"`
</ParamField>

<ParamField path="mask" type="Locator[]" optional>
  List of locators to cover with a colored overlay while the screenshot is taken.
</ParamField>

<ParamField path="maskColor" type="string" optional>
  CSS color to use for masked overlays.

  **Default:** `#FF00FF`
</ParamField>

<ParamField path="style" type="string" optional>
  Additional CSS text injected into every frame just before capture. Useful for
  hiding or tweaking dynamic UI.
</ParamField>

<ParamField path="omitBackground" type="boolean" optional>
  Make the default page background transparent (PNG only).

  **Default:** `false`
</ParamField>

<ParamField path="timeout" type="number" optional>
  Maximum time in milliseconds to wait for the capture before throwing.
</ParamField>

<ParamField path="path" type="string" optional>
  Write the screenshot to the provided file path. The image is still returned as
  a buffer.
</ParamField>

**Returns:** A `Promise<Buffer>` containing the screenshot image data.

## Viewport

### setViewportSize()

Set the page viewport size.

```typescript  theme={null}
await page.setViewportSize(
  width: number,
  height: number,
  options?: ViewportOptions
): Promise<void>
```

<ParamField path="width" type="number" required>
  Viewport width in CSS pixels.
</ParamField>

<ParamField path="height" type="number" required>
  Viewport height in CSS pixels.
</ParamField>

<ParamField path="deviceScaleFactor" type="number" optional>
  Device scale factor (pixel ratio).

  **Default:** `1`
</ParamField>

## Wait Methods

### waitForLoadState()

Wait for the page to reach a specific lifecycle state.

```typescript  theme={null}
await page.waitForLoadState(state: LoadState, timeoutMs?: number): Promise<void>
```

<ParamField path="state" type="LoadState" required>
  The lifecycle state to wait for.

  **Options:** `"load"`, `"domcontentloaded"`, `"networkidle"`
</ParamField>

<ParamField path="timeoutMs" type="number" optional>
  Maximum time to wait in milliseconds.

  **Default:** `15000`
</ParamField>

## Events

### on("console")

Listen for console output produced by the page and any adopted iframe sessions. Returns the page instance so calls can be chained.

```typescript  theme={null}
import type { ConsoleMessage } from "@browserbasehq/stagehand";

const handleConsole = (message: ConsoleMessage) => {
  console.log(`[${message.type()}] ${message.text()}`);
  console.log("Arguments:", message.args());
  const location = message.location();
  if (location?.url) {
    console.log(`Emitted from ${location.url}:${location.lineNumber ?? 0}`);
  }
};

page.on("console", handleConsole);
```

`ConsoleMessage` exposes helpers for working with console events:

* `message.type()` – console API category such as `log`, `error`, or `warning`
* `message.text()` – string representation of the console arguments
* `message.args()` – underlying CDP `RemoteObject` arguments array
* `message.location()` – source URL, line, and column when available
* `message.timestamp()` – CDP timestamp for the event
* `message.raw()` – access to the original `Runtime.consoleAPICalledEvent`

### once("console")

Register a listener that removes itself after the first console event.

```typescript  theme={null}
page.once("console", (message) => {
  console.log("First console message:", message.text());
});
```

### off("console")

Remove a previously registered listener. The reference must match the original listener passed to `on()`.

```typescript  theme={null}
page.off("console", handleConsole);
```

## Code Examples

<Tabs>
  <Tab title="Basic Navigation">
    ```typescript  theme={null}
    import { Stagehand } from "@browserbasehq/stagehand";

    // Initialize with Browserbase (API key and project ID from environment variables)
    // Set BROWSERBASE_API_KEY and BROWSERBASE_PROJECT_ID in your environment
    const stagehand = new Stagehand({ env: "BROWSERBASE" });
    await stagehand.init();
    const page = stagehand.context.pages()[0];

    // Navigate to a URL
    await page.goto("https://example.com");

    // Get current URL and title
    console.log("URL:", page.url());
    console.log("Title:", await page.title());

    // Navigate back and forward
    await page.goBack();
    await page.goForward();

    // Reload the page
    await page.reload();
    ```
  </Tab>

  <Tab title="Screenshots">
    ```typescript  theme={null}
    // Capture viewport screenshot
    const screenshot = await page.screenshot();
    await fs.writeFile("screenshot.png", screenshot);

    // Capture full page screenshot
    const fullPage = await page.screenshot({ fullPage: true });
    await fs.writeFile("fullpage.png", fullPage);

    // Capture JPEG with styling overrides and a masked element
    const styled = await page.screenshot({
      type: "jpeg",
      quality: 80,
      style: "body { filter: grayscale(1); }",
      mask: [page.locator(".ads-banner")],
      maskColor: "rgba(0, 0, 0, 0.3)",
    });
    await fs.writeFile("styled.jpg", styled);
    ```
  </Tab>

  <Tab title="JavaScript Evaluation">
    ```typescript  theme={null}
    // Execute JavaScript expression
    const pageHeight = await page.evaluate("document.body.scrollHeight");
    console.log("Page height:", pageHeight);

    // Execute function with arguments
    const result = await page.evaluate((selector) => {
      const element = document.querySelector(selector);
      return element ? element.textContent : null;
    }, "h1");
    console.log("H1 text:", result);

    // Async function evaluation
    const data = await page.evaluate(async () => {
      const response = await fetch("/api/data");
      return response.json();
    });
    ```
  </Tab>

  <Tab title="Interaction">
    ```typescript  theme={null}
    // Click at coordinates
    await page.click(100, 200);

    // Double click
    await page.click(100, 200, { clickCount: 2 });

    // Type text
    await page.type("Hello, World!");

    // Type with delay between keystrokes
    await page.type("Slow typing", { delay: 100 });

    // Use locator for element interaction
    const button = page.locator("button.submit");
    await button.click();
    ```
  </Tab>

  <Tab title="Wait for Load">
    ```typescript  theme={null}
    // Navigate and wait for full load
    await page.goto("https://example.com", {
      waitUntil: "load",
      timeoutMs: 30000
    });

    // Wait for network idle after navigation
    await page.goto("https://spa-app.com", {
      waitUntil: "networkidle"
    });

    // Wait for specific load state
    await page.waitForLoadState("domcontentloaded");
    ```
  </Tab>

  <Tab title="Viewport">
    ```typescript  theme={null}
    // Set viewport size
    await page.setViewportSize(1920, 1080);

    // Set mobile viewport with device scale
    await page.setViewportSize(375, 667, {
      deviceScaleFactor: 2
    });

    // Then take a screenshot at this size
    const screenshot = await page.screenshot();
    ```
  </Tab>
</Tabs>

## Types

### LoadState

```typescript  theme={null}
type LoadState = "load" | "domcontentloaded" | "networkidle";
```

* **`"load"`** - Wait for the `load` event (all resources loaded)
* **`"domcontentloaded"`** - Wait for the `DOMContentLoaded` event (DOM is ready)
* **`"networkidle"`** - Wait for network connections to be idle

### AnyPage

```typescript  theme={null}
type AnyPage = PlaywrightPage | PuppeteerPage | PatchrightPage | Page;
```

Stagehand supports multiple browser automation libraries. The `AnyPage` type represents any compatible page object.

### ScreenshotClip

```typescript  theme={null}
interface ScreenshotClip {
  x: number;
  y: number;
  width: number;
  height: number;
}
```

Represents the CSS-pixel rectangle to capture when `clip` is provided.

### ScreenshotOptions

```typescript  theme={null}
interface ScreenshotOptions {
  fullPage?: boolean;
  clip?: ScreenshotClip;
  type?: "png" | "jpeg";
  quality?: number;
  scale?: "css" | "device";
  animations?: "allow" | "disabled";
  caret?: "hide" | "initial";
  mask?: Locator[];
  maskColor?: string;
  style?: string;
  omitBackground?: boolean;
  timeout?: number;
  path?: string;
}
```

Matches Playwright's screenshot signature with sensible defaults to control how a
capture is produced.

## Error Handling

Page methods may throw the following errors:

* **Navigation Errors** - Timeout or network issues during navigation
* **Evaluation Errors** - JavaScript execution errors in `evaluate()`
* **Interaction Errors** - Failed clicks or typing operations
* **Screenshot Errors** - Issues capturing screenshots

All errors should be caught and handled appropriately:

```typescript  theme={null}
try {
  await page.goto("https://example.com");
} catch (error) {
  console.error("Navigation failed:", error.message);
}
```
# locator

> Complete API reference for the Locator class

<CardGroup cols={1}>
  <Card title="Page" icon="browser" href="/v3/references/page">
    Learn about the Page object that creates locators
  </Card>
</CardGroup>

## Overview

The `Locator` class provides precise element interaction capabilities. It resolves CSS or XPath selectors within a frame and performs low-level actions using Chrome DevTools Protocol (CDP).

Create a locator through the page object:

```typescript  theme={null}
const stagehand = new Stagehand({ env: "LOCAL" });
await stagehand.init();
const page = stagehand.context.pages()[0];

// Create a locator
const button = page.locator("button.submit");
await button.click();
```

## Key Features

* **Lazy resolution** - Selectors are resolved fresh on each action
* **Isolated execution** - Runs in an isolated world, separate from page scripts
* **CDP-based** - Uses Chrome DevTools Protocol for reliable interactions
* **Automatic cleanup** - Releases remote objects automatically
* **Iframe support** - Works seamlessly with iframes and shadow DOM

## Interaction Methods

### click()

Click the element at its visual center.

```typescript  theme={null}
await locator.click(options?: ClickOptions): Promise<void>
```

<ParamField path="button" type="&#x22;left&#x22; | &#x22;right&#x22; | &#x22;middle&#x22;" optional>
  Mouse button to use for the click.

  **Default:** `"left"`
</ParamField>

<ParamField path="clickCount" type="number" optional>
  Number of consecutive clicks (for double-click, triple-click).

  **Default:** `1`
</ParamField>

The method:

1. Scrolls element into view
2. Gets element geometry
3. Moves mouse to center
4. Dispatches mousePressed and mouseReleased events

### fill()

Fill an input, textarea, or contenteditable element.

```typescript  theme={null}
await locator.fill(value: string): Promise<void>
```

<ParamField path="value" type="string" required>
  The text value to fill into the element.
</ParamField>

The method intelligently handles different input types:

* Uses native value setter for special inputs (date, number, etc.)
* Types text character-by-character for regular inputs
* Clears existing content before filling

### type()

Type text into the element with optional delay between keystrokes.

```typescript  theme={null}
await locator.type(text: string, options?: TypeOptions): Promise<void>
```

<ParamField path="text" type="string" required>
  The text to type.
</ParamField>

<ParamField path="delay" type="number" optional>
  Delay in milliseconds between each keystroke.

  If not specified, uses `Input.insertText` for efficiency.
</ParamField>

### hover()

Move the mouse cursor to the element's center without clicking.

```typescript  theme={null}
await locator.hover(): Promise<void>
```

Scrolls the element into view and dispatches a mouse move event.

### selectOption()

Select one or more options in a `<select>` element.

```typescript  theme={null}
await locator.selectOption(values: string | string[]): Promise<string[]>
```

<ParamField path="values" type="string | string[]" required>
  Option value(s) to select. For multi-select elements, pass an array.
</ParamField>

**Returns:** `Promise<string[]>` - Array of values that were actually selected.

### setInputFiles()

Set files on an `<input type="file">` element.

```typescript  theme={null}
await locator.setInputFiles(files: FileInput): Promise<void>
```

<ParamField path="files" type="string | string[] | FilePayload | FilePayload[]" required>
  File paths or file payloads to upload.

  **File Path:** Absolute or relative path to a file

  **File Payload:** Object with `{ name, mimeType, buffer }`
</ParamField>

**FilePayload Interface:**

```typescript  theme={null}
interface FilePayload {
  name: string;
  mimeType: string;
  buffer: ArrayBuffer | Uint8Array | Buffer | string;
}
```

Pass an empty array to clear the file selection.

## State Methods

### isVisible()

Check if the element is visible.

```typescript  theme={null}
await locator.isVisible(): Promise<boolean>
```

**Returns:** `Promise<boolean>` - `true` if element is attached and visible.

### isChecked()

Check if a checkbox or radio button is checked.

```typescript  theme={null}
await locator.isChecked(): Promise<boolean>
```

**Returns:** `Promise<boolean>` - `true` if checked. Also considers `aria-checked` for ARIA widgets.

### inputValue()

Get the current value of an input element.

```typescript  theme={null}
await locator.inputValue(): Promise<string>
```

**Returns:** `Promise<string>` - The element's input value.

Works with: `<input>`, `<textarea>`, `<select>`, contenteditable elements.

### textContent()

Get the element's text content (raw).

```typescript  theme={null}
await locator.textContent(): Promise<string>
```

**Returns:** `Promise<string>` - The element's `textContent` property.

### innerText()

Get the element's visible text (layout-aware).

```typescript  theme={null}
await locator.innerText(): Promise<string>
```

**Returns:** `Promise<string>` - The element's `innerText` property.

### innerHtml()

Get the element's HTML content.

```typescript  theme={null}
await locator.innerHtml(): Promise<string>
```

**Returns:** `Promise<string>` - The element's `innerHtml`.

## Selection Methods

### count()

Get the number of elements matching the selector.

```typescript  theme={null}
await locator.count(): Promise<number>
```

**Returns:** `Promise<number>` - Count of matching elements.

### nth()

Get a locator for the element at a specific index.

```typescript  theme={null}
locator.nth(index: number): Locator
```

<ParamField path="index" type="number" required>
  Zero-based index of the element to select.
</ParamField>

**Returns:** `Locator` - New locator targeting the nth element.

```typescript  theme={null}
// Get the third button
const thirdButton = page.locator("button").nth(2);
await thirdButton.click();
```

### first()

Get a locator for the first matching element.

```typescript  theme={null}
locator.first(): Locator
```

**Returns:** `Locator` - Returns the same locator (querySelector already returns first match).

## Utility Methods

### highlight()

Visually highlight the element with an overlay.

```typescript  theme={null}
await locator.highlight(options?: HighlightOptions): Promise<void>
```

<ParamField path="durationMs" type="number" optional>
  How long to display the highlight in milliseconds.

  **Default:** `800`
</ParamField>

<ParamField path="borderColor" type="{ r, g, b, a? }" optional>
  Border color RGBA values (0-255).

  **Default:** `{ r: 255, g: 0, b: 0, a: 0.9 }` (red)
</ParamField>

<ParamField path="contentColor" type="{ r, g, b, a? }" optional>
  Content fill color RGBA values (0-255).

  **Default:** `{ r: 255, g: 200, b: 0, a: 0.2 }` (yellow)
</ParamField>

Useful for debugging and visual verification.

### scrollTo()

Scroll the element to a specific position.

```typescript  theme={null}
await locator.scrollTo(percent: number | string): Promise<void>
```

<ParamField path="percent" type="number | string" required>
  Scroll position as percentage (0-100).
</ParamField>

For `<html>` or `<body>` elements, scrolls the window. Otherwise, scrolls the element itself.

### centroid()

Get the center coordinates of the element.

```typescript  theme={null}
await locator.centroid(): Promise<{ x: number; y: number }>
```

**Returns:** `Promise<{ x, y }>` - Center point in CSS pixels.

### backendNodeId()

Get the DOM backend node ID for the element.

```typescript  theme={null}
await locator.backendNodeId(): Promise<BackendNodeId>
```

**Returns:** `Promise<BackendNodeId>` - Unique identifier for the DOM node.

Useful for identity comparisons without maintaining element handles.

### sendClickEvent()

Dispatch a DOM click event directly on the element.

```typescript  theme={null}
await locator.sendClickEvent(options?: EventOptions): Promise<void>
```

<ParamField path="bubbles" type="boolean" optional>
  Whether the event bubbles.

  **Default:** `true`
</ParamField>

<ParamField path="cancelable" type="boolean" optional>
  Whether the event is cancelable.

  **Default:** `true`
</ParamField>

<ParamField path="composed" type="boolean" optional>
  Whether the event crosses shadow DOM boundaries.

  **Default:** `true`
</ParamField>

<ParamField path="detail" type="number" optional>
  Click count detail.

  **Default:** `1`
</ParamField>

This dispatches an event directly without synthesizing real pointer input. Useful for elements that rely on click handlers without needing hit-testing.

## Code Examples

<Tabs>
  <Tab title="Basic Interaction">
    ```typescript  theme={null}
    import { Stagehand } from "@browserbasehq/stagehand";

    // Initialize with Browserbase (API key and project ID from environment variables)
    // Set BROWSERBASE_API_KEY and BROWSERBASE_PROJECT_ID in your environment
    const stagehand = new Stagehand({ env: "BROWSERBASE" });
    await stagehand.init();
    const page = stagehand.context.pages()[0];

    await page.goto("https://example.com");

    // Click a button
    const submitButton = page.locator("button[type=submit]");
    await submitButton.click();

    // Fill an input
    const emailInput = page.locator("input[name=email]");
    await emailInput.fill("user@example.com");

    // Type with delay
    const searchBox = page.locator("input[type=search]");
    await searchBox.type("stagehand", { delay: 100 });

    await stagehand.close();
    ```
  </Tab>

  <Tab title="Forms">
    ```typescript  theme={null}
    // Fill multiple form fields
    const form = page.locator("form#login");

    await page.locator("#username").fill("myuser");
    await page.locator("#password").fill("mypass");

    // Select from dropdown
    await page.locator("select#country").selectOption("US");

    // Multi-select
    await page.locator("select#skills").selectOption(["js", "ts", "react"]);

    // Check checkbox
    const termsCheckbox = page.locator("input#terms");
    const isChecked = await termsCheckbox.isChecked();
    if (!isChecked) {
      await termsCheckbox.click();
    }

    // Submit
    await page.locator("button[type=submit]").click();
    ```
  </Tab>

  <Tab title="File Upload">
    ```typescript  theme={null}
    // Upload from file path
    const fileInput = page.locator("input[type=file]");
    await fileInput.setInputFiles("/path/to/document.pdf");

    // Upload multiple files
    await fileInput.setInputFiles([
      "/path/to/image1.jpg",
      "/path/to/image2.jpg"
    ]);

    // Upload from buffer
    await fileInput.setInputFiles({
      name: "data.json",
      mimeType: "application/json",
      buffer: JSON.stringify({ key: "value" })
    });

    // Clear file selection
    await fileInput.setInputFiles([]);
    ```
  </Tab>

  <Tab title="Element Selection">
    ```typescript  theme={null}
    // Count elements
    const buttons = page.locator("button");
    const count = await buttons.count();
    console.log(`Found ${count} buttons`);

    // Click the first button
    await buttons.first().click();

    // Click the third button
    await buttons.nth(2).click();

    // Iterate with nth
    for (let i = 0; i < count; i++) {
      const button = buttons.nth(i);
      const text = await button.innerText();
      console.log(`Button ${i}: ${text}`);
    }
    ```
  </Tab>

  <Tab title="State Checks">
    ```typescript  theme={null}
    // Check visibility
    const modal = page.locator(".modal");
    if (await modal.isVisible()) {
      console.log("Modal is visible");
    }

    // Check checkbox state
    const checkbox = page.locator("input#subscribe");
    const checked = await checkbox.isChecked();
    console.log("Subscribed:", checked);

    // Get input value
    const email = page.locator("input#email");
    const value = await email.inputValue();
    console.log("Email:", value);

    // Get text content
    const heading = page.locator("h1");
    const text = await heading.textContent();
    console.log("Heading:", text);
    ```
  </Tab>

  <Tab title="Advanced Actions">
    ```typescript  theme={null}
    // Hover to reveal menu
    const menuButton = page.locator("button.menu");
    await menuButton.hover();

    // Wait for submenu
    await page.waitForLoadState("networkidle");

    // Click submenu item
    await page.locator("a.submenu-item").click();

    // Highlight for debugging
    await page.locator("div.error").highlight({
      durationMs: 2000,
      borderColor: { r: 255, g: 0, b: 0 },
      contentColor: { r: 255, g: 0, b: 0, a: 0.1 }
    });

    // Scroll element into position
    const section = page.locator("#section-3");
    await section.scrollTo(50); // Scroll to 50%

    // Get element position
    const { x, y } = await section.centroid();
    console.log(`Element center: ${x}, ${y}`);
    ```
  </Tab>
</Tabs>

## Selector Support

Locators support both CSS and XPath selectors:

### CSS Selectors

```typescript  theme={null}
page.locator("button");                    // Tag
page.locator(".submit-btn");              // Class
page.locator("#login-form");              // ID
page.locator("button.primary");           // Tag + class
page.locator("input[type=email]");        // Attribute
page.locator("div > p");                  // Child
page.locator("h1 + p");                   // Adjacent sibling
page.locator("div.container button");     // Descendant
```

### XPath Selectors

```typescript  theme={null}
page.locator("//button");                               // Tag
page.locator("//button[@class='submit']");             // Attribute
page.locator("//div[@id='content']//p");               // Descendant
page.locator("//button[contains(text(), 'Submit')]");  // Text content
page.locator("(//button)[1]");                         // First button
page.locator("//input[@type='text'][1]");              // First text input
```

## Best Practices

1. **Use specific selectors** - Prefer IDs or unique attributes over generic selectors
2. **Chain with nth()** - Use `locator().nth()` instead of putting index in selector
3. **Check state before action** - Use `isVisible()`, `isChecked()` for conditional logic
4. **Let locators auto-resolve** - Don't store element handles, use locators which re-resolve
5. **Use fill() for inputs** - Prefer `fill()` over `click()` + `type()` for better reliability
6. **Handle file uploads properly** - Use absolute paths or buffer payloads for `setInputFiles()`
7. **Highlight for debugging** - Use `highlight()` during development to verify targeting

## Common Patterns

### Conditional Interaction

```typescript  theme={null}
const errorMessage = page.locator(".error-message");
if (await errorMessage.isVisible()) {
  const text = await errorMessage.textContent();
  console.log("Error:", text);
}
```

### Wait and Interact

```typescript  theme={null}
// Locators automatically wait during actions
const dynamicButton = page.locator("button.dynamic");
await dynamicButton.click(); // Waits for element to exist
```

### Loop Through Elements

```typescript  theme={null}
const items = page.locator("li.item");
const count = await items.count();

for (let i = 0; i < count; i++) {
  const item = items.nth(i);
  const text = await item.innerText();
  console.log(`Item ${i}:`, text);
}
```

## Error Handling

Locator methods may throw the following errors:

* **Element not found** - Selector doesn't match any elements
* **Element not visible** - Element exists but is not visible (for actions requiring visibility)
* **Invalid selector** - Malformed CSS or XPath selector
* **Timeout errors** - Operation exceeded timeout limits
* **CDP errors** - Chrome DevTools Protocol communication errors

Handle errors appropriately:

```typescript  theme={null}
try {
  await page.locator("button.submit").click();
} catch (error) {
  console.error("Click failed:", error.message);
}
```

## Type Definitions

```typescript  theme={null}
interface Locator {
  // Actions
  click(options?: { button?: MouseButton; clickCount?: number }): Promise<void>;
  fill(value: string): Promise<void>;
  type(text: string, options?: { delay?: number }): Promise<void>;
  hover(): Promise<void>;
  selectOption(values: string | string[]): Promise<string[]>;
  setInputFiles(files: FileInput): Promise<void>;

  // State
  isVisible(): Promise<boolean>;
  isChecked(): Promise<boolean>;
  inputValue(): Promise<string>;
  textContent(): Promise<string>;
  innerText(): Promise<string>;
  innerHtml(): Promise<string>;

  // Selection
  count(): Promise<number>;
  nth(index: number): Locator;
  first(): Locator;

  // Utilities
  highlight(options?: HighlightOptions): Promise<void>;
  scrollTo(percent: number | string): Promise<void>;
  centroid(): Promise<{ x: number; y: number }>;
  backendNodeId(): Promise<BackendNodeId>;
  sendClickEvent(options?: EventOptions): Promise<void>;
}
```
# deepLocator

> Complete API reference for the deepLocator method

<CardGroup cols={1}>
  <Card title="Locator" icon="crosshairs" href="/v3/references/locator">
    Learn about the standard Locator class
  </Card>
</CardGroup>

## Overview

The `deepLocator()` method creates a special locator that can traverse iframe boundaries and shadow DOM using a simplified syntax. It automatically resolves the correct frame for each operation, making cross-frame interactions seamless.

Access via the page object:

```typescript  theme={null}
const stagehand = new Stagehand({ env: "BROWSERBASE" });
await stagehand.init();
const page = stagehand.context.pages()[0];

// Deep locator with iframe traversal
const button = page.deepLocator("iframe#myframe >> button.submit");
await button.click();
```

## Syntax

### page.deepLocator()

Create a deep locator that can cross iframe and shadow DOM boundaries.

```typescript  theme={null}
page.deepLocator(selector: string): DeepLocatorDelegate
```

<ParamField path="selector" type="string" required>
  Selector string with optional iframe hop notation (`>>`).

  Supports:

  * **CSS selectors** - Standard CSS syntax
  * **XPath** - Prefix with `xpath=` or start with `/`
  * **Hop notation** - Use `>>` to traverse into iframes
  * **Deep XPath** - Automatically handles iframe steps in XPath
</ParamField>

**Returns:** `DeepLocatorDelegate` - A locator-like object that resolves frames on each action.

## Hop Notation

The `>>` operator allows you to traverse into iframes in a readable way:

```typescript  theme={null}
// Syntax: parent-selector >> child-selector >> target-selector
page.deepLocator("iframe#outer >> iframe.inner >> button")
```

Each segment before `>>` represents an iframe to traverse into. The final segment is the target element.

### Examples

```typescript  theme={null}
// Single iframe hop
page.deepLocator("iframe#payment >> input#card-number")

// Multiple iframe hops
page.deepLocator("iframe#level1 >> iframe#level2 >> div.content")

// XPath with hops
page.deepLocator("//iframe[@id='myframe'] >> //button[@class='submit']")

// CSS with XPath target
page.deepLocator("iframe.widget >> xpath=//div[@data-id='123']")
```

## Deep XPath

When using XPath, `deepLocator` automatically recognizes `iframe` steps and traverses into them:

```typescript  theme={null}
// Automatically traverses into iframes
page.deepLocator("//iframe//button")
page.deepLocator("//iframe[@id='myframe']//input[@name='email']")
page.deepLocator("//iframe[1]//iframe[2]//div[@class='target']")
```

The locator intelligently parses the XPath, identifies iframe boundaries, and resolves the correct frame for the final selector.

## Methods

`DeepLocatorDelegate` provides the same API as `Locator`, with automatic frame resolution:

### Interaction Methods

All interaction methods from [`Locator`](/v3/references/locator) are available:

* **`click(options?)`** - Click the element
* **`fill(value)`** - Fill an input
* **`type(text, options?)`** - Type text
* **`hover()`** - Hover over element
* **`selectOption(values)`** - Select dropdown options
* **`scrollTo(percent)`** - Scroll element

### State Methods

* **`isVisible()`** - Check visibility
* **`isChecked()`** - Check checkbox state
* **`inputValue()`** - Get input value
* **`textContent()`** - Get text content
* **`innerText()`** - Get visible text
* **`innerHtml()`** - Get HTML content

### Selection Methods

* **`count()`** - Count matching elements
* **`nth(index)`** - Select by index
* **`first()`** - Get first element

### Utility Methods

* **`highlight(options?)`** - Highlight element
* **`centroid()`** - Get center coordinates
* **`backendNodeId()`** - Get DOM node ID
* **`sendClickEvent(options?)`** - Dispatch click event

All methods work identically to `Locator`, but automatically resolve the correct frame before executing.

## Code Examples

<Tabs>
  <Tab title="Basic Iframe Traversal">
    ```typescript  theme={null}
    import { Stagehand } from "@browserbasehq/stagehand";

    // Initialize with Browserbase (API key and project ID from environment variables)
    // Set BROWSERBASE_API_KEY and BROWSERBASE_PROJECT_ID in your environment
    const stagehand = new Stagehand({ env: "BROWSERBASE" });
    await stagehand.init();
    const page = stagehand.context.pages()[0];

    await page.goto("https://example.com");

    // Click button inside iframe
    const button = page.deepLocator("iframe#widget >> button.submit");
    await button.click();

    // Fill input in nested iframe
    const input = page.deepLocator("iframe#outer >> iframe#inner >> input#email");
    await input.fill("user@example.com");

    await stagehand.close();
    ```
  </Tab>

  <Tab title="Multiple Iframes">
    ```typescript  theme={null}
    // Three-level iframe nesting
    await page.deepLocator(
      "iframe#level1 >> iframe#level2 >> iframe#level3 >> div.target"
    ).click();

    // Different selectors at each level
    await page.deepLocator(
      "iframe.container >> #payment-frame >> input[name=cardNumber]"
    ).fill("4111111111111111");

    // Mixed CSS and XPath
    await page.deepLocator(
      "iframe.widget >> xpath=//button[contains(text(), 'Submit')]"
    ).click();
    ```
  </Tab>

  <Tab title="Deep XPath">
    ```typescript  theme={null}
    // Simple iframe traversal with XPath
    const content = page.deepLocator("//iframe//div[@class='content']");
    const text = await content.textContent();

    // Multiple iframe levels
    const button = page.deepLocator(
      "//iframe[@id='outer']//iframe[@class='inner']//button"
    );
    await button.click();

    // XPath with predicates
    const input = page.deepLocator(
      "//iframe[1]//form[@id='myform']//input[@type='text'][1]"
    );
    await input.fill("test value");
    ```
  </Tab>

  <Tab title="Element Selection">
    ```typescript  theme={null}
    // Count elements across iframes
    const buttons = page.deepLocator("iframe#widget >> button");
    const count = await buttons.count();
    console.log(`Found ${count} buttons in iframe`);

    // Select specific element
    const firstButton = buttons.first();
    await firstButton.click();

    const thirdButton = buttons.nth(2);
    await thirdButton.click();

    // Get text from all elements
    for (let i = 0; i < count; i++) {
      const btn = buttons.nth(i);
      const text = await btn.innerText();
      console.log(`Button ${i}:`, text);
    }
    ```
  </Tab>

  <Tab title="Payment Forms">
    ```typescript  theme={null}
    // Common use case: payment iframe
    const paymentFrame = "iframe#stripe-payment-element";

    // Fill card details
    await page.deepLocator(`${paymentFrame} >> input[name="cardnumber"]`)
      .fill("4242424242424242");

    await page.deepLocator(`${paymentFrame} >> input[name="exp-date"]`)
      .fill("12/25");

    await page.deepLocator(`${paymentFrame} >> input[name="cvc"]`)
      .fill("123");

    await page.deepLocator(`${paymentFrame} >> input[name="postal"]`)
      .fill("12345");

    // Submit
    await page.deepLocator(`${paymentFrame} >> button[type="submit"]`)
      .click();
    ```
  </Tab>

  <Tab title="State Checks">
    ```typescript  theme={null}
    // Check visibility across iframe
    const modal = page.deepLocator("iframe#app >> .modal");
    if (await modal.isVisible()) {
      console.log("Modal is visible in iframe");
    }

    // Get values from iframe inputs
    const email = page.deepLocator("iframe#form >> input#email");
    const value = await email.inputValue();
    console.log("Email value:", value);

    // Check checkbox in iframe
    const checkbox = page.deepLocator("iframe#settings >> input#subscribe");
    const checked = await checkbox.isChecked();
    console.log("Subscribed:", checked);

    // Highlight element in iframe for debugging
    await page.deepLocator("iframe#widget >> .error-message")
      .highlight({ durationMs: 2000 });
    ```
  </Tab>
</Tabs>

## Comparison with Standard Locator

### Standard Locator (Single Frame)

```typescript  theme={null}
// Only works in the main frame
const button = page.locator("button.submit");
await button.click();

// Cannot access elements inside iframes
const iframeButton = page.locator("iframe >> button"); // ❌ Won't work
```

### Deep Locator (Cross-Frame)

```typescript  theme={null}
// Works across iframe boundaries
const button = page.deepLocator("iframe#widget >> button.submit");
await button.click(); // ✅ Automatically traverses into iframe

// Can handle nested iframes
const nested = page.deepLocator("iframe#a >> iframe#b >> button");
await nested.click(); // ✅ Handles multiple levels
```

## When to Use deepLocator

Use `deepLocator()` when:

1. **Targeting elements inside iframes** - Payment forms, embedded widgets, third-party content
2. **Working with nested iframes** - Multiple levels of iframe nesting
3. **XPath crosses iframe boundaries** - When XPath naturally includes iframe steps
4. **Simpler syntax preferred** - Use `>>` instead of manual frame switching

Use standard `locator()` when:

1. **Elements are in main frame** - No iframe traversal needed
2. **Performance critical** - Standard locator is slightly faster (no frame resolution)
3. **Working with frame references** - You already have the frame object

## Best Practices

1. **Use specific selectors** - Make each segment unique to avoid ambiguity
2. **Keep hop chains short** - Simpler is better for maintainability
3. **Name your iframes** - Use IDs or classes on iframes for easier targeting
4. **Test incrementally** - Verify each segment works before adding more
5. **Cache selectors** - Store complex selectors in variables for reuse
6. **Use highlight() for debugging** - Verify you're targeting the right element

## Common Patterns

### Named Iframe References

```typescript  theme={null}
// Define iframe selectors
const PAYMENT_FRAME = "iframe#stripe-payment";
const WIDGET_FRAME = "iframe.embedded-widget";

// Use in deep locators
await page.deepLocator(`${PAYMENT_FRAME} >> input#card`).fill("4242");
await page.deepLocator(`${WIDGET_FRAME} >> button`).click();
```

### Conditional Iframe Interaction

```typescript  theme={null}
const errorInIframe = page.deepLocator("iframe#form >> .error-message");
if (await errorInIframe.isVisible()) {
  const errorText = await errorInIframe.textContent();
  console.error("Form error:", errorText);
}
```

### Dynamic Frame Selection

```typescript  theme={null}
// Select iframe by attribute
const frameSelector = `iframe[data-widget-id="${widgetId}"]`;
const button = page.deepLocator(`${frameSelector} >> button.action`);
await button.click();
```

## Error Handling

Deep locator operations may throw:

* **Element not found** - Selector doesn't match in the target frame
* **Frame not found** - Iframe selector doesn't resolve
* **Timeout errors** - Frame or element resolution timed out
* **Invalid selector** - Malformed selector syntax

Handle errors appropriately:

```typescript  theme={null}
try {
  await page.deepLocator("iframe#widget >> button").click();
} catch (error) {
  console.error("Deep locator failed:", error.message);
  // Fallback or retry logic
}
```

## Advanced Usage

### Combining with Page Methods

```typescript  theme={null}
// Navigate then use deep locator
await page.goto("https://example.com");
await page.waitForLoadState("networkidle");

const iframeButton = page.deepLocator("iframe#app >> button");
await iframeButton.click();
```

### With AI-Powered Methods

```typescript  theme={null}
// Use observe to find elements in iframes
const actions = await stagehand.observe("find buttons in the payment iframe");

// Then use deep locator for precise interaction
await page.deepLocator("iframe#payment >> button.submit").click();
```

## Technical Details

### How It Works

1. **Parse selector** - Splits on `>>` or parses XPath for iframe steps
2. **Build frame chain** - Creates FrameLocator chain for each iframe segment
3. **Resolve final frame** - Navigates through frames to find target frame
4. **Create locator** - Returns a locator in the correct frame context
5. **Lazy execution** - Frame resolution happens fresh on each action

### Frame Resolution

Deep locators use the internal `FrameLocator` and `resolveLocatorWithHops` logic to:

* Track frame hierarchies
* Handle OOPIF (out-of-process iframes)
* Support shadow DOM piercing
* Maintain frame references during navigation

## Type Definitions

```typescript  theme={null}
interface DeepLocatorDelegate {
  // Actions
  click(options?: { button?: MouseButton; clickCount?: number }): Promise<void>;
  fill(value: string): Promise<void>;
  type(text: string, options?: { delay?: number }): Promise<void>;
  hover(): Promise<void>;
  selectOption(values: string | string[]): Promise<string[]>;
  scrollTo(percent: number | string): Promise<void>;

  // State
  isVisible(): Promise<boolean>;
  isChecked(): Promise<boolean>;
  inputValue(): Promise<string>;
  textContent(): Promise<string>;
  innerText(): Promise<string>;
  innerHtml(): Promise<string>;

  // Selection
  count(): Promise<number>;
  nth(index: number): DeepLocatorDelegate;
  first(): DeepLocatorDelegate;

  // Utilities
  highlight(options?: HighlightOptions): Promise<void>;
  centroid(): Promise<{ x: number; y: number }>;
  backendNodeId(): Promise<BackendNodeId>;
  sendClickEvent(options?: EventOptions): Promise<void>;
}
```
# Response

> Complete API reference for the Response object

<CardGroup cols={1}>
  <Card title="Navigation" icon="compass" href="/v3/references/page">
    See how pages expose Response objects from navigation methods
  </Card>
</CardGroup>

## Overview

`Response` mirrors Playwright’s [Response](https://playwright.dev/docs/api/class-response) interface and is returned from Stagehand navigation helpers such as `page.goto()`, `page.reload()`, `page.goBack()`, and `page.goForward()`. It provides a convenient way to inspect the HTTP metadata associated with a navigation, retrieve the response body on demand, and monitor when the underlying request finishes.

Stagehand automatically returns `null` for navigations that do not yield a network request (for example `data:` URLs, `about:blank`, or same-document history changes), matching Playwright’s behaviour.

## Getting a Response

```typescript  theme={null}
const response = await page.goto("https://example.com", {
  waitUntil: "networkidle",
});

if (!response) {
  throw new Error("Navigation did not produce a network response");
}

console.log("Status", response.status(), response.statusText());
const body = await response.text();
```

When a navigation does not produce a response object you will receive `null`, allowing you to branch early:

```typescript  theme={null}
const inline = await page.goto("data:text/html,<h1>inline</h1>");
if (inline === null) {
  // No network fetch happened; handle accordingly
}
```

## Status & Metadata

### url()

```typescript  theme={null}
response.url(): string
```

Returns the final URL associated with the navigation request.

### status()

```typescript  theme={null}
response.status(): number
```

Returns the HTTP status code.

### statusText()

```typescript  theme={null}
response.statusText(): string
```

Returns the human-readable status text (for example `OK`).

### ok()

```typescript  theme={null}
response.ok(): boolean
```

Convenience helper that resolves to `true` for 2xx responses and `false` otherwise.

### frame()

```typescript  theme={null}
response.frame(): Frame | null
```

Returns the Stagehand `Frame` that initiated the navigation. When the frame is no longer available, `null` is returned.

### fromServiceWorker()

```typescript  theme={null}
response.fromServiceWorker(): boolean
```

Indicates whether the response was served from a Service Worker fetch handler.

### securityDetails()

```typescript  theme={null}
await response.securityDetails(): Promise<Protocol.Network.SecurityDetails | null>
```

Resolves with TLS/security metadata when available (issuer, protocol, validity window). Returns `null` for insecure or non-network responses.

### serverAddr()

```typescript  theme={null}
await response.serverAddr(): Promise<{ ipAddress: string; port: number } | null>
```

Provides the remote IP/port reported by Chrome, when known.

## Header Helpers

### headers()

```typescript  theme={null}
response.headers(): Record<string, string>
```

Returns a lowercase header map, matching Playwright’s `headers()` behaviour.

### allHeaders()

```typescript  theme={null}
await response.allHeaders(): Promise<Record<string, string>>
```

Includes additional headers only surfaced via Chrome’s `responseReceivedExtraInfo` event (such as `set-cookie`).

### headerValue()

```typescript  theme={null}
await response.headerValue(name: string): Promise<string | null>
```

Returns a comma-joined string of all values for the specified header. Resolves to `null` when the header is absent.

### headerValues()

```typescript  theme={null}
await response.headerValues(name: string): Promise<string[]>
```

Returns an array of header values, keeping multiple entries separate.

### headersArray()

```typescript  theme={null}
await response.headersArray(): Promise<Array<{ name: string; value: string }>>
```

Returns the header list while preserving the original casing and order reported by the browser.

## Body Helpers

### body()

```typescript  theme={null}
await response.body(): Promise<Buffer>
```

Fetches the raw response body. The buffer is base64-decoded for you when Chrome sends it that way.

### text()

```typescript  theme={null}
await response.text(): Promise<string>
```

Returns the response body decoded as UTF-8 text.

### json()

```typescript  theme={null}
await response.json<T = unknown>(): Promise<T>
```

Parses the response body as JSON. Throws if the body cannot be parsed or is not valid JSON.

<Note>
  All body helper calls (`body()`, `text()`, `json()`) only succeed once the browser reports the response body is available. Stagehand handles this timing automatically.
</Note>

## Completion

### finished()

```typescript  theme={null}
await response.finished(): Promise<null | Error>
```

Resolves to `null` when the main navigation request completes successfully, or to an `Error` if Chrome reports `Network.loadingFailed`. This mirrors Playwright’s `response.finished()` contract and is especially helpful for catching late failures such as network resets or blocked responses.

```typescript  theme={null}
const result = await response.finished();
if (result instanceof Error) {
  console.error("Navigation failed", result.message);
}
```

## Usage Patterns

### Inspect status and headers

```typescript  theme={null}
const response = await page.goto("https://httpbin.org/headers");

if (response) {
  console.log(response.status(), response.statusText());
  const headers = await response.headersArray();
  headers.forEach(({ name, value }) => {
    console.log(`${name}: ${value}`);
  });
}
```

### Handle non-network navigations

```typescript  theme={null}
const result = await page.goto("data:text/html,<p>inline</p>");

if (result === null) {
  console.log("No network response (data URL)");
} else {
  // Process as usual
}
```

### Await completion

```typescript  theme={null}
const response = await page.goto("https://example.com/slow");

if (response) {
  const finished = await response.finished();
  if (finished instanceof Error) {
    console.error("Navigation failed", finished.message);
  }
}
```

## Returned From

* `await page.goto(url, options?)`
* `await page.reload(options?)`
* `await page.goBack(options?)`
* `await page.goForward(options?)`

Each method resolves with `Response | null` depending on whether Chrome reported a document-level network response.

## See Also

* [Page reference](/v3/references/page) for details on navigation helpers
